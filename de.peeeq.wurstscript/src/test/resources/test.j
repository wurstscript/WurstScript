// this script was compiled with wurst 1.8.0.0-798bf1b7
globals
rect w=null
rect u=null
rect r=null
rect s=null
rect t=null
rect i=null
rect S=null
rect c=null
rect o=null
rect O=null
rect l=null
rect b=null
camerasetup y=null
camerasetup p=null
camerasetup e=null
camerasetup q=null
camerasetup a=null
trigger n=null
trigger d=null
trigger f=null
unit R=null
unit T=null
string Y=null
string G=null
string g=null
string h=null
string F=null
string k=null
string j=null
string x=null
string v=null
string m=null
string Q=null
string W=null
string E=null
string Z=null
string U=null
string I=null
string P=null
string A=null
string D=null
string H=null
string J=null
string K=null
string L=null
real X=0.
real C=0.
real V=0.
integer B=0
integer N=0
real array M
integer array ww
integer array uw
integer array rw
real sw=0.
integer tw=0
integer iw=0
integer Sw=0
player cw=null
integer array ow
integer array Ow
integer array lw
integer array bw
integer yw=0
integer pw=0
integer ew=0
integer array qw
integer array aw
integer array nw
integer array dw
integer array fw
integer array Rw
string array Tw
integer array Yw
integer array Gw
real array gw
real array hw
integer Fw=0
integer kw=0
integer jw=0
real array xw
integer vw=0
integer mw=0
integer Qw=0
integer Ww=0
integer Ew=0
integer array Zw
integer array Uw
integer array Iw
integer array Pw
integer array Aw
integer array Dw
real array Hw
integer Jw=0
effect array Kw
real Lw=0.
real Xw=0.
real Cw=0.
real Vw=0.
integer array Bw
unit array Nw
integer array Mw
integer array wu
integer array uu
real array ru
integer array su
integer array tu
boolean array iu
integer Su=0
integer cu=0
integer ou=0
integer array Ou
integer array lu
integer array bu
effect array yu
playerevent pu=null
trigger eu=null
trigger qu=null
trigger au=null
integer array nu
integer du=0
integer fu=0
integer Ru=0
integer array Tu
integer array Yu
integer array Gu
integer array gu
integer array hu
integer array Fu
integer array ku
integer array ju
unit array xu
group vu=null
integer array mu
integer Qu=0
filterfunc Wu=null
integer Eu=0
integer array Zu
timer array Uu
timer array Iu
timer array Pu
integer Au=0
integer Du=0
integer Hu=0
integer Ju=0
integer Ku=0
integer Lu=0
integer Xu=0
integer Cu=0
integer Vu=0
integer array Bu
integer array Nu
integer array Mu
string array wr
integer ur=0
player rr=null
item array sr
integer array tr
boolean array ir
integer array Sr
integer array cr
real array lr
real array br
multiboard yr=null
integer pr=0
integer er=0
integer qr=0
integer ar=0
integer nr=0
integer dr=0
integer fr=0
boolean Rr=false
integer Tr=0
integer Yr=0
integer Gr=0
integer gr=0
integer hr=0
real Fr=0.
real kr=0.
real jr=0.
boolean array xr
integer array vr
integer array mr
real array Qr
real array Wr
integer array Er
integer array Zr
integer array Ur
integer array Ir
integer array Pr
integer array Ar
integer array Dr
integer Hr=0
integer Jr=0
timer Kr=null
trigger array Lr
unit array Xr
unit array Cr
real array Vr
real array Br
real array Nr
real array Mr
boolean array ws
boolean array us
integer rs=0
integer ss=0
integer ts=0
integer array is
integer array Ss
integer cs=0
integer os=0
real Os=0.
integer ls=0
integer array bs
integer array ys
integer array ps
timer es=null
unit array qs
real array as
integer array ns
integer ds=0
integer fs=0
integer array Rs
integer Ts=0
integer array Ys
integer array Gs
integer array gs
integer array hs
integer array Fs
integer array ks
integer array js
integer array xs
integer array vs
integer array ms
integer array Qs
integer array Ws
integer array Es
integer array Zs
integer array Us
integer array Is
integer array Ps
integer array As
integer array Ds
integer array Hs
integer array Js
integer array Ks
integer array Ls
integer array Xs
integer array Cs
string array Vs
integer array Bs
real array Ns
integer array Ms
integer array wt
integer array ut
integer array rt
integer st=0
integer tt=0
integer St=0
real ct=0.
real ot=0.
real Ot=0.
integer lt=0
integer array bt
integer array yt
boolean array pt
integer array et
integer array qt
integer array at
timer array nt
integer array dt
integer array ft
string array Rt
boolean Tt=false
integer Yt=0
integer Gt=0
integer array gt
real array ht
real array Ft
real array kt
real array jt
real array xt
real array vt
real array mt
real array Qt
real array Wt
player array Et
boolean array Zt
boolean array Ut
boolean array It
integer array Pt
integer At=0
integer Dt=0
integer Ht=0
integer Jt=0
integer Kt=0
integer Lt=0
integer array Xt
integer array Ct
boolean array Vt
integer array Bt
unit array Nt
integer Mt=0
integer wi=0
hashtable ui=null
string ri=null
boolean si=false
force ti=null
boolean array ii
integer array Si
integer ci=0
integer array oi
integer array Oi
integer array li
integer bi=0
integer array yi
texttag array pi
boolean array ei
real array qi
integer array ai
integer ni=0
integer di=0
integer fi=0
integer array Ri
integer array Ti
integer array Yi
boolean array Gi
string gi=null
real hi=0.
integer Fi=0
integer array ki
integer array ji
boolean xi=false
boolean vi=false
boolean mi=false
boolean Qi=false
integer array Wi
boolean array Ei
unit array Zi
effect array Ui
integer array Ii
integer array Pi
integer array Ai
integer array Di
timer Hi=null
real Ji=0.
integer Ki=0
integer array Li
integer array Xi
integer array Ci
integer array Vi
timer Bi=null
real Ni=0.
integer Mi=0
integer wS=0
integer uS=0
integer rS=0
group array sS
integer tS=0
integer iS=0
boolean SS=false
integer array cS
boolean oS=false
group OS=null
group lS=null
hashtable bS=null
hashtable yS=null
integer array pS
integer array eS
integer qS=0
real array aS
integer array nS
real array dS
real fS=0.
string RS=null
string TS=null
integer array YS
integer array GS
real array gS
integer array hS
real array FS
real array kS
real array jS
real array xS
integer array vS
integer array mS
integer array QS
integer WS=0
real ES=0.
real ZS=0.
integer US=0
integer IS=0
multiboard PS=null
integer array AS
string array DS
integer HS=0
integer JS=0
string KS=null
string LS=null
integer array XS
integer array CS
integer array VS
integer array BS
integer array NS
integer array MS
integer array wc
integer array uc
integer array rc
string array sc
integer array tc
integer array ic
integer array Sc
integer array cc
integer oc=0
integer Oc=0
integer lc=0
integer array bc
integer array yc
integer array pc
integer array ec
integer qc=0
string ac=null
integer nc=0
integer dc=0
integer array fc
integer array Rc
integer array Tc
integer array Yc
integer array Gc
integer array gc
integer array hc
integer array Fc
integer array kc
integer array jc
integer array xc
integer array vc
integer array mc
integer array Qc
integer array Wc
integer array Ec
integer array Zc
integer array Uc
integer array Ic
integer array Pc
integer array Ac
integer array Dc
integer array Hc
string array Jc
string array Kc
integer array Lc
integer array Xc
integer array Cc
integer array Vc
integer array Bc
integer array Nc
integer array Mc
integer array wo
integer array uo
integer array ro
boolean array so
integer array io
integer array So
integer array co
integer array oo
integer array Oo
integer array lo
integer bo=0
integer yo=0
integer po=0
integer eo=0
real qo=0.
integer ao=0
integer no=0
integer do=0
item array fo
boolean Ro=false
rect To=null
rect Yo=null
region Go=null
real go=0.
real ho=0.
real Fo=0.
real ko=0.
real jo=0.
real xo=0.
real vo=0.
real mo=0.
real Qo=0.
multiboard Wo=null
string Eo=null
string Zo=null
string Uo=null
string Io=null
string Po=null
trigger Ao=null
group Do=null
unit array Ho
integer Jo=0
integer Ko=0
integer Lo=0
integer Xo=0
real Co=0.
integer array Vo
real array Bo
real array No
integer Mo=0
integer array wO
boolean uO=false
player array rO
integer array sO
boolean array tO
integer array iO
integer array SO
integer array cO
integer array oO
player array OO
player lO=null
playercolor bO=null
playercolor yO=null
playercolor pO=null
playercolor eO=null
playercolor array qO
boolean aO=false
group nO=null
unit dO=null
real array fO
real RO=0.
integer TO=0
real array YO
real array GO
real array gO
real array hO
boolean array FO
boolean array kO
real array jO
real array xO
real array vO
real array mO
real array QO
real WO=0.
trigger array EO
integer ZO=0
integer UO=0
integer IO=0
integer PO=0
integer AO=0
integer DO=0
integer HO=0
real array JO
string array KO
integer LO=0
integer XO=0
integer CO=0
integer VO=0
integer BO=0
integer NO=0
integer MO=0
integer wl=0
integer ul=0
integer rl=0
integer array sl
real array tl
real array il
real array Sl
real array cl
real array ol
real array Ol
real array ll
effect array bl
player array yl
integer array pl
integer array el
boolean array ql
timer array al
integer nl=0
integer dl=0
real array fl
real array Rl
real array Tl
integer Yl=0
integer Gl=0
string gl=null
integer hl=0
real Fl=0.
integer kl=0
integer jl=0
real xl=0.
real vl=0.
real ml=0.
real array Ql
real array Wl
real array El
real array Zl
integer array Ul
integer array Il
integer Pl=0
triggercondition Al=null
integer array Dl
integer array Hl
string array Jl
integer array Kl
boolean array Ll
boolean array Xl
boolean array Cl
integer array Vl
integer array Bl
string array Nl
real array Ml
real array wb
real array ub
sound array rb
integer array sb
unit array tb
player array ib
integer array Sb
string cb=null
string ob=null
string Ob=null
string lb=null
string bb=null
string yb=null
string pb=null
string eb=null
string qb=null
integer array ab
real array nb
real array db
integer fb=0
integer Rb=0
integer Tb=0
integer array Yb
real array Gb
real array gb
real array hb
real array Fb
real array kb
real array jb
real array xb
real array vb
real array mb
integer Qb=0
integer Wb=0
integer Eb=0
integer Zb=0
integer Ub=0
effect array Ib
real Pb=0.
integer array Ab
string array Db
string array Hb
integer Jb=0
string Kb=null
string Lb=null
integer Xb=0
integer Cb=0
unit array Vb
hashtable Bb=null
real Nb=0.
integer Mb=0
item wy=null
rect uy=null
item array ry
integer sy=0
integer array ty
real array iy
integer array Sy
integer array cy
integer array oy
integer array Oy
integer ly=0
integer by=0
boolean array yy
integer array py
timer array ey
integer qy=0
integer ay=0
integer ny=0
trigger dy=null
integer fy=0
integer Ry=0
integer Ty=0
real Yy=0.
real Gy=0.
integer gy=0
integer array hy
integer array Fy
effect array ky
integer jy=0
integer xy=0
integer vy=0
integer array my
integer Qy=0
integer Wy=0
integer Ey=0
real Zy=0.
integer Uy=0
player Iy=null
integer Py=0
real Ay=0.
integer Dy=0
integer Hy=0
integer Jy=0
trigger Ky=null
trigger Ly=null
integer array Xy
integer array Cy
integer array Vy
integer By=0
real Ny=0.
string My=null
trigger wp=null
trigger up=null
unit rp=null
unit sp=null
unit array tp
real ip=0.
integer Sp=0
integer cp=0
integer op=0
timer Op=null
boolean lp=false
integer bp=0
string yp=null
real pp=0.
real ep=0.
real qp=0.
real ap=0.
real np=0.
location dp=null
integer fp=0
integer Rp=0
integer Tp=0
integer array Yp
real array Gp
real array gp
real array hp
boolean array Fp
player array kp
integer jp=0
real xp=0.
integer array vp
group array mp
integer array Qp
integer array Wp
rect array Ep
integer Zp=0
real Up=0.
real Ip=0.
integer array Pp
integer array Ap
integer array Dp
integer array Hp
integer array Jp
integer array Kp
integer array Lp
integer array Xp
integer array Cp
integer array Vp
integer array Bp
integer array Np
integer array Mp
integer array we
integer array ue
integer array re
integer array se
integer array te
integer array ie
integer array Se
integer ce=0
integer oe=0
integer array Oe
integer array le
integer be=0
integer ye=0
integer array pe
integer array ee
integer qe=0
integer ae=0
integer array ne
integer array de
integer fe=0
integer Re=0
integer array Te
integer array Ye
integer Ge=0
integer ge=0
integer array he
integer array Fe
integer ke=0
integer je=0
integer array xe
integer array ve
integer me=0
integer Qe=0
integer array We
integer array Ee
integer Ze=0
integer Ue=0
integer array Ie
integer array Pe
integer Ae=0
integer De=0
integer array He
integer array Je
integer Ke=0
integer Le=0
integer array Xe
integer array Ce
integer Ve=0
integer Be=0
integer array Ne
integer Me=0
integer wq=0
integer array uq
integer array rq
integer sq=0
integer tq=0
integer array iq
integer array Sq
integer cq=0
integer oq=0
integer array Oq
integer array lq
integer bq=0
integer yq=0
integer array pq
integer array eq
integer qq=0
integer aq=0
integer array nq
integer array dq
integer fq=0
integer Rq=0
integer array Tq
integer array Yq
integer Gq=0
integer gq=0
integer array hq
integer Fq=0
integer kq=0
integer array jq
integer xq=0
integer vq=0
integer array mq
integer array Qq
integer Wq=0
integer Eq=0
integer array Zq
integer array Uq
integer Iq=0
integer Pq=0
integer array Aq
integer array Dq
integer Hq=0
integer Jq=0
integer array Kq
integer array Lq
integer Xq=0
integer Cq=0
integer array Vq
integer array Bq
integer Nq=0
integer Mq=0
integer array wa
integer array ua
integer ra=0
integer sa=0
integer array ta
integer array ia
integer Sa=0
integer ca=0
integer array oa
integer Oa=0
integer la=0
integer array ba
integer array ya
integer pa=0
integer ea=0
integer array qa
integer array aa
integer na=0
integer da=0
integer array fa
integer Ra=0
integer Ta=0
integer array Ya
integer array Ga
integer ga=0
integer ha=0
integer array Fa
integer array ka
integer ja=0
integer xa=0
integer array va
integer array ma
integer array Qa
integer Wa=0
integer Ea=0
integer array Za
integer array Ua
integer Ia=0
integer Pa=0
integer array Aa
integer array Da
integer Ha=0
integer Ja=0
integer array Ka
integer array La
integer array Xa
integer array Ca
integer Va=0
integer Ba=0
integer Na=0
integer array Ma
integer array wn
integer un=0
integer rn=0
integer array sn
integer array tn
integer Sn=0
integer cn=0
integer array on
integer array On
integer ln=0
integer bn=0
integer array yn
integer array pn
integer en=0
integer qn=0
integer array an
integer nn=0
integer dn=0
integer array fn
integer array Rn
integer Tn=0
integer Yn=0
integer Gn=0
integer array gn
integer hn=0
integer array Fn
integer array kn
integer jn=0
integer xn=0
integer array vn
integer array mn
integer Qn=0
integer Wn=0
integer array En
integer array Zn
integer Un=0
integer In=0
integer array Pn
integer array An
integer Dn=0
integer Hn=0
integer array Jn
integer array Kn
integer Ln=0
integer Xn=0
integer array Cn
integer array Vn
integer Bn=0
integer Nn=0
integer array Mn
integer array wd
integer ud=0
integer rd=0
integer array sd
integer array td
integer id=0
integer Sd=0
integer array cd
string array od
string array Od
string array ld
string array bd
string array yd
string array pd
string array ed
string array qd
string array ad
string array nd
string array dd
string array fd
string array Rd
string array Td
string array Yd
string array Gd
string array gd
string array hd
string array Fd
string array kd
string array jd
string array xd
string array vd
string array md
string array Qd
unit array Wd
unit array Ed
unit array Zd
unit array Ud
unit array Id
unit array Pd
integer Ad=0
string array Dd
real Hd=0.
real Jd=0.
real Kd=0.
real Ld=0.
real Xd=0.
real Cd=0.
real Vd=0.
real Bd=0.
real Nd=0.
real Md=0.
real wf=0.
real uf=0.
real rf=0.
real sf=0.
real tf=0.
real Sf=0.
real cf=0.
real of=0.
real Of=0.
real lf=0.
real bf=0.
real yf=0.
real pf=0.
real ef=0.
real qf=0.
real af=0.
real nf=0.
real df=0.
real ff=0.
integer Rf=0
integer Tf=0
integer Yf=0
real Gf=0.
real gf=0.
real hf=0.
real Ff=0.
real kf=0.
real jf=0.
real xf=0.
real vf=0.
real mf=0.
real Qf=0.
real Wf=0.
real Ef=0.
real Zf=0.
real Uf=0.
real If=0.
real Pf=0.
real Af=0.
real Df=0.
real Hf=0.
real Jf=0.
real Kf=0.
real Lf=0.
real Xf=0.
real Cf=0.
real Vf=0.
real Bf=0.
real Nf=0.
real Mf=0.
integer wR=0
integer uR=0
integer rR=0
integer sR=0
integer tR=0
integer iR=0
real SR=0.
real cR=0.
real oR=0.
real OR=0.
real lR=0.
real bR=0.
real yR=0.
real pR=0.
real eR=0.
real qR=0.
real aR=0.
real nR=0.
real dR=0.
real fR=0.
real RR=0.
real TR=0.
real YR=0.
real GR=0.
real gR=0.
real hR=0.
real FR=0.
real kR=0.
integer jR=0
integer xR=0
integer vR=0
integer mR=0
real QR=0.
real WR=0.
real ER=0.
real ZR=0.
real UR=0.
real IR=0.
integer PR=0
integer AR=0
integer DR=0
integer HR=0
real JR=0.
real KR=0.
real LR=0.
real XR=0.
real CR=0.
real VR=0.
real BR=0.
real NR=0.
real MR=0.
real wT=0.
real uT=0.
real rT=0.
real sT=0.
real tT=0.
real iT=0.
real ST=0.
real cT=0.
real oT=0.
real OT=0.
real lT=0.
integer bT=0
integer yT=0
integer pT=0
integer eT=0
code qT=null
code aT=null
code nT=null
code dT=null
code fT=null
code RT=null
code TT=null
code YT=null
code GT=null
code gT=null
code hT=null
code FT=null
code kT=null
code jT=null
code xT=null
code vT=null
code mT=null
code QT=null
code WT=null
code ET=null
code ZT=null
code UT=null
code IT=null
code PT=null
code AT=null
code DT=null
code HT=null
code JT=null
code KT=null
code LT=null
code XT=null
code CT=null
code VT=null
code BT=null
code NT=null
code MT=null
code wY=null
code uY=null
code rY=null
code sY=null
code tY=null
code iY=null
code SY=null
code cY=null
code oY=null
code OY=null
code lY=null
code bY=null
code yY=null
code pY=null
code eY=null
code qY=null
code aY=null
code nY=null
code dY=null
code fY=null
code RY=null
code TY=null
code YY=null
code GY=null
code gY=null
code hY=null
code FY=null
code kY=null
code jY=null
code xY=null
code vY=null
code mY=null
code QY=null
code WY=null
code EY=null
code ZY=null
code UY=null
code IY=null
code PY=null
code AY=null
code DY=null
code HY=null
code JY=null
code KY=null
code LY=null
code XY=null
code CY=null
code VY=null
code BY=null
code NY=null
code MY=null
code wG=null
code uG=null
code rG=null
code sG=null
code tG=null
code iG=null
code SG=null
code cG=null
code oG=null
code OG=null
code lG=null
code bG=null
code yG=null
code pG=null
code eG=null
code qG=null
code aG=null
code nG=null
code dG=null
code fG=null
code RG=null
code TG=null
code YG=null
code GG=null
code gG=null
code hG=null
code FG=null
code kG=null
code jG=null
code xG=null
code vG=null
code mG=null
code QG=null
code WG=null
code EG=null
code ZG=null
code UG=null
code IG=null
code PG=null
code AG=null
code DG=null
code HG=null
code JG=null
code KG=null
code LG=null
code XG=null
code CG=null
code VG=null
code BG=null
code NG=null
code MG=null
code wg=null
code ug=null
code rg=null
code sg=null
code tg=null
code ig=null
code Sg=null
code cg=null
code og=null
code Og=null
code lg=null
code bg=null
code yg=null
code pg=null
code eg=null
code qg=null
code ag=null
code ng=null
code dg=null
code fg=null
code Rg=null
code Tg=null
code Yg=null
code Gg=null
code gg=null
code hg=null
code Fg=null
code kg=null
code jg=null
code xg=null
integer vg=0
group mg=null
unit Qg=null
unit Wg=null
unit Eg=null
unit Zg=null
unit Ug=null
player Ig=null
unit Pg=null
timer Ag=null
trigger Dg=null
unit Hg=null
unit Jg=null
unit Kg=null
unit Lg=null
unit Xg=null
trigger Cg=null
unit Vg=null
endglobals
function foo takes unit Xsu returns boolean
return true
endfunction
function Csu takes handle Xsu returns integer
return GetHandleId(Xsu)
endfunction
function B0u takes unit V0u returns integer
return Csu(V0u)
endfunction
function oaw takes hashtable taw,integer iaw,integer Saw,integer caw returns nothing
call SaveInteger(taw,iaw,Saw,caw)
endfunction
function p3w takes integer l3w,integer b3w,integer y3w returns nothing
call oaw(Bb,l3w,b3w,y3w)
endfunction
function nEw takes integer qEw returns string
local integer aEw=qEw
if aEw==0 then
return "|cffADADADtrace|r"
elseif aEw==1 then
return "|cff2685DCdebug|r"
elseif aEw==2 then
return "|cffFFCC00info|r"
elseif aEw==3 then
return "|cffF47E3Ewarning|r"
elseif aEw==4 then
return "|cffFB2700error|r"
endif
return "?"
endfunction
function YEw takes player dEw,integer fEw,string REw returns nothing
local string TEw
if TO<=fEw then
set TEw=nEw(fEw)+" - "+REw
call DisplayTimedTextToPlayer(dEw,0.,0.,RO,TEw)
endif
endfunction
function LEw takes string KEw returns nothing
call YEw(lO,4,KEw)
endfunction
function Nqw takes hashtable Xqw,integer Cqw,integer Vqw,boolean Bqw returns nothing
call SaveBoolean(Xqw,Cqw,Vqw,Bqw)
endfunction
function Qqw takes hashtable xqw,integer vqw,integer mqw returns boolean
return LoadBoolean(xqw,vqw,mqw)
endfunction
function Rqw takes hashtable nqw,integer dqw,integer fqw returns boolean
return HaveSavedBoolean(nqw,dqw,fqw)
endfunction
function Ssw takes string isw returns nothing
endfunction
function Uqw takes hashtable Wqw,integer Eqw,integer Zqw returns integer
return LoadInteger(Wqw,Eqw,Zqw)
endfunction
function ZMw takes string EMw returns integer
return StringHash(EMw)
endfunction
function bUw takes real lUw returns integer
return R2I(lUw)
endfunction
function gqw takes hashtable Tqw,integer Yqw,integer Gqw returns boolean
return HaveSavedInteger(Tqw,Yqw,Gqw)
endfunction
function tsw takes string Lrw,string Xrw returns nothing
local integer Crw
local string Vrw
local integer Brw
local integer Nrw
local string Mrw
local integer wsw
local integer usw
local string rsw
local string ssw
set Dd[Ad]=Xrw
set Ad=Ad+1
if Ro then
call Ssw("ERROR: "+Lrw)
else
if not si then
set Crw=ZMw(Lrw)
if gqw(ui,wi,Crw) then
if Uqw(ui,wi,Crw)+Mt<Ni then
set rsw=Lrw
set Vrw=""
set Brw=Ad
set Nrw=0
loop
set Brw=Brw-1
set Nrw=Nrw+1
exitwhen Nrw>20
exitwhen Brw<0
set Vrw=Vrw+"\n   "+Dd[Brw]
endloop
call LEw(rsw+Vrw)
call oaw(ui,wi,Crw,bUw(Ni))
call Nqw(ui,wi,Crw,false)
elseif Rqw(ui,wi,Crw) then
if not Qqw(ui,wi,Crw) then
call LEw("|cffFF3A29Excessive repeating errors are being omitted")
call Nqw(ui,wi,Crw,true)
endif
else
call LEw("|cffFF3A29Excessive repeating errors are being omitted")
call Nqw(ui,wi,Crw,true)
endif
else
call oaw(ui,wi,Crw,bUw(Ni))
set ssw="|cffFF3A29Error:|r "+Lrw
set Mrw=""
set wsw=Ad
set usw=0
loop
set wsw=wsw-1
set usw=usw+1
exitwhen usw>20
exitwhen wsw<0
set Mrw=Mrw+"\n   "+Dd[wsw]
endloop
call LEw(ssw+Mrw)
endif
endif
set ri=Lrw
call I2S(1/0)
endif
set Ad=Ad-1
endfunction
function JXu takes integer PXu,integer AXu,integer DXu,string HXu returns nothing
set Dd[Ad]=HXu
set Ad=Ad+1
if Za[PXu]==0 then
if PXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_saveInt","when calling error in ")
else
call tsw("Called Table.Table_Table_saveInt on invalid object.","when calling error in ")
endif
endif
call p3w(PXu,AXu,DXu)
set Ad=Ad-1
endfunction
function Aew takes integer Zew,integer Uew,integer Iew,string Pew returns nothing
set Dd[Ad]=Pew
set Ad=Ad+1
call JXu(Zew,Uew,Iew,"when calling saveInt in HashMap, line 16")
set Ad=Ad-1
endfunction
function sew takes integer uew,integer rew returns integer
return Uqw(yS,uew,rew)
endfunction
function JWu takes integer PWu,integer AWu,string DWu returns integer
local integer HWu
set Dd[Ad]=DWu
set Ad=Ad+1
if ma[PWu]==0 then
if PWu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_count","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_count on invalid object.","when calling error in ")
endif
endif
set HWu=sew(PWu,AWu)
set Ad=Ad-1
return HWu
endfunction
function xew takes integer hew,integer Few,string kew returns boolean
local boolean jew
set Dd[Ad]=kew
set Ad=Ad+1
set jew=JWu(hew,Few,"when calling count in HashList, line 83")>0
set Ad=Ad-1
return jew
endfunction
function yEu takes integer oEu,integer OEu,string lEu returns boolean
local boolean bEu
set Dd[Ad]=lEu
set Ad=Ad+1
if ma[oEu]==0 then
if oEu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_has","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_has on invalid object.","when calling error in ")
endif
endif
set bEu=xew(oEu,OEu,"when calling has in HashList, line 82")
set Ad=Ad-1
return bEu
endfunction
function aqw takes integer yqw,integer pqw,string eqw returns boolean
local boolean qqw
set Dd[Ad]=eqw
set Ad=Ad+1
set qqw=yEu(eS[yqw],pqw,"when calling has in HashMap, line 44")
set Ad=Ad-1
return qqw
endfunction
function AEu takes integer ZEu,integer UEu,string IEu returns boolean
local boolean PEu
set Dd[Ad]=IEu
set Ad=Ad+1
if Za[ZEu]==0 then
if ZEu==0 then
call tsw("Nullpointer exception when calling IterableMap.HashMap_IterableMap_hasKey","when calling error in ")
else
call tsw("Called IterableMap.HashMap_IterableMap_hasKey on invalid object.","when calling error in ")
endif
endif
set PEu=aqw(ZEu,UEu,"when calling hasKey in HashMap, line 43")
set Ad=Ad-1
return PEu
endfunction
function cew takes integer tew,integer iew,string Sew returns nothing
set Dd[Ad]=Sew
set Ad=Ad+1
call oaw(yS,tew,iew,JWu(tew,iew,"when calling count in HashList, line 14")+1)
set Ad=Ad-1
endfunction
function CWu takes integer KWu,integer LWu,string XWu returns nothing
set Dd[Ad]=XWu
set Ad=Ad+1
if ma[KWu]==0 then
if KWu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_incrOccurences","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_incrOccurences on invalid object.","when calling error in ")
endif
endif
call cew(KWu,LWu,"when calling incrOccurences in HashList, line 13")
set Ad=Ad-1
endfunction
function X3u takes integer J3u,integer K3u,string L3u returns nothing
set Dd[Ad]=L3u
set Ad=Ad+1
call oaw(bS,J3u,pS[J3u],K3u)
call CWu(J3u,K3u,"when calling incrOccurences in HashList, line 23")
set pS[J3u]=pS[J3u]+1
set Ad=Ad-1
endfunction
function N3u takes integer C3u,integer V3u,string B3u returns nothing
set Dd[Ad]=B3u
set Ad=Ad+1
if ma[C3u]==0 then
if C3u==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_add","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_add on invalid object.","when calling error in ")
endif
endif
call X3u(C3u,V3u,"when calling add in HashList, line 20")
set Ad=Ad-1
endfunction
function cqw takes integer sqw,integer tqw,integer iqw,string Sqw returns nothing
set Dd[Ad]=Sqw
set Ad=Ad+1
call Aew(sqw,tqw,iqw,"when calling put in HashMap, line 38")
if not AEu(sqw,tqw,"when calling hasKey in HashMap, line 39") then
call N3u(eS[sqw],tqw,"when calling add in HashMap, line 40")
endif
set Ad=Ad-1
endfunction
function YEu takes integer dEu,integer fEu,integer REu,string TEu returns nothing
set Dd[Ad]=TEu
set Ad=Ad+1
if Za[dEu]==0 then
if dEu==0 then
call tsw("Nullpointer exception when calling HashMap.HashMap_HashMap_put","when calling error in ")
else
call tsw("Called HashMap.HashMap_HashMap_put on invalid object.","when calling error in ")
endif
endif
if Za[dEu]<=887 then
call Aew(dEu,fEu,REu,"when calling put in HashMap, line 15")
else
call cqw(dEu,fEu,REu,"when calling put in HashMap, line 15")
endif
set Ad=Ad-1
endfunction
function O3w takes integer c3w,integer o3w returns integer
return Uqw(Bb,c3w,o3w)
endfunction
function IXu takes integer WXu,integer EXu,string ZXu returns integer
local integer UXu
set Dd[Ad]=ZXu
set Ad=Ad+1
if Za[WXu]==0 then
if WXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_loadInt","when calling error in ")
else
call tsw("Called Table.Table_Table_loadInt on invalid object.","when calling error in ")
endif
endif
set UXu=O3w(WXu,EXu)
set Ad=Ad-1
return UXu
endfunction
function Lew takes integer Dew,integer Hew,string Jew returns integer
local integer Kew
set Dd[Ad]=Jew
set Ad=Ad+1
set Kew=IXu(Dew,Hew,"when calling loadInt in HashMap, line 20")
set Ad=Ad-1
return Kew
endfunction
function kEu takes integer GEu,integer gEu,string hEu returns integer
local integer FEu
set Dd[Ad]=hEu
set Ad=Ad+1
if Za[GEu]==0 then
if GEu==0 then
call tsw("Nullpointer exception when calling HashMap.HashMap_HashMap_get","when calling error in ")
else
call tsw("Called HashMap.HashMap_HashMap_get on invalid object.","when calling error in ")
endif
endif
set FEu=Lew(GEu,gEu,"when calling get in HashMap, line 19")
set Ad=Ad-1
return FEu
endfunction
function w3w takes integer NMw,integer MMw returns boolean
return gqw(Bb,NMw,MMw)
endfunction
function GXu takes integer fXu,integer RXu,string TXu returns boolean
local boolean YXu
set Dd[Ad]=TXu
set Ad=Ad+1
if Za[fXu]==0 then
if fXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_hasInt","when calling error in ")
else
call tsw("Called Table.Table_Table_hasInt on invalid object.","when calling error in ")
endif
endif
set YXu=w3w(fXu,RXu)
set Ad=Ad-1
return YXu
endfunction
function Eew takes integer vew,integer mew,string Qew returns boolean
local boolean Wew
set Dd[Ad]=Qew
set Ad=Ad+1
set Wew=GXu(vew,mew,"when calling hasInt in HashMap, line 12")
set Ad=Ad-1
return Wew
endfunction
function nEu takes integer pEu,integer eEu,string qEu returns boolean
local boolean aEu
set Dd[Ad]=qEu
set Ad=Ad+1
if Za[pEu]==0 then
if pEu==0 then
call tsw("Nullpointer exception when calling HashMap.HashMap_HashMap_has","when calling error in ")
else
call tsw("Called HashMap.HashMap_HashMap_has on invalid object.","when calling error in ")
endif
endif
set aEu=Eew(pEu,eEu,"when calling has in HashMap, line 11")
set Ad=Ad-1
return aEu
endfunction
function gK takes unit RK,integer TK,integer YK,string GK returns integer
set Dd[Ad]=GK
set Ad=Ad+1
set ju[YK]=TK
if RK!=null then
set xu[YK]=RK
if nEu(Ru,B0u(RK),"when calling has in ClosureEvents, line 154") then
set ku[kEu(Ru,B0u(RK),"when calling get in ClosureEvents, line 155")]=YK
set Fu[YK]=kEu(Ru,B0u(RK),"when calling get in ClosureEvents, line 156")
endif
call YEu(Ru,B0u(RK),YK,"when calling put in ClosureEvents, line 157")
else
if nEu(fu,TK,"when calling has in ClosureEvents, line 159") then
set ku[kEu(fu,TK,"when calling get in ClosureEvents, line 160")]=YK
set Fu[YK]=kEu(fu,TK,"when calling get in ClosureEvents, line 161")
endif
call YEu(fu,TK,YK,"when calling put in ClosureEvents, line 163")
endif
set Ad=Ad-1
return YK
endfunction
function AK takes integer ZK,integer UK,string IK returns integer
local integer PK
set Dd[Ad]=IK
set Ad=Ad+1
set PK=gK(null,ZK,UK,"when calling addSpellInternal in ClosureEvents, line 145")
set Ad=Ad-1
return PK
endfunction
function DJu takes string PJu returns integer
local integer AJu
set Dd[Ad]=PJu
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set AJu=ye
set pe[AJu]=800
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set AJu=0
endif
else
set be=be-1
set AJu=le[be]
set pe[AJu]=800
endif
set Ad=Ad-1
return AJu
endfunction
function qL takes integer eL returns nothing
set Fu[eL]=0
set ku[eL]=0
set xu[eL]=null
endfunction
function HL takes integer DL returns nothing
call qL(DL)
endfunction
function EHw takes string vHw returns boolean
local integer mHw
local integer QHw
local integer WHw
set Dd[Ad]=vHw
set Ad=Ad+1
set QHw=1095577698
set WHw=1112354870
set nl=QHw
set dl=WHw
set mHw=DJu("when calling alloc_Closure in ShieldKit, line 33")
call HL(mHw)
call AK(1093677124,mHw,"when calling onTargetCast in ShieldKit, line 33")
set Ad=Ad-1
return true
endfunction
function A1u takes nothing returns boolean
set Ad=0
return EHw("ShieldKit, line 1")
endfunction
function AH takes nothing returns boolean
return true
endfunction
function AW takes nothing returns boolean
local integer IW=1095577652
local integer PW=1112354867
set vw=IW
set mw=PW
return true
endfunction
function FYu takes integer gYu,string hYu returns nothing
set Dd[Ad]=hYu
set Ad=Ad+1
if Oq[gYu]==0 then
call tsw("Double free: object of type CallbackCounted","when calling error in ")
else
set Sq[cq]=gYu
set cq=cq+1
set Oq[gYu]=0
endif
set Ad=Ad-1
endfunction
function Y2w takes timer T2w returns nothing
call PauseTimer(T2w)
endfunction
function R2w takes timer f2w returns integer
return GetHandleId(f2w)
endfunction
function c2w takes timer t2w,string i2w returns integer
local integer S2w
set Dd[Ad]=i2w
set Ad=Ad+1
set S2w=IXu(ay,R2w(t2w),"when calling loadInt in TimerUtils, line 21")
set Ad=Ad-1
return S2w
endfunction
function s2w takes timer w2w,integer u2w,string r2w returns nothing
set Dd[Ad]=r2w
set Ad=Ad+1
call JXu(ay,R2w(w2w),u2w,"when calling saveInt in TimerUtils, line 17")
set Ad=Ad-1
endfunction
function e2w takes timer y2w,string p2w returns nothing
set Dd[Ad]=p2w
set Ad=Ad+1
if y2w==null then
call tsw("Trying to release a null timer","when calling error in TimerUtils, line 37")
set Ad=Ad-1
return
endif
if c2w(y2w,"when calling getData in TimerUtils, line 39")==ny then
call tsw("ReleaseTimer: Double free!","when calling error in TimerUtils, line 40")
set Ad=Ad-1
return
endif
call s2w(y2w,ny,"when calling setData in TimerUtils, line 42")
call Y2w(y2w)
set ey[qy]=y2w
set qy=qy+1
set Ad=Ad-1
endfunction
function eC takes integer yC,string pC returns nothing
set Dd[Ad]=pC
set Ad=Ad+1
call e2w(Uu[yC],"when calling release in ClosureTimers, line 131")
set Ad=Ad-1
endfunction
function OC takes integer cC,string oC returns nothing
set Dd[Ad]=oC
set Ad=Ad+1
call eC(cC,"when calling CallbackCounted_onDestroy in ClosureTimers, line 130")
call FYu(cC,"when calling CallbackCounted in ClosureTimers, line 130")
set Ad=Ad-1
endfunction
function bYu takes integer OYu,string lYu returns nothing
set Dd[Ad]=lYu
set Ad=Ad+1
if Oq[OYu]==0 then
if OYu==0 then
call tsw("Nullpointer exception when calling CallbackCounted.destroyCallbackCounted","when calling error in ")
else
call tsw("Called CallbackCounted.destroyCallbackCounted on invalid object.","when calling error in ")
endif
endif
call OC(OYu,"when calling destroyCallbackCounted in ClosureTimers, line 100")
set Ad=Ad-1
endfunction
function ZLw takes sound WLw,real ELw returns nothing
call SetSoundPitch(WLw,ELw)
endfunction
function Zyw takes integer Wyw,integer Eyw returns nothing
call ZLw(rb[Xi[Wyw]],Ji)
endfunction
function kyw takes integer hyw,integer Fyw returns nothing
set Ji=Ji*0.99802
call ZLw(rb[Li[hyw]],Ji)
endfunction
function qYu takes integer yYu,integer pYu,string eYu returns nothing
set Dd[Ad]=eYu
set Ad=Ad+1
if Oq[yYu]==0 then
if yYu==0 then
call tsw("Nullpointer exception when calling CallbackCounted.ClosureTimers_CallbackCounted_call","when calling error in ")
else
call tsw("Called CallbackCounted.ClosureTimers_CallbackCounted_call on invalid object.","when calling error in ")
endif
endif
if Oq[yYu]<=652 then
call kyw(yYu,pYu)
else
call Zyw(yYu,pYu)
endif
set Ad=Ad-1
endfunction
function SC takes integer tC,string iC returns nothing
set Dd[Ad]=iC
set Ad=Ad+1
call qYu(tC,tC,"when calling call in ClosureTimers, line 125")
set Zu[tC]=Zu[tC]-1
if Zu[tC]<=0 then
call bYu(tC,"when calling CallbackCounted in ClosureTimers, line 128")
endif
set Ad=Ad-1
endfunction
function GYu takes integer TYu,string YYu returns nothing
set Dd[Ad]=YYu
set Ad=Ad+1
if Oq[TYu]==0 then
if TYu==0 then
call tsw("Nullpointer exception when calling CallbackCounted.ClosureTimers_CallbackCounted_callAndCount","when calling error in ")
else
call tsw("Called CallbackCounted.ClosureTimers_CallbackCounted_callAndCount on invalid object.","when calling error in ")
endif
endif
call SC(TYu,"when calling callAndCount in ClosureTimers, line 124")
set Ad=Ad-1
endfunction
function sC takes string rC returns nothing
set Dd[Ad]=rC
set Ad=Ad+1
call GYu(c2w(GetExpiredTimer(),"when calling getData in ClosureTimers, line 122"),"when calling callAndCount in ClosureTimers, line 122")
set Ad=Ad-1
endfunction
function B1u takes nothing returns nothing
set Ad=0
call sC("ClosureTimers, line 110")
endfunction
function BMw takes nothing returns boolean
set Bb=InitHashtable()
return true
endfunction
function Bjw takes nothing returns boolean
set Eo=".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
return true
endfunction
function Bm takes nothing returns boolean
local integer Cm=1095577650
local integer Vm=1112354865
set Fw=Cm
set kw=Vm
set jw=512*512
return true
endfunction
function d2w takes timer n2w returns real
return TimerGetElapsed(n2w)
endfunction
function Hyw takes nothing returns real
return d2w(Bi)
endfunction
function DEw takes string AEw returns nothing
call YEw(lO,1,AEw)
endfunction
function Ytu takes unit Ttu returns integer
return GetUnitUserData(Ttu)
endfunction
function e_u takes unit p_u returns integer
return Ytu(p_u)
endfunction
function Sww takes unit tww,integer iww returns nothing
set gt[e_u(tww)]=iww
endfunction
function WCu takes integer mCu,string QCu returns nothing
set Dd[Ad]=QCu
set Ad=Ad+1
if Oe[mCu]==0 then
call tsw("Double free: object of type BlockadeShip","when calling error in ")
else
set Se[ce]=mCu
set ce=ce+1
set Oe[mCu]=0
endif
set Ad=Ad-1
endfunction
function Wsu takes unit Qsu returns nothing
call KillUnit(Qsu)
endfunction
function juw takes integer kuw returns nothing
set Lt=Lt-1
if kuw!=Ht then
set Ct[Xt[kuw]]=Ct[kuw]
else
set Ht=Ct[kuw]
endif
if kuw!=Jt then
set Xt[Ct[kuw]]=Xt[kuw]
else
set Jt=Xt[kuw]
endif
set Xt[kuw]=0
set Ct[kuw]=0
endfunction
function qxu takes integer pxu,string exu returns nothing
set Dd[Ad]=exu
set Ad=Ad+1
if Oe[pxu]==0 then
if pxu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_removeFromInactive","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_removeFromInactive on invalid object.","when calling error in ")
endif
endif
call juw(pxu)
set Ad=Ad-1
endfunction
function guw takes integer Guw returns nothing
set Kt=Kt-1
if Guw!=At then
set Ct[Xt[Guw]]=Ct[Guw]
else
set At=Ct[Guw]
endif
if Guw!=Dt then
set Xt[Ct[Guw]]=Xt[Guw]
else
set Dt=Xt[Guw]
endif
set Xt[Guw]=0
set Ct[Guw]=0
endfunction
function yxu takes integer lxu,string bxu returns nothing
set Dd[Ad]=bxu
set Ad=Ad+1
if Oe[lxu]==0 then
if lxu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_removeFromActive","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_removeFromActive on invalid object.","when calling error in ")
endif
endif
call guw(lxu)
set Ad=Ad-1
endfunction
function Wuw takes integer muw,string Quw returns nothing
set Dd[Ad]=Quw
set Ad=Ad+1
if Vt[muw]then
set Vt[muw]=false
call yxu(muw,"when calling removeFromActive in DupletListModule, line 33")
else
call qxu(muw,"when calling removeFromInactive in DupletListModule, line 35")
endif
set Ad=Ad-1
endfunction
function Oxu takes integer cxu,string oxu returns nothing
set Dd[Ad]=oxu
set Ad=Ad+1
if Oe[cxu]==0 then
if cxu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_remove","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_remove on invalid object.","when calling error in ")
endif
endif
call Wuw(cxu,"when calling remove in DupletListModule, line 30")
set Ad=Ad-1
endfunction
function auw takes integer euw,string quw returns nothing
set Dd[Ad]=quw
set Ad=Ad+1
call Oxu(euw,"when calling remove in DupletListModule, line 89")
set Ad=Ad-1
endfunction
function biu takes unit liu returns nothing
call RemoveUnit(liu)
endfunction
function Mhw takes integer Nhw returns integer
return co[Nhw]
endfunction
function XPu takes integer JPu,string KPu returns integer
local integer LPu
set Dd[Ad]=KPu
set Ad=Ad+1
if yn[JPu]==0 then
if JPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_getDummy","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_getDummy on invalid object.","when calling error in ")
endif
endif
set LPu=Mhw(JPu)
set Ad=Ad-1
return LPu
endfunction
function jGw takes integer FGw,string kGw returns nothing
set Dd[Ad]=kGw
set Ad=Ad+1
set wo[FGw]=XPu(ro[FGw],"when calling getDummy in LinkedList, line 397")
set uo[FGw]=wo[FGw]
set Ad=Ad-1
endfunction
function XUu takes integer KUu,string LUu returns nothing
set Dd[Ad]=LUu
set Ad=Ad+1
if on[KUu]==0 then
if KUu==0 then
call tsw("Nullpointer exception when calling LLIterator.LinkedList_LLIterator_reset","when calling error in ")
else
call tsw("Called LLIterator.LinkedList_LLIterator_reset on invalid object.","when calling error in ")
endif
endif
call jGw(KUu,"when calling reset in LinkedList, line 396")
set Ad=Ad-1
endfunction
function pIu takes string bIu returns integer
local integer yIu
set Dd[Ad]=bIu
set Ad=Ad+1
if Sn==0 then
if cn<32768 then
set cn=cn+1
set yIu=cn
set on[yIu]=775
else
call tsw("Out of memory: Could not create LLIterator.","when calling error in ")
set yIu=0
endif
else
set Sn=Sn-1
set yIu=tn[Sn]
set on[yIu]=775
endif
set Ad=Ad-1
return yIu
endfunction
function ugw takes integer BGw,integer NGw,boolean MGw,string wgw returns nothing
set Dd[Ad]=wgw
set Ad=Ad+1
set so[BGw]=true
set ro[BGw]=NGw
call XUu(BGw,"when calling reset in LinkedList, line 393")
set so[BGw]=MGw
set Ad=Ad-1
endfunction
function hGw takes integer TGw,boolean YGw,string GGw returns integer
local integer gGw
set Dd[Ad]=GGw
set Ad=Ad+1
set gGw=pIu("when calling LLIterator in LinkedList, line 391")
call ugw(gGw,TGw,YGw,"when calling construct_LLIterator2 in LinkedList, line 391")
set Ad=Ad-1
return gGw
endfunction
function uhw takes integer Mgw,string whw returns integer
set Dd[Ad]=whw
set Ad=Ad+1
if Oo[Mgw]==0 then
set Oo[Mgw]=hGw(Mgw,false,"when calling new_LLIterator in LinkedList, line 143")
endif
call XUu(Oo[Mgw],"when calling reset in LinkedList, line 144")
set Ad=Ad-1
return Oo[Mgw]
endfunction
function cPu takes integer tPu,string iPu returns integer
local integer SPu
set Dd[Ad]=iPu
set Ad=Ad+1
if yn[tPu]==0 then
if tPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_staticItr","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_staticItr on invalid object.","when calling error in ")
endif
endif
set SPu=uhw(tPu,"when calling staticItr in LinkedList, line 141")
set Ad=Ad-1
return SPu
endfunction
function nGw takes integer aGw returns boolean
return Mc[uo[aGw]]!=wo[aGw]
endfunction
function p5 takes effect y5 returns nothing
call DestroyEffect(y5)
endfunction
function qGw takes integer eGw returns integer
set uo[eGw]=Mc[uo[eGw]]
return Bc[uo[eGw]]
endfunction
function sww takes unit rww returns integer
return gt[e_u(rww)]
endfunction
function KP takes integer JP returns nothing
set ou=ou-1
if JP!=Su then
set lu[Ou[JP]]=lu[JP]
else
set Su=lu[JP]
endif
if JP!=cu then
set Ou[lu[JP]]=Ou[JP]
else
set cu=Ou[JP]
endif
endfunction
function ARu takes integer IRu,string PRu returns nothing
set Dd[Ad]=PRu
set Ad=Ad+1
if Ie[IRu]==0 then
if IRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_LinkedListModule_remove","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_LinkedListModule_remove on invalid object.","when calling error in ")
endif
endif
call KP(IRu)
set Ad=Ad-1
endfunction
function oP takes integer cP returns nothing
endfunction
function qmu takes integer pmu,string emu returns nothing
set Dd[Ad]=emu
set Ad=Ad+1
if Ya[pmu]==0 then
call tsw("Double free: object of type Iterator","when calling error in ")
else
set fa[Ra]=pmu
set Ra=Ra+1
set Ya[pmu]=0
endif
set Ad=Ad-1
endfunction
function wcw takes integer MSw returns nothing
endfunction
function CSw takes integer LSw,string XSw returns nothing
set Dd[Ad]=XSw
set Ad=Ad+1
call wcw(LSw)
call qmu(LSw,"when calling Iterator in LinkedListModule, line 71")
set Ad=Ad-1
endfunction
function Omu takes integer cmu,string omu returns nothing
set Dd[Ad]=omu
set Ad=Ad+1
if Ya[cmu]==0 then
if cmu==0 then
call tsw("Nullpointer exception when calling Iterator.destroyIterator","when calling error in ")
else
call tsw("Called Iterator.destroyIterator on invalid object.","when calling error in ")
endif
endif
call CSw(cmu,"when calling destroyIterator in LinkedListModule, line 71")
set Ad=Ad-1
endfunction
function ASw takes integer ISw,string PSw returns nothing
set Dd[Ad]=PSw
set Ad=Ad+1
if Gi[ISw]then
call Omu(ISw,"when calling Iterator in LinkedListModule, line 91")
endif
set Ad=Ad-1
endfunction
function ESw takes integer QSw returns integer
local integer WSw=Yi[QSw]
set Yi[QSw]=Ti[Yi[QSw]]
return WSw
endfunction
function AUu takes integer IUu,string PUu returns nothing
set Dd[Ad]=PUu
set Ad=Ad+1
if sn[IUu]==0 then
call tsw("Double free: object of type LLEntry","when calling error in ")
else
set wn[un]=IUu
set un=un+1
set sn[IUu]=0
endif
set Ad=Ad-1
endfunction
function pGw takes integer yGw returns nothing
endfunction
function SGw takes integer tGw,string iGw returns nothing
set Dd[Ad]=iGw
set Ad=Ad+1
call pGw(tGw)
call AUu(tGw,"when calling LLEntry in LinkedList, line 371")
set Ad=Ad-1
endfunction
function WUu takes integer mUu,string QUu returns nothing
set Dd[Ad]=QUu
set Ad=Ad+1
if sn[mUu]==0 then
if mUu==0 then
call tsw("Nullpointer exception when calling LLEntry.destroyLLEntry","when calling error in ")
else
call tsw("Called LLEntry.destroyLLEntry on invalid object.","when calling error in ")
endif
endif
call SGw(mUu,"when calling destroyLLEntry in LinkedList, line 371")
set Ad=Ad-1
endfunction
function Egw takes integer mgw,integer Qgw,string Wgw returns nothing
set Dd[Ad]=Wgw
set Ad=Ad+1
set Mc[Nc[Qgw]]=Mc[Qgw]
set Nc[Mc[Qgw]]=Nc[Qgw]
call WUu(Qgw,"when calling LLEntry in LinkedList, line 351")
set oo[mgw]=oo[mgw]-1
set Ad=Ad-1
endfunction
function sAu takes integer wAu,integer uAu,string rAu returns nothing
set Dd[Ad]=rAu
set Ad=Ad+1
if yn[wAu]==0 then
if wAu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_removeEntry","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_removeEntry on invalid object.","when calling error in ")
endif
endif
call Egw(wAu,uAu,"when calling removeEntry in LinkedList, line 348")
set Ad=Ad-1
endfunction
function vgw takes integer Fgw,string kgw returns integer
local integer jgw
local integer xgw
set Dd[Ad]=kgw
set Ad=Ad+1
set jgw=Mc[co[Fgw]]
set xgw=0
if jgw!=co[Fgw]then
set xgw=Bc[jgw]
call sAu(Fgw,jgw,"when calling removeEntry in LinkedList, line 78")
endif
set Ad=Ad-1
return xgw
endfunction
function JIu takes integer AIu,string DIu returns integer
local integer HIu
set Dd[Ad]=DIu
set Ad=Ad+1
if yn[AIu]==0 then
if AIu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_dequeue","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_dequeue on invalid object.","when calling error in ")
endif
endif
set HIu=vgw(AIu,"when calling dequeue in LinkedList, line 73")
set Ad=Ad-1
return HIu
endfunction
function G4w takes texttag R4w,real T4w,real Y4w returns nothing
call SetTextTagVelocity(R4w,T4w,Y4w)
endfunction
function MC takes integer BC,string NC returns nothing
set Dd[Ad]=NC
set Ad=Ad+1
call e2w(Pu[BC],"when calling release in ClosureTimers, line 80")
set Ad=Ad-1
endfunction
function rGu takes integer wGu,string uGu returns nothing
set Dd[Ad]=uGu
set Ad=Ad+1
if ne[wGu]==0 then
call tsw("Double free: object of type CallbackSingle","when calling error in ")
else
set ee[qe]=wGu
set qe=qe+1
set ne[wGu]=0
endif
set Ad=Ad-1
endfunction
function XC takes integer KC,string LC returns nothing
set Dd[Ad]=LC
set Ad=Ad+1
call MC(KC,"when calling CallbackSingle_onDestroy in ClosureTimers, line 79")
call rGu(KC,"when calling CallbackSingle in ClosureTimers, line 79")
set Ad=Ad-1
endfunction
function KYu takes integer HYu,string JYu returns nothing
set Dd[Ad]=JYu
set Ad=Ad+1
if ne[HYu]==0 then
if HYu==0 then
call tsw("Nullpointer exception when calling CallbackSingle.destroyCallbackSingle","when calling error in ")
else
call tsw("Called CallbackSingle.destroyCallbackSingle on invalid object.","when calling error in ")
endif
endif
call XC(HYu,"when calling destroyCallbackSingle in ClosureTimers, line 63")
set Ad=Ad-1
endfunction
function VC takes integer CC returns nothing
endfunction
function b2w takes string o2w returns timer
local timer O2w
local timer l2w
set Dd[Ad]=o2w
set Ad=Ad+1
if qy>0 then
set qy=qy-1
call s2w(ey[qy],0,"when calling setData in TimerUtils, line 29")
set Ad=Ad-1
set O2w=null
set l2w=null
return ey[qy]
else
set O2w=CreateTimer()
call s2w(O2w,0,"when calling setData in TimerUtils, line 32")
set l2w=O2w
set Ad=Ad-1
set Ag=l2w
set O2w=null
set l2w=null
return Ag
endif
endfunction
function j2w takes timer h2w,real F2w,code k2w returns nothing
call TimerStart(h2w,F2w,false,k2w)
endfunction
function UC takes integer vC,real mC,string QC returns nothing
local timer WC
local timer EC
local integer ZC
set Dd[Ad]=QC
set Ad=Ad+1
set ZC=vC
set WC=b2w("when calling getTimer in ClosureTimers, line 68")
call s2w(WC,vC,"when calling setData in ClosureTimers, line 69")
set EC=WC
call j2w(EC,mC,UG)
set Pu[ZC]=EC
set Ad=Ad-1
set WC=null
set EC=null
endfunction
function MYu takes integer VYu,real BYu,string NYu returns nothing
set Dd[Ad]=NYu
set Ad=Ad+1
if ne[VYu]==0 then
if VYu==0 then
call tsw("Nullpointer exception when calling CallbackSingle.ClosureTimers_CallbackSingle_start","when calling error in ")
else
call tsw("Called CallbackSingle.ClosureTimers_CallbackSingle_start on invalid object.","when calling error in ")
endif
endif
call UC(VYu,BYu,"when calling start in ClosureTimers, line 67")
set Ad=Ad-1
endfunction
function gX takes real TX,integer YX,string GX returns integer
set Dd[Ad]=GX
set Ad=Ad+1
call MYu(YX,TX,"when calling start in ClosureTimers, line 15")
set Ad=Ad-1
return YX
endfunction
function l4w takes texttag o4w,real O4w returns nothing
call SetTextTagLifespan(o4w,O4w)
endfunction
function smu takes string umu returns integer
local integer rmu
set Dd[Ad]=umu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set rmu=ae
set ne[rmu]=673
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set rmu=0
endif
else
set qe=qe-1
set rmu=ee[qe]
set ne[rmu]=673
endif
set Ad=Ad-1
return rmu
endfunction
function Miw takes integer Diw,real Hiw,real Jiw,real Kiw,string Liw returns nothing
local texttag Xiw
local texttag Ciw
local integer Viw
local real Biw
local integer Niw
set Dd[Ad]=Liw
set Ad=Ad+1
set Xiw=pi[Diw]
call G4w(Xiw,Hiw,Jiw)
set Ciw=Xiw
call l4w(Ciw,Kiw)
set qi[Diw]=Hyw()
if ai[Diw]!=0 then
call KYu(ai[Diw],"when calling CallbackSingle in FText, line 110")
endif
set Niw=Diw
set Biw=Kiw-0.025
set Viw=smu("when calling alloc_Closure in FText, line 111")
call VC(Viw)
set yi[Viw]=Diw
set ai[Niw]=gX(Biw,Viw,"when calling doAfter in FText, line 111")
set Ad=Ad-1
set Xiw=null
set Ciw=null
endfunction
function Jvu takes integer Ivu,real Pvu,real Avu,real Dvu,string Hvu returns nothing
set Dd[Ad]=Hvu
set Ad=Ad+1
if qa[Ivu]==0 then
if Ivu==0 then
call tsw("Nullpointer exception when calling FText.FText_FText_setDynamic","when calling error in ")
else
call tsw("Called FText.FText_FText_setDynamic on invalid object.","when calling error in ")
endif
endif
call Miw(Ivu,Pvu,Avu,Dvu,"when calling setDynamic in FText, line 105")
set Ad=Ad-1
endfunction
function NSw takes integer VSw,boolean BSw returns nothing
set Yi[VSw]=ni
set Gi[VSw]=BSw
endfunction
function ymu takes string lmu returns integer
local integer bmu
set Dd[Ad]=lmu
set Ad=Ad+1
if Ra==0 then
if Ta<32768 then
set Ta=Ta+1
set bmu=Ta
set Ya[bmu]=770
else
call tsw("Out of memory: Could not create Iterator.","when calling error in ")
set bmu=0
endif
else
set Ra=Ra-1
set bmu=fa[Ra]
set Ya[bmu]=770
endif
set Ad=Ad-1
return bmu
endfunction
function KSw takes boolean DSw,string HSw returns integer
local integer JSw
set Dd[Ad]=HSw
set Ad=Ad+1
set JSw=ymu("when calling Iterator in LinkedListModule, line 75")
call NSw(JSw,DSw)
set Ad=Ad-1
return JSw
endfunction
function RSw takes string dSw returns integer
local integer fSw
set Dd[Ad]=dSw
set Ad=Ad+1
set fSw=KSw(true,"when calling new_Iterator in LinkedListModule, line 53")
set Ad=Ad-1
return fSw
endfunction
function USw takes integer ZSw returns boolean
return Yi[ZSw]!=0
endfunction
function Aiw takes integer Iiw,string Piw returns nothing
set Dd[Ad]=Piw
set Ad=Ad+1
set ei[Iiw]=true
if ai[Iiw]!=0 then
call KYu(ai[Iiw],"when calling CallbackSingle in FText, line 102")
set ai[Iiw]=0
endif
set Ad=Ad-1
endfunction
function Uvu takes integer Evu,string Zvu returns nothing
set Dd[Ad]=Zvu
set Ad=Ad+1
if qa[Evu]==0 then
if Evu==0 then
call tsw("Nullpointer exception when calling FText.FText_FText_setPermanent","when calling error in ")
else
call tsw("Called FText.FText_FText_setPermanent on invalid object.","when calling error in ")
endif
endif
call Aiw(Evu,"when calling setPermanent in FText, line 99")
set Ad=Ad-1
endfunction
function F4w takes texttag g4w,boolean h4w returns nothing
call SetTextTagVisibility(g4w,h4w)
endfunction
function J1w takes texttag P1w,real A1w,real D1w,real H1w returns nothing
call SetTextTagPos(P1w,A1w,D1w,H1w)
endfunction
function a4w takes texttag e4w,real q4w returns nothing
call SetTextTagFadepoint(e4w,q4w)
endfunction
function c4w takes texttag t4w,string i4w,real S4w returns nothing
call SetTextTagText(t4w,i4w,S4w*0.0023)
endfunction
function f4w takes texttag n4w,real d4w returns nothing
call SetTextTagAge(n4w,d4w)
endfunction
function Uiw takes integer Giw,string giw,real hiw,real Fiw,real kiw,real jiw returns nothing
local texttag xiw=pi[Giw]
local texttag viw
local texttag miw
local texttag Qiw
local texttag Wiw
local texttag Eiw
local texttag Ziw
call c4w(xiw,giw,jiw)
set viw=xiw
call J1w(viw,hiw,Fiw,kiw)
set miw=viw
call f4w(miw,0.)
set Qiw=miw
call F4w(Qiw,true)
set Wiw=Qiw
call G4w(Wiw,pp,ep)
set Eiw=Wiw
call a4w(Eiw,.45)
set Ziw=Eiw
call l4w(Ziw,WO)
set xiw=null
set viw=null
set miw=null
set Qiw=null
set Wiw=null
set Eiw=null
set Ziw=null
endfunction
function Wvu takes integer Fvu,string kvu,real jvu,real xvu,real vvu,real mvu,string Qvu returns nothing
set Dd[Ad]=Qvu
set Ad=Ad+1
if qa[Fvu]==0 then
if Fvu==0 then
call tsw("Nullpointer exception when calling FText.FText_FText_setup","when calling error in ")
else
call tsw("Called FText.FText_FText_setup on invalid object.","when calling error in ")
endif
endif
call Uiw(Fvu,kvu,jvu,xvu,vvu,mvu)
set Ad=Ad-1
endfunction
function Bvu takes string Cvu returns integer
local integer Vvu
set Dd[Ad]=Cvu
set Ad=Ad+1
if pa==0 then
if ea<32768 then
set ea=ea+1
set Vvu=ea
set qa[Vvu]=737
else
call tsw("Out of memory: Could not create FText.","when calling error in ")
set Vvu=0
endif
else
set pa=pa-1
set Vvu=ya[pa]
set qa[Vvu]=737
endif
set Ad=Ad-1
return Vvu
endfunction
function gSw takes integer GSw returns nothing
set fi=fi+1
if fi==1 then
set ni=GSw
set Ri[GSw]=0
else
set Ri[GSw]=di
set Ti[di]=GSw
set Ri[ni]=GSw
endif
set Ti[GSw]=0
set di=GSw
endfunction
function p4w takes texttag b4w,boolean y4w returns nothing
call SetTextTagPermanent(b4w,y4w)
endfunction
function eSw takes integer ySw returns nothing
local texttag pSw
set pi[ySw]=CreateTextTag()
set ei[ySw]=false
set qi[ySw]=0.
set ai[ySw]=0
call gSw(ySw)
set pSw=pi[ySw]
call p4w(pSw,true)
set pSw=null
endfunction
function Yiw takes string Riw returns integer
local integer Tiw
set Dd[Ad]=Riw
set Ad=Ad+1
set Tiw=Bvu("when calling FText in FText, line 71")
call eSw(Tiw)
set Ad=Ad-1
return Tiw
endfunction
function s4w takes texttag N1w,integer M1w,integer w4w,integer u4w,integer r4w returns nothing
call SetTextTagColor(N1w,M1w,w4w,u4w,r4w)
endfunction
function Cgw takes integer Xgw returns integer
return oo[Xgw]
endfunction
function sPu takes integer wPu,string uPu returns integer
local integer rPu
set Dd[Ad]=uPu
set Ad=Ad+1
if yn[wPu]==0 then
if wPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_size","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_size on invalid object.","when calling error in ")
endif
endif
set rPu=Cgw(wPu)
set Ad=Ad-1
return rPu
endfunction
function ftw takes real Msw,real wtw,real utw,string rtw,real stw,real ttw,real itw,real Stw,integer ctw,integer otw,integer Otw,integer ltw,string btw returns integer
local boolean ytw
local integer ptw
local integer etw
local integer qtw
local integer atw
local integer ntw
local integer dtw
set Dd[Ad]=btw
set Ad=Ad+1
set ytw=ttw<=0.
set ptw=0
if sPu(bi,"when calling size in FText, line 40")>0 then
call DEw("get recycled")
set ptw=JIu(bi,"when calling dequeue in FText, line 42")
elseif fi<100 then
set ptw=Yiw("when calling new_FText in FText, line 46")
call DEw("get new")
else
set etw=RSw("when calling iterator in FText, line 50")
loop
exitwhen not USw(etw)
set qtw=ESw(etw)
if (not ei[qtw])and ptw==0 or qi[qtw]<qi[ptw]then
set ptw=qtw
endif
endloop
call ASw(etw,"when calling close in FText, line 50")
if ptw==0 then
call tsw("You have reached the maximum possible permanent texttags","when calling error in FText, line 54")
endif
call DEw("get force recycle")
endif
set atw=ptw
call Wvu(atw,rtw,Msw,wtw,utw,stw,"when calling setup in FText, line 56")
call s4w(pi[ptw],ctw,otw,Otw,ltw)
if ytw then
set ntw=ptw
call Uvu(ntw,"when calling setPermanent in FText, line 59")
else
set dtw=ptw
call Jvu(dtw,itw,Stw,ttw,"when calling setDynamic in FText, line 61")
endif
set Ad=Ad-1
return ptw
endfunction
function vuw takes integer xuw returns nothing
set Kt=Kt+1
if Kt==1 then
set At=xuw
set Xt[xuw]=0
else
set Xt[xuw]=Dt
set Ct[Dt]=xuw
set Xt[At]=xuw
endif
set Ct[xuw]=0
set Dt=xuw
endfunction
function dxu takes integer axu,string nxu returns nothing
set Dd[Ad]=nxu
set Ad=Ad+1
if Oe[axu]==0 then
if axu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_addToActive","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_addToActive on invalid object.","when calling error in ")
endif
endif
call vuw(axu)
set Ad=Ad-1
endfunction
function Auw takes integer Iuw,string Puw returns nothing
set Dd[Ad]=Puw
set Ad=Ad+1
call dxu(Iuw,"when calling addToActive in DupletListModule, line 16")
set Ad=Ad-1
endfunction
function Fww takes integer gww,boolean hww returns nothing
set Zt[gww]=hww
endfunction
function Xju takes integer Jju,boolean Kju,string Lju returns nothing
set Dd[Ad]=Lju
set Ad=Ad+1
if Oe[Jju]==0 then
if Jju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_setFlying","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_setFlying on invalid object.","when calling error in ")
endif
endif
call Fww(Jju,Kju)
set Ad=Ad-1
endfunction
function xcu takes real Fcu,real kcu,real jcu returns real
call MoveLocation(dp,Fcu,kcu)
return GetLocationZ(dp)
endfunction
function Gww takes integer Oww,real lww,real bww,real yww,real pww,real eww,real qww,player aww,real nww,string dww returns nothing
local real fww
local real Rww
local integer Tww
local integer Yww
set Dd[Ad]=dww
set Ad=Ad+1
set Tww=Oww
set ht[Tww]=lww
set Ft[Tww]=bww
set kt[Tww]=yww
set Yww=Oww
set jt[Yww]=pww
set xt[Yww]=eww
set vt[Yww]=qww
set Et[Oww]=aww
set Qt[Oww]=nww
set Rww=yww
if xi then
set fww=xcu(lww,bww,yww)
else
set fww=0.
endif
if Rww>fww then
call Xju(Oww,true,"when calling setFlying in Entity, line 101")
endif
set dr=dr+1
set Ad=Ad-1
endfunction
function Bku takes integer Pku,real Aku,real Dku,real Hku,real Jku,real Kku,real Lku,player Xku,real Cku,string Vku returns nothing
set Dd[Ad]=Vku
set Ad=Ad+1
if Oe[Pku]==0 then
if Pku==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_setupEntity","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_setupEntity on invalid object.","when calling error in ")
endif
endif
call Gww(Pku,Aku,Dku,Hku,Jku,Kku,Lku,Xku,Cku,"when calling setupEntity in Entity, line 95")
set Ad=Ad-1
endfunction
function puw takes integer Suw,player cuw,real ouw,real Ouw,real luw,real buw,string yuw returns nothing
set Dd[Ad]=yuw
set Ad=Ad+1
set Vt[Suw]=true
set mt[Suw]=Co
set Wt[Suw]=1.
set Zt[Suw]=false
set Ut[Suw]=false
set It[Suw]=true
set Pt[Suw]=0
call Auw(Suw,"when calling construct_Entity_DupletListModule in DupletListModule, line 15")
call Bku(Suw,ouw,Ouw,luw,qp,ap,np,cuw,buw,"when calling setupEntity in Entity, line 90")
set Ad=Ad-1
endfunction
function I1w takes integer R1w,real T1w,real Y1w,real G1w,real g1w,real h1w,real F1w,string k1w,real j1w,real x1w,integer v1w,integer m1w,integer Q1w,integer W1w,string E1w returns nothing
local integer Z1w
local integer U1w
set Dd[Ad]=E1w
set Ad=Ad+1
call puw(R1w,cw,T1w,Y1w,G1w,0.,"when calling construct_Entity5 in TextTagEntity, line 10")
set It[R1w]=false
set iy[R1w]=x1w
set Z1w=R1w
set jt[Z1w]=g1w
set xt[Z1w]=h1w
set vt[Z1w]=F1w
set U1w=R1w
set Sy[U1w]=v1w
set cy[U1w]=m1w
set oy[U1w]=Q1w
set Oy[U1w]=W1w
set ty[R1w]=ftw(T1w,Y1w,G1w,k1w,j1w,x1w,pp,ep,v1w,m1w,Q1w,W1w,"when calling createFText in TextTagEntity, line 16")
set Ad=Ad-1
endfunction
function nCu takes string qCu returns integer
local integer aCu
set Dd[Ad]=qCu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set aCu=oe
set Oe[aCu]=838
else
call tsw("Out of memory: Could not create TextTagEntity.","when calling error in ")
set aCu=0
endif
else
set ce=ce-1
set aCu=Se[ce]
set Oe[aCu]=838
endif
set Ad=Ad-1
return aCu
endfunction
function f1w takes real t1w,real i1w,real S1w,real c1w,real o1w,real O1w,string l1w,real b1w,real y1w,integer p1w,integer e1w,integer q1w,integer a1w,string n1w returns integer
local integer d1w
set Dd[Ad]=n1w
set Ad=Ad+1
set d1w=nCu("when calling TextTagEntity in TextTagEntity, line 10")
call I1w(d1w,t1w,i1w,S1w,c1w,o1w,O1w,l1w,b1w,y1w,p1w,e1w,q1w,a1w,"when calling construct_TextTagEntity in TextTagEntity, line 10")
set Ad=Ad-1
return d1w
endfunction
function sJw takes integer MHw,string wJw returns nothing
local integer uJw
local integer rJw
set Dd[Ad]=wJw
set Ad=Ad+1
if ru[MHw]==90. then
set uJw=MHw
call f1w(fl[uJw],Rl[uJw],Tl[uJw],0.,0.,GetRandomReal(9.,12.),"Shield applied",13.,1.55,255,204,12,255,"when calling new_TextTagEntity in ShieldKit, line 28")
else
set rJw=MHw
call f1w(fl[rJw],Rl[rJw],Tl[rJw],0.,0.,GetRandomReal(9.,12.),"Shield collapsed",13.,1.55,255,204,12,255,"when calling new_TextTagEntity in ShieldKit, line 30")
endif
set Ad=Ad-1
endfunction
function FRu takes integer gRu,string hRu returns nothing
set Dd[Ad]=hRu
set Ad=Ad+1
if Ie[gRu]==0 then
if gRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_onEnd","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_onEnd on invalid object.","when calling error in ")
endif
endif
if Ie[gRu]<=644 then
if Ie[gRu]<=643 then
call oP(gRu)
else
call sJw(gRu,"when calling onEnd in Buff, line 91")
endif
else
call oP(gRu)
endif
set Ad=Ad-1
endfunction
function KU takes integer JU returns boolean
return Bw[JU]!=0
endfunction
function eiu takes unit yiu,integer piu returns boolean
return UnitRemoveAbility(yiu,piu)
endfunction
function UGw takes integer WGw,string EGw returns integer
local integer ZGw
set Dd[Ad]=EGw
set Ad=Ad+1
if uo[WGw]!=wo[WGw]then
call sAu(ro[WGw],uo[WGw],"when calling removeEntry in LinkedList, line 404")
set ZGw=Bc[uo[WGw]]
set uo[WGw]=Nc[uo[WGw]]
set Ad=Ad-1
return ZGw
endif
set Ad=Ad-1
return 0
endfunction
function NUu takes integer CUu,string VUu returns integer
local integer BUu
set Dd[Ad]=VUu
set Ad=Ad+1
if on[CUu]==0 then
if CUu==0 then
call tsw("Nullpointer exception when calling LLIterator.LinkedList_LLIterator_remove","when calling error in ")
else
call tsw("Called LLIterator.LinkedList_LLIterator_remove on invalid object.","when calling error in ")
endif
endif
set BUu=UGw(CUu,"when calling remove in LinkedList, line 402")
set Ad=Ad-1
return BUu
endfunction
function iI takes integer tI returns integer
return Bw[tI]
endfunction
function sI takes integer BU,integer NU,string MU returns nothing
local integer wI
local integer uI
local integer rI
set Dd[Ad]=MU
set Ad=Ad+1
if KU(BU) then
call DEw("Removing Buff")
set wI=cPu(iI(BU),"when calling staticItr in Buff, line 31")
set rI=wI
loop
exitwhen not nGw(rI)
set uI=qGw(rI)
if Ie[uI]==NU then
call NUu(wI,"when calling remove in Buff, line 34")
endif
endloop
endif
set Ad=Ad-1
endfunction
function HP takes integer ZP,string UP returns nothing
local integer IP
local integer PP
local integer AP
local unit DP
set Dd[Ad]=UP
set Ad=Ad+1
call DEw("Destroy Buff")
call FRu(ZP,"when calling onEnd in Buff, line 114")
if uu[ZP]!=0 and(not Ut[uu[ZP]]) and KU(uu[ZP]) then
call sI(uu[ZP],Ie[ZP],"when calling removeBuff in Buff, line 116")
set DP=Nt[uu[ZP]]
set IP=ZP
set AP=su[IP]
set PP=AP
call eiu(DP,PP)
endif
set uu[ZP]=0
call ARu(ZP,"when calling remove in LinkedListModule, line 49")
set Ad=Ad-1
set DP=null
endfunction
function JRu takes integer DRu,string HRu returns nothing
set Dd[Ad]=HRu
set Ad=Ad+1
if Ie[DRu]==0 then
call tsw("Double free: object of type Buff","when calling error in ")
else
set Ee[Ze]=DRu
set Ze=Ze+1
set Ie[DRu]=0
endif
set Ad=Ad-1
endfunction
function jP takes integer FP,string kP returns nothing
set Dd[Ad]=kP
set Ad=Ad+1
call HP(FP,"when calling Buff_onDestroy in Buff, line 112")
call JRu(FP,"when calling Buff in Buff, line 112")
set Ad=Ad-1
endfunction
function CCu takes integer LCu,string XCu returns nothing
set Dd[Ad]=XCu
set Ad=Ad+1
if Ie[LCu]==0 then
call tsw("Double free: object of type TowerBlockadeBuff","when calling error in ")
else
set Ee[Ze]=LCu
set Ze=Ze+1
set Ie[LCu]=0
endif
set Ad=Ad-1
endfunction
function aIu takes integer eIu,string qIu returns nothing
set Dd[Ad]=qIu
set Ad=Ad+1
if on[eIu]==0 then
call tsw("Double free: object of type LLIterator","when calling error in ")
else
set tn[Sn]=eIu
set Sn=Sn+1
set on[eIu]=0
endif
set Ad=Ad-1
endfunction
function sgw takes integer rgw returns nothing
endfunction
function AGw takes integer IGw,string PGw returns nothing
set Dd[Ad]=PGw
set Ad=Ad+1
call sgw(IGw)
call aIu(IGw,"when calling LLIterator in LinkedList, line 381")
set Ad=Ad-1
endfunction
function JUu takes integer DUu,string HUu returns nothing
set Dd[Ad]=HUu
set Ad=Ad+1
if on[DUu]==0 then
if DUu==0 then
call tsw("Nullpointer exception when calling LLIterator.destroyLLIterator","when calling error in ")
else
call tsw("Called LLIterator.destroyLLIterator on invalid object.","when calling error in ")
endif
endif
call AGw(DUu,"when calling destroyLLIterator in LinkedList, line 381")
set Ad=Ad-1
endfunction
function RGw takes integer dGw,string fGw returns nothing
set Dd[Ad]=fGw
set Ad=Ad+1
if so[dGw]then
call JUu(dGw,"when calling LLIterator in LinkedList, line 425")
endif
set Ad=Ad-1
endfunction
function VSu takes unit CSu returns nothing
call PauseUnit(CSu,false)
endfunction
function U6w takes integer Z6w returns nothing
call VSu(Nt[Z6w])
endfunction
function VGw takes integer LGw,integer XGw,string CGw returns nothing
set Dd[Ad]=CGw
set Ad=Ad+1
set so[LGw]=true
set ro[LGw]=XGw
call XUu(LGw,"when calling reset in LinkedList, line 389")
set Ad=Ad-1
endfunction
function QGw takes integer xGw,string vGw returns integer
local integer mGw
set Dd[Ad]=vGw
set Ad=Ad+1
set mGw=pIu("when calling LLIterator in LinkedList, line 387")
call VGw(mGw,xGw,"when calling construct_LLIterator in LinkedList, line 387")
set Ad=Ad-1
return mGw
endfunction
function lgw takes integer cgw,string ogw returns integer
local integer Ogw
set Dd[Ad]=ogw
set Ad=Ad+1
set Ogw=QGw(cgw,"when calling new_LLIterator in LinkedList, line 156")
set Ad=Ad-1
return Ogw
endfunction
function A9u takes integer Z9u,string U9u returns nothing
local integer I9u
local integer P9u
set Dd[Ad]=U9u
set Ad=Ad+1
call U6w(Z9u)
set I9u=lgw(Xy[Z9u],"when calling iterator in TrooperTower, line 92")
loop
exitwhen not nGw(I9u)
set P9u=qGw(I9u)
call VSu(Nt[P9u])
endloop
call RGw(I9u,"when calling close in TrooperTower, line 92")
set Ad=Ad-1
endfunction
function GVu takes integer TVu,string YVu returns nothing
set Dd[Ad]=YVu
set Ad=Ad+1
if Oe[TVu]==0 then
if TVu==0 then
call tsw("Nullpointer exception when calling Tower.Tower_Tower_unpause","when calling error in ")
else
call tsw("Called Tower.Tower_Tower_unpause on invalid object.","when calling error in ")
endif
endif
if Oe[TVu]<=866 then
if Oe[TVu]<=865 then
call U6w(TVu)
else
call A9u(TVu,"when calling unpause in Tower, line 59")
endif
else
call U6w(TVu)
endif
set Ad=Ad-1
endfunction
function P5w takes integer U5w,string I5w returns nothing
set Dd[Ad]=I5w
set Ad=Ad+1
if uu[U5w]!=0 then
call GVu(uu[U5w],"when calling unpause in TowerBlockade, line 65")
endif
if Fy[U5w]!=0 then
call Oxu(Fy[U5w],"when calling remove in TowerBlockade, line 67")
endif
call HP(U5w,"when calling Buff_onDestroy in TowerBlockade, line 29")
set Ad=Ad-1
endfunction
function k5w takes integer h5w,string F5w returns nothing
set Dd[Ad]=F5w
set Ad=Ad+1
call P5w(h5w,"when calling TowerBlockadeBuff_onDestroy in TowerBlockade, line 63")
call CCu(h5w,"when calling TowerBlockadeBuff in TowerBlockade, line 63")
set Ad=Ad-1
endfunction
function lRu takes integer oRu,string ORu returns nothing
set Dd[Ad]=ORu
set Ad=Ad+1
if Ie[oRu]==0 then
if oRu==0 then
call tsw("Nullpointer exception when calling Buff.destroyBuff","when calling error in ")
else
call tsw("Called Buff.destroyBuff on invalid object.","when calling error in ")
endif
endif
if Ie[oRu]<=647 then
call jP(oRu,"when calling destroyBuff in Buff, line 71")
else
call k5w(oRu,"when calling destroyTowerBlockadeBuff in Buff, line 71")
endif
set Ad=Ad-1
endfunction
function wP takes integer NI,string MI returns nothing
set Dd[Ad]=MI
set Ad=Ad+1
if not iu[NI]then
set iu[NI]=true
call lRu(NI,"when calling Buff in Buff, line 110")
endif
set Ad=Ad-1
endfunction
function OAu takes integer cAu,string oAu returns nothing
set Dd[Ad]=oAu
set Ad=Ad+1
if yn[cAu]==0 then
call tsw("Double free: object of type LinkedList","when calling error in ")
else
set On[ln]=cAu
set ln=ln+1
set yn[cAu]=0
endif
set Ad=Ad-1
endfunction
function BYw takes integer VYw returns nothing
endfunction
function vUu takes integer jUu,string xUu returns nothing
set Dd[Ad]=xUu
set Ad=Ad+1
if Ma[jUu]==0 then
call tsw("Double free: object of type LLBackIterator","when calling error in ")
else
set Na=Na+1
set Ma[jUu]=0
endif
set Ad=Ad-1
endfunction
function CYw takes integer LYw,string XYw returns nothing
set Dd[Ad]=XYw
set Ad=Ad+1
call BYw(LYw)
call vUu(LYw,"when calling LLBackIterator in LinkedList, line 427")
set Ad=Ad-1
endfunction
function kUu takes integer hUu,string FUu returns nothing
set Dd[Ad]=FUu
set Ad=Ad+1
if Ma[hUu]==0 then
if hUu==0 then
call tsw("Nullpointer exception when calling LLBackIterator.destroyLLBackIterator","when calling error in ")
else
call tsw("Called LLBackIterator.destroyLLBackIterator on invalid object.","when calling error in ")
endif
endif
call CYw(hUu,"when calling destroyLLBackIterator in LinkedList, line 427")
set Ad=Ad-1
endfunction
function SFw takes integer sFw,string tFw returns nothing
local integer iFw
set Dd[Ad]=tFw
set Ad=Ad+1
if Oo[sFw]!=0 then
call JUu(Oo[sFw],"when calling LLIterator in LinkedList, line 356")
endif
if lo[sFw]!=0 then
call kUu(lo[sFw],"when calling LLBackIterator in LinkedList, line 358")
endif
set iFw=Mc[co[sFw]]
loop
exitwhen not(iFw!=co[sFw])
set iFw=Mc[iFw]
call WUu(Nc[iFw],"when calling LLEntry in LinkedList, line 362")
endloop
call WUu(co[sFw],"when calling LLEntry in LinkedList, line 363")
set Ad=Ad-1
endfunction
function OFw takes integer cFw,string oFw returns nothing
set Dd[Ad]=oFw
set Ad=Ad+1
call SFw(cFw,"when calling LinkedList_onDestroy in LinkedList, line 354")
call OAu(cFw,"when calling LinkedList in LinkedList, line 354")
set Ad=Ad-1
endfunction
function xIu takes integer kIu,string jIu returns nothing
set Dd[Ad]=jIu
set Ad=Ad+1
if yn[kIu]==0 then
if kIu==0 then
call tsw("Nullpointer exception when calling LinkedList.destroyLinkedList","when calling error in ")
else
call tsw("Called LinkedList.destroyLinkedList on invalid object.","when calling error in ")
endif
endif
call OFw(kIu,"when calling destroyLinkedList in LinkedList, line 13")
set Ad=Ad-1
endfunction
function xtu takes unit jtu returns boolean
return foo(jtu)
endfunction
function J4u takes integer E4u,integer Z4u,string U4u,integer I4u,string P4u returns nothing
local integer A4u
local integer D4u
local integer H4u
if E4u==0 then
set Dd[Ad]=U4u
set Ad=Ad+1
call J4u(1,Z4u,"when calling clearBuffs in Entity, line 263",0,null)
if sww(Nt[Z4u])==Z4u then
call Sww(Nt[Z4u],0)
if xtu(Nt[Z4u]) then
if vi then
call Wsu(Nt[Z4u])
else
call biu(Nt[Z4u])
endif
endif
endif
set Nt[Z4u]=null
call auw(Z4u,"when calling Entity_onDestroy in Entity, line 195")
set Ad=Ad-1
elseif E4u==1 then
set Dd[Ad]=U4u
set Ad=Ad+1
set A4u=Bw[Z4u]
if A4u!=0 then
call DEw("Cleaning Buffs")
set H4u=cPu(A4u,"when calling staticItr in Buff, line 43")
loop
exitwhen not nGw(H4u)
set D4u=qGw(H4u)
call DEw("Clear buffs: Terminate")
call J4u(2,D4u,"when calling terminate in Buff, line 45",0,null)
endloop
call xIu(A4u,"when calling LinkedList in Buff, line 46")
set Bw[Z4u]=0
endif
set Ad=Ad-1
elseif E4u==2 then
set Dd[Ad]=U4u
set Ad=Ad+1
if Ie[Z4u]==0 then
if Z4u==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_terminate","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_terminate on invalid object.","when calling error in ")
endif
endif
if Ie[Z4u]<=647 then
call wP(Z4u,"when calling terminate in Buff, line 107")
else
call J4u(3,0,null,Z4u,"when calling terminate in Buff, line 107")
endif
set Ad=Ad-1
elseif E4u==3 then
if Z4u==0 then
set Dd[Ad]=P4u
set Ad=Ad+1
call p5(ky[I4u])
if Fy[I4u]!=0 and xtu(Nt[Fy[I4u]]) then
call J4u(3,1,null,Fy[I4u],"when calling BlockadeShip in TowerBlockade, line 59")
endif
call wP(I4u,"when calling terminate in TowerBlockade, line 60")
set Ad=Ad-1
elseif Z4u==1 then
set Dd[Ad]=P4u
set Ad=Ad+1
if Oe[I4u]==0 then
if I4u==0 then
call tsw("Nullpointer exception when calling BlockadeShip.destroyBlockadeShip","when calling error in ")
else
call tsw("Called BlockadeShip.destroyBlockadeShip on invalid object.","when calling error in ")
endif
endif
call J4u(3,2,null,I4u,"when calling destroyBlockadeShip in TowerBlockade, line 69")
set Ad=Ad-1
elseif Z4u==2 then
set Dd[Ad]=P4u
set Ad=Ad+1
call J4u(3,3,null,I4u,"when calling BlockadeShip_onDestroy in TowerBlockade, line 84")
call WCu(I4u,"when calling BlockadeShip in TowerBlockade, line 84")
set Ad=Ad-1
elseif Z4u==3 then
set Dd[Ad]=P4u
set Ad=Ad+1
if xtu(Nt[I4u]) then
call J4u(3,4,null,hy[I4u],"when calling terminate in TowerBlockade, line 86")
endif
call J4u(0,I4u,"when calling UnitEntity_onDestroy in TowerBlockade, line 69",0,null)
set Ad=Ad-1
elseif Z4u==4 then
set Dd[Ad]=P4u
set Ad=Ad+1
if Ie[I4u]==0 then
if I4u==0 then
call tsw("Nullpointer exception when calling TowerBlockadeBuff.TowerBlockade_TowerBlockadeBuff_terminate","when calling error in ")
else
call tsw("Called TowerBlockadeBuff.TowerBlockade_TowerBlockadeBuff_terminate on invalid object.","when calling error in ")
endif
endif
call J4u(3,0,null,I4u,"when calling terminate in TowerBlockade, line 56")
set Ad=Ad-1
endif
endif
endfunction
function Osu takes unit csu,integer osu returns boolean
return UnitAddAbility(csu,osu)
endfunction
function htu takes unit Gtu,integer gtu returns boolean
return GetUnitAbilityLevel(Gtu,gtu)>0
endfunction
function hP takes integer qP,boolean aP returns nothing
local unit GP=Nt[uu[qP]]
local integer nP=qP
local integer fP=su[nP]
local integer dP=fP
local integer RP
local integer TP
local integer YP
local unit gP
if (not htu(GP,dP))or aP then
set gP=Nt[uu[qP]]
set RP=qP
set YP=su[RP]
set TP=YP
call Osu(gP,TP)
endif
set GP=null
set gP=null
endfunction
function Hiu takes unit Piu,player Aiu,boolean Diu returns nothing
call SetUnitOwner(Piu,Aiu,Diu)
endfunction
function ctu takes unit Stu returns real
return GetUnitY(Stu)
endfunction
function itu takes unit ttu returns real
return GetUnitX(ttu)
endfunction
function KQw takes player DQw,unit HQw,real JQw returns nothing
if lO==DQw then
call PanCameraToTimed(itu(HQw),ctu(HQw),JQw)
endif
endfunction
function NQw takes player VQw,unit BQw returns nothing
if lO==VQw then
call ClearSelection()
call SelectUnit(BQw,true)
endif
endfunction
function Oiu takes unit ciu,string oiu returns nothing
call QueueUnitAnimation(ciu,oiu)
endfunction
function Tiu takes unit fiu,string Riu returns nothing
call SetUnitAnimation(fiu,Riu)
endfunction
function Iiu takes unit Eiu,unitstate Ziu,real Uiu returns nothing
call SetUnitState(Eiu,Ziu,Uiu)
endfunction
function Wiu takes unit miu,real Qiu returns nothing
call Iiu(miu,UNIT_STATE_LIFE,Qiu)
endfunction
function XSu takes unit LSu returns nothing
call ShowUnit(LSu,true)
endfunction
function Ycu takes real Rcu,real Tcu returns real
set kf=Rcu
set jf=Tcu
set xf=0.
return kf
endfunction
function G5 takes string f5,real R5,real T5,real Y5 returns effect
return AddSpecialEffect(f5,R5,T5)
endfunction
function d5 takes string e5,real q5,real a5,real n5 returns nothing
call p5(G5(e5,q5,a5,n5))
endfunction
function k5 takes string g5,real h5,real F5 returns nothing
call d5(g5,Ycu(h5,F5),jf,xf)
endfunction
function kQw takes player FQw returns integer
return GetPlayerId(FQw)
endfunction
function stu takes unit rtu returns real
set Sf=itu(rtu)
set cf=ctu(rtu)
return Sf
endfunction
function ySu takes unit lSu,real bSu returns nothing
call SetUnitTimeScale(lSu,bSu)
endfunction
function qbu takes integer wbu,boolean ubu returns nothing
local integer rbu
local unit sbu
local real tbu
local unit ibu
local unit Sbu
local unit cbu
local unit obu
local unit Obu
local unit lbu
local unit bbu
local player ybu
local player pbu
local unit ebu
call hP(wbu,ubu)
if Fp[wbu]then
set rbu=oO[wO[kQw(Et[uu[wbu]])]]
set sbu=Nt[uu[wbu]]
call VSu(sbu)
set ibu=sbu
set ebu=ibu
if rbu==1 then
set tbu=0.25
else
set tbu=1.0
endif
call ySu(ebu,tbu)
set Sbu=ibu
call Wiu(Sbu,9999.)
set cbu=Sbu
call XSu(cbu)
set obu=cbu
call Tiu(obu,"stand")
set Obu=obu
call Oiu(Obu,"stand")
set lbu=Obu
call eiu(lbu,1098282348)
set bbu=lbu
call Hiu(bbu,kp[wbu],false)
set ybu=Et[uu[wbu]]
call NQw(ybu,Nt[uu[wbu]])
set pbu=ybu
call KQw(pbu,Nt[uu[wbu]],0.)
call k5(A,stu(Nt[uu[wbu]]),cf)
set Fp[wbu]=false
set Gp[wbu]=Ni
endif
set sbu=null
set ibu=null
set Sbu=null
set cbu=null
set obu=null
set Obu=null
set lbu=null
set bbu=null
set ybu=null
set pbu=null
set ebu=null
endfunction
function URu takes integer WRu,boolean ERu,string ZRu returns nothing
set Dd[Ad]=ZRu
set Ad=Ad+1
if Ie[WRu]==0 then
if WRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_refresh","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_refresh on invalid object.","when calling error in ")
endif
endif
if Ie[WRu]<=646 then
if Ie[WRu]<=645 then
call hP(WRu,ERu)
else
call qbu(WRu,ERu)
endif
else
call hP(WRu,ERu)
endif
set Ad=Ad-1
endfunction
function eP takes integer yP,string pP returns nothing
set Dd[Ad]=pP
set Ad=Ad+1
call URu(yP,false,"when calling refresh in Buff, line 101")
set Ad=Ad-1
endfunction
function QRu takes integer vRu,string mRu returns nothing
set Dd[Ad]=mRu
set Ad=Ad+1
if Ie[vRu]==0 then
if vRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_refresh","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_refresh on invalid object.","when calling error in ")
endif
endif
call eP(vRu,"when calling refresh in Buff, line 100")
set Ad=Ad-1
endfunction
function UUu takes string EUu returns integer
local integer ZUu
set Dd[Ad]=EUu
set Ad=Ad+1
if un==0 then
if rn<32768 then
set rn=rn+1
set ZUu=rn
set sn[ZUu]=774
else
call tsw("Out of memory: Could not create LLEntry.","when calling error in ")
set ZUu=0
endif
else
set un=un-1
set ZUu=wn[un]
set sn[ZUu]=774
endif
set Ad=Ad-1
return ZUu
endfunction
function bGw takes integer cGw,integer oGw,integer OGw,integer lGw returns nothing
set Bc[cGw]=oGw
set Nc[cGw]=OGw
set Mc[cGw]=lGw
endfunction
function sGw takes integer NYw,integer MYw,integer wGw,string uGw returns integer
local integer rGw
set Dd[Ad]=uGw
set Ad=Ad+1
set rGw=UUu("when calling LLEntry in LinkedList, line 376")
call bGw(rGw,NYw,MYw,wGw)
set Ad=Ad-1
return rGw
endfunction
function g3u takes integer R3u,integer T3u,string Y3u returns nothing
local integer G3u
set Dd[Ad]=Y3u
set Ad=Ad+1
set G3u=sGw(T3u,Nc[co[R3u]],co[R3u],"when calling new_LLEntry in LinkedList, line 35")
set Mc[Nc[co[R3u]]]=G3u
set Nc[co[R3u]]=G3u
set oo[R3u]=oo[R3u]+1
set Ad=Ad-1
endfunction
function j3u takes integer h3u,integer F3u,string k3u returns nothing
set Dd[Ad]=k3u
set Ad=Ad+1
if yn[h3u]==0 then
if h3u==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_add","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_add on invalid object.","when calling error in ")
endif
endif
call g3u(h3u,F3u,"when calling add in LinkedList, line 33")
set Ad=Ad-1
endfunction
function VU takes integer LU,integer XU,string CU returns nothing
set Dd[Ad]=CU
set Ad=Ad+1
if XU==0 then
call tsw("Cannot add null buff","when calling error in Buff, line 17")
endif
call DEw("Added buff")
call j3u(Bw[LU],XU,"when calling add in Buff, line 19")
set Ad=Ad-1
endfunction
function SAu takes string tAu returns integer
local integer iAu
set Dd[Ad]=tAu
set Ad=Ad+1
if ln==0 then
if bn<32768 then
set bn=bn+1
set iAu=bn
set yn[iAu]=783
else
call tsw("Out of memory: Could not create LinkedList.","when calling error in ")
set iAu=0
endif
else
set ln=ln-1
set iAu=On[ln]
set yn[iAu]=783
endif
set Ad=Ad-1
return iAu
endfunction
function rFw takes integer wFw,string uFw returns nothing
set Dd[Ad]=uFw
set Ad=Ad+1
set co[wFw]=sGw(0,0,0,"when calling new_LLEntry in LinkedList, line 14")
set oo[wFw]=0
set Oo[wFw]=0
set lo[wFw]=0
set Mc[co[wFw]]=co[wFw]
set Nc[co[wFw]]=co[wFw]
set Ad=Ad-1
endfunction
function Ngw takes string Vgw returns integer
local integer Bgw
set Dd[Ad]=Vgw
set Ad=Ad+1
set Bgw=SAu("when calling LinkedList in LinkedList, line 27")
call rFw(Bgw,"when calling construct_LinkedList2 in LinkedList, line 27")
set Ad=Ad-1
return Bgw
endfunction
function qI takes integer pI,string eI returns integer
set Dd[Ad]=eI
set Ad=Ad+1
set Bw[pI]=Ngw("when calling new_LinkedList in Buff, line 68")
set Ad=Ad-1
return Bw[pI]
endfunction
function VWw takes integer HWw,integer JWw,string KWw returns nothing
local integer LWw
local integer XWw
local integer CWw
set Dd[Ad]=KWw
set Ad=Ad+1
set uu[HWw]=JWw
if not KU(JWw) then
call qI(JWw,"when calling newBuffs in PresetBuffs, line 75")
else
set LWw=lgw(iI(JWw),"when calling iterator in PresetBuffs, line 77")
loop
exitwhen not nGw(LWw)
set XWw=qGw(LWw)
if Ie[XWw]==Ie[HWw] and XWw!=HWw then
set CWw=XWw
set ru[CWw]=ru[HWw]
set fO[CWw]=fO[CWw]+fO[HWw]
set uu[HWw]=0
call J4u(2,HWw,"when calling terminate in PresetBuffs, line 83",0,null)
call RGw(LWw,"when calling close in PresetBuffs, line 77")
set Ad=Ad-1
return
endif
endloop
call RGw(LWw,"when calling close in PresetBuffs, line 77")
endif
call VU(JWw,HWw,"when calling addBuff in PresetBuffs, line 85")
call QRu(HWw,"when calling refresh in PresetBuffs, line 86")
set Ad=Ad-1
endfunction
function Dsu takes unit Asu returns real
return GetUnitFlyHeight(Asu)
endfunction
function hcu takes real Gcu,real gcu returns real
call MoveLocation(dp,Gcu,gcu)
return GetLocationZ(dp)
endfunction
function ptu takes real ltu,real btu,unit ytu returns real
set VR=ltu
set BR=btu
set NR=hcu(ltu,btu)+Dsu(ytu)
return VR
endfunction
function Otu takes unit otu returns real
set Md=ptu(stu(otu),cf,otu)
set wf=BR
set uf=NR
return Md
endfunction
function qtu takes unit etu returns real
set aR=itu(etu)
set nR=ctu(etu)
set dR=Dsu(etu)
return aR
endfunction
function prw takes integer Orw returns real
local integer lrw
local integer brw
local integer yrw
if not Vt[Orw]then
if xi then
set lrw=Orw
set ht[lrw]=Otu(Nt[Orw])
set Ft[lrw]=wf
set kt[lrw]=uf
else
set brw=Orw
set ht[brw]=qtu(Nt[Orw])
set Ft[brw]=nR
set kt[brw]=dR
endif
endif
set yrw=Orw
set iT=ht[yrw]
set ST=Ft[yrw]
set cT=kt[yrw]
return iT
endfunction
function wvu takes integer Kxu,string Lxu returns real
local real Xxu
local real Cxu
local real Vxu
local real Bxu
local real Nxu
local real Mxu
set Dd[Ad]=Lxu
set Ad=Ad+1
if Oe[Kxu]==0 then
if Kxu==0 then
call tsw("Nullpointer exception when calling UnitEntity.Entity_UnitEntity_getPos","when calling error in ")
else
call tsw("Called UnitEntity.Entity_UnitEntity_getPos on invalid object.","when calling error in ")
endif
endif
set Bxu=prw(Kxu)
set Nxu=ST
set Mxu=cT
set Xxu=Bxu
set Cxu=Nxu
set Vxu=Mxu
set Ad=Ad-1
set rf=Xxu
set sf=Cxu
set tf=Vxu
return rf
endfunction
function XHw takes integer HHw,integer JHw,string KHw returns nothing
local integer LHw
set Dd[Ad]=KHw
set Ad=Ad+1
call VWw(HHw,JHw,"when calling apply in ShieldKit, line 18")
set LHw=HHw
set fl[LHw]=wvu(JHw,"when calling getPos in ShieldKit, line 19")
set Rl[LHw]=sf
set Tl[LHw]=tf
set Ad=Ad-1
endfunction
function LJu takes integer HJu,integer JJu,string KJu returns nothing
set Dd[Ad]=KJu
set Ad=Ad+1
if Ie[HJu]==0 then
if HJu==0 then
call tsw("Nullpointer exception when calling ShieldKitBuff.ShieldKit_ShieldKitBuff_apply","when calling error in ")
else
call tsw("Called ShieldKitBuff.ShieldKit_ShieldKitBuff_apply on invalid object.","when calling error in ")
endif
endif
call XHw(HJu,JJu,"when calling apply in ShieldKit, line 17")
set Ad=Ad-1
endfunction
function VJu takes string XJu returns integer
local integer CJu
set Dd[Ad]=XJu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set CJu=Ue
set Ie[CJu]=644
else
call tsw("Out of memory: Could not create ShieldKitBuff.","when calling error in ")
set CJu=0
endif
else
set Ze=Ze-1
set CJu=Ee[Ze]
set Ie[CJu]=644
endif
set Ad=Ad-1
return CJu
endfunction
function BP takes integer VP returns nothing
set ou=ou+1
if ou==1 then
set Su=VP
set Ou[VP]=0
else
set Ou[VP]=cu
set lu[cu]=VP
set Ou[Su]=VP
endif
set lu[VP]=0
set cu=VP
endfunction
function EP takes integer xP,real vP,integer mP,integer QP returns nothing
local integer WP
set uu[xP]=0
set iu[xP]=false
call BP(xP)
set ru[xP]=vP
set WP=xP
set su[WP]=mP
set tu[WP]=QP
endfunction
function DWw takes integer UWw,real IWw,integer PWw,integer AWw returns nothing
call EP(UWw,IWw,PWw,AWw)
endfunction
function OEw takes integer tEw,real iEw,integer SEw,integer cEw,real oEw returns nothing
call DWw(tEw,iEw,SEw,cEw)
set fO[tEw]=oEw
endfunction
function pUw takes real yUw returns string
return R2S(yUw)
endfunction
function lJw takes integer oJw,real OJw returns nothing
call OEw(oJw,90.,nl,dl,OJw)
call DEw("ShieldKit created, dur: "+pUw(ru[oJw])+" amount: "+pUw(OJw))
endfunction
function cJw takes real tJw,string iJw returns integer
local integer SJw
set Dd[Ad]=iJw
set Ad=Ad+1
set SJw=VJu("when calling ShieldKitBuff in ShieldKit, line 13")
call lJw(SJw,tJw)
set Ad=Ad-1
return SJw
endfunction
function DHw takes integer ZHw,unit UHw,unit IHw,string PHw returns nothing
local integer AHw
set Dd[Ad]=PHw
set Ad=Ad+1
set AHw=sww(IHw)
call LJu(cJw(200.+Hyw()*2.,"when calling new_ShieldKitBuff in ShieldKit, line 35"),AHw,"when calling apply in ShieldKit, line 35")
set Ad=Ad-1
endfunction
function dXu takes string aXu returns integer
local integer nXu
set Dd[Ad]=aXu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set nXu=ae
set ne[nXu]=689
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set nXu=0
endif
else
set qe=qe-1
set nXu=ee[qe]
set ne[nXu]=689
endif
set Ad=Ad-1
return nXu
endfunction
function diu takes unit qiu,integer aiu,integer niu returns nothing
call SetUnitAbilityLevel(qiu,aiu,niu)
endfunction
function XMw takes integer DMw,unit HMw,unit JMw,string KMw returns nothing
local integer LMw
set Dd[Ad]=KMw
set Ad=Ad+1
call diu(JMw,Cb,2)
call k5(E,stu(JMw),cf)
set LMw=dXu("when calling alloc_Closure in SuperCharge, line 13")
call VC(LMw)
set Vb[LMw]=JMw
call gX(15.,LMw,"when calling doAfter in SuperCharge, line 13")
set Ad=Ad-1
endfunction
function NTu takes integer XTu,unit CTu,unit VTu,string BTu returns nothing
set Dd[Ad]=BTu
set Ad=Ad+1
if pe[XTu]==0 then
if XTu==0 then
call tsw("Nullpointer exception when calling OnUnitCast.ClosureEvents_OnUnitCast_fireEx","when calling error in ")
else
call tsw("Called OnUnitCast.ClosureEvents_OnUnitCast_fireEx on invalid object.","when calling error in ")
endif
endif
if pe[XTu]<=800 then
call DHw(XTu,CTu,VTu,"when calling ShieldKit_closure_impl in ClosureEvents, line 95")
else
call XMw(XTu,CTu,VTu,"when calling SuperCharge_closure_impl in ClosureEvents, line 95")
endif
set Ad=Ad-1
endfunction
function AL takes integer UL,unit IL,string PL returns nothing
set Dd[Ad]=PL
set Ad=Ad+1
call NTu(UL,IL,GetSpellTargetUnit(),"when calling fireEx in ClosureEvents, line 93")
set Ad=Ad-1
endfunction
function bmw takes integer lmw returns nothing
endfunction
function Fh takes real hh returns real
return hh*C
endfunction
function viu takes unit jiu,real xiu returns nothing
call SetUnitFacing(jiu,Fh(xiu))
endfunction
function olw takes integer Slw,real clw returns nothing
call viu(Zi[Slw],clw)
endfunction
function mQu takes integer jQu,real xQu,string vQu returns nothing
set Dd[Ad]=vQu
set Ad=Ad+1
if Fa[jQu]==0 then
if jQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setXYAngle","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setXYAngle on invalid object.","when calling error in ")
endif
endif
call olw(jQu,xQu)
set Ad=Ad-1
endfunction
function WZw takes integer vZw,real mZw,string QZw returns nothing
set Dd[Ad]=QZw
set Ad=Ad+1
set YO[vZw]=mZw
call mQu(Wi[vZw],mZw,"when calling setXYAngle in Projectile, line 47")
set Ad=Ad-1
endfunction
function oHu takes integer iHu,real SHu,string cHu returns nothing
set Dd[Ad]=cHu
set Ad=Ad+1
if Oe[iHu]==0 then
if iHu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setXYAngle","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setXYAngle on invalid object.","when calling error in ")
endif
endif
call WZw(iHu,SHu,"when calling setXYAngle in Projectile, line 45")
set Ad=Ad-1
endfunction
function EOu takes real mOu,real QOu,real WOu returns real
set Wf=mOu
set Ef=QOu
return Wf
endfunction
function Kqu takes widget Dqu,string Hqu,string Jqu returns effect
return AddSpecialEffectTarget(Hqu,Dqu,Jqu)
endfunction
function KOw takes integer HOw,string JOw returns nothing
if Ui[HOw]!=null then
call p5(Ui[HOw])
endif
if JOw=="" then
set Ui[HOw]=null
else
set Ui[HOw]=Kqu(Zi[HOw],JOw,"origin")
endif
endfunction
function NQu takes integer CQu,string VQu,string BQu returns nothing
set Dd[Ad]=BQu
set Ad=Ad+1
if Fa[CQu]==0 then
if CQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setFx","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setFx on invalid object.","when calling error in ")
endif
endif
call KOw(CQu,VQu)
set Ad=Ad-1
endfunction
function f3u takes integer q3u,integer a3u,string n3u returns unit
local unit d3u
set Dd[Ad]=n3u
set Ad=Ad+1
if a3u<0 or a3u>=6 then
call tsw("Index out of Bounds","when calling error in ")
elseif a3u<=2 then
if a3u<=1 then
if a3u<=0 then
set d3u=Wd[q3u]
else
set d3u=Ed[q3u]
endif
else
set d3u=Zd[q3u]
endif
elseif a3u<=4 then
if a3u<=3 then
set d3u=Ud[q3u]
else
set d3u=Id[q3u]
endif
else
set d3u=Pd[q3u]
endif
set Ad=Ad-1
set Vg=d3u
set d3u=null
return Vg
endfunction
function l2 takes integer c2,string o2 returns unit
local unit O2
set Dd[Ad]=o2
set Ad=Ad+1
if ps[c2]>0 then
set ps[c2]=ps[c2]-1
set bs[c2]=ModuloInteger(bs[c2]+1,ls)
set O2=f3u(c2,bs[c2],"when calling units in DummyRecycler, line 66")
set Ad=Ad-1
set Wg=O2
set O2=null
return Wg
else
call tsw("Queue empty","when calling error in DummyRecycler, line 68")
set Ad=Ad-1
set O2=null
return null
endif
endfunction
function Lgu takes integer Hgu,string Jgu returns unit
local unit Kgu
set Dd[Ad]=Jgu
set Ad=Ad+1
if mq[Hgu]==0 then
if Hgu==0 then
call tsw("Nullpointer exception when calling ArrayQueue.DummyRecycler_ArrayQueue_dequeue","when calling error in ")
else
call tsw("Called ArrayQueue.DummyRecycler_ArrayQueue_dequeue on invalid object.","when calling error in ")
endif
endif
set Kgu=l2(Hgu,"when calling dequeue in DummyRecycler, line 62")
set Ad=Ad-1
set Kg=Kgu
set Kgu=null
return Kg
endfunction
function Iru takes player Qru,integer Wru,real Eru,real Zru,real Uru returns unit
return CreateUnit(Qru,Wru,Eru,Zru,Fh(Uru))
endfunction
function TSu takes unit fSu,real RSu returns nothing
call SetUnitX(fSu,RSu)
endfunction
function vSu takes unit jSu,real xSu returns nothing
call SetUnitY(jSu,xSu)
endfunction
function kSu takes unit YSu,real GSu,real gSu returns nothing
local unit hSu=YSu
local unit FSu
call TSu(hSu,GSu)
set FSu=hSu
call vSu(FSu,gSu)
set hSu=null
set FSu=null
endfunction
function S2 takes real B4,real N4,player M4,real w2 returns unit
local unit u2=Iru(M4,cs,B4,N4,w2)
local unit r2=u2
local unit s2
local unit t2
local unit i2
call kSu(r2,B4,N4)
set s2=r2
call Osu(s2,tw)
set t2=s2
call eiu(t2,tw)
set i2=t2
call Osu(i2,iw)
set Qg=u2
set u2=null
set r2=null
set s2=null
set t2=null
set i2=null
return Qg
endfunction
function V2 takes real P2,real A2,real D2,string H2 returns unit
local integer J2
local unit K2
local unit L2
local unit X2
local unit C2
set Dd[Ad]=H2
set Ad=Ad+1
set J2=bUw(bUw(ModuloReal(Fh(D2),360.))/Os)
if ps[Rs[J2]]>0 then
set K2=Lgu(Rs[J2],"when calling dequeue in DummyRecycler, line 26")
call kSu(K2,P2,A2)
set L2=K2
call VSu(L2)
set C2=L2
set Ad=Ad-1
set Eg=C2
set K2=null
set L2=null
set X2=null
set C2=null
return Eg
else
set X2=S2(P2,A2,cw,D2)
set Ad=Ad-1
set Zg=X2
set K2=null
set L2=null
set X2=null
set C2=null
return Zg
endif
endfunction
function Nru takes unit Cru,real Vru,real Bru returns nothing
call SetUnitFlyHeight(Cru,Vru,Bru)
endfunction
function Rlw takes integer dlw,real flw returns nothing
call Nru(Zi[dlw],flw,0.)
endfunction
function XQu takes integer JQu,real KQu,string LQu returns nothing
set Dd[Ad]=LQu
set Ad=Ad+1
if Fa[JQu]==0 then
if JQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setZ","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setZ on invalid object.","when calling error in ")
endif
endif
call Rlw(JQu,KQu)
set Ad=Ad-1
endfunction
function DOw takes integer AOw returns unit
return Zi[AOw]
endfunction
function RQu takes integer nQu,string dQu returns unit
local unit fQu
set Dd[Ad]=dQu
set Ad=Ad+1
if Fa[nQu]==0 then
if nQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_getDummy","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_getDummy on invalid object.","when calling error in ")
endif
endif
set fQu=DOw(nQu)
set Ad=Ad-1
set Xg=fQu
set fQu=null
return Xg
endfunction
function kiu takes unit hiu,playercolor Fiu returns nothing
call SetUnitColor(hiu,Fiu)
endfunction
function POw takes integer ZOw,playercolor UOw,string IOw returns nothing
set Dd[Ad]=IOw
set Ad=Ad+1
call kiu(RQu(ZOw,"when calling getDummy in Fx, line 67"),UOw)
set Ad=Ad-1
endfunction
function uQu takes integer Nmu,playercolor Mmu,string wQu returns nothing
set Dd[Ad]=wQu
set Ad=Ad+1
if Fa[Nmu]==0 then
if Nmu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setPlayerColor","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setPlayerColor on invalid object.","when calling error in ")
endif
endif
call POw(Nmu,Mmu,"when calling setPlayerColor in Fx, line 66")
set Ad=Ad-1
endfunction
function Fbw takes integer nbw,playercolor dbw,real fbw,real Rbw,real Tbw,real Ybw,string Gbw,string gbw returns nothing
local integer hbw
set Dd[Ad]=gbw
set Ad=Ad+1
set Zi[nbw]=null
set Ui[nbw]=null
set hbw=nbw
set Ii[hbw]=255
set Pi[hbw]=255
set Ai[hbw]=255
set Di[hbw]=255
set Zi[nbw]=V2(EOu(fbw,Rbw,Tbw),Ef,Ybw,"when calling get in Fx, line 57")
call NQu(nbw,Gbw,"when calling setFx in Fx, line 58")
call XQu(nbw,Tbw,"when calling setZ in Fx, line 59")
call uQu(nbw,dbw,"when calling setPlayerColor in Fx, line 60")
set Ad=Ad-1
endfunction
function tWu takes string rWu returns integer
local integer sWu
set Dd[Ad]=rWu
set Ad=Ad+1
if ga==0 then
if ha<32768 then
set ha=ha+1
set sWu=ha
set Fa[sWu]=761
else
call tsw("Out of memory: Could not create Fx.","when calling error in ")
set sWu=0
endif
else
set ga=ga-1
set sWu=Ga[ga]
set Fa[sWu]=761
endif
set Ad=Ad-1
return sWu
endfunction
function abw takes playercolor obw,real Obw,real lbw,real bbw,real ybw,string pbw,string ebw returns integer
local integer qbw
set Dd[Ad]=ebw
set Ad=Ad+1
set qbw=tWu("when calling Fx in Fx, line 56")
call Fbw(qbw,obw,Obw,lbw,bbw,ybw,pbw,"when calling construct_Fx8 in Fx, line 56")
set Ad=Ad-1
return qbw
endfunction
function iWw takes player tWw returns playercolor
return GetPlayerColor(tWw)
endfunction
function nOw takes integer lOw,real bOw,string yOw,string pOw returns nothing
local integer eOw
local playercolor qOw
local integer aOw
set Dd[Ad]=pOw
set Ad=Ad+1
set aOw=lOw
set qOw=iWw(Et[lOw])
set eOw=lOw
set Wi[aOw]=abw(qOw,ht[eOw],Ft[eOw],kt[eOw],bOw,yOw,"when calling new_Fx in FxEntity, line 25")
set Ad=Ad-1
set qOw=null
endfunction
function Pmu takes integer Emu,real Zmu,string Umu,string Imu returns nothing
set Dd[Ad]=Imu
set Ad=Ad+1
if Oe[Emu]==0 then
if Emu==0 then
call tsw("Nullpointer exception when calling FxEntity.FxEntity_FxEntity_setupFx","when calling error in ")
else
call tsw("Called FxEntity.FxEntity_FxEntity_setupFx on invalid object.","when calling error in ")
endif
endif
call nOw(Emu,Zmu,Umu,"when calling setupFx in FxEntity, line 24")
set Ad=Ad-1
endfunction
function mOw takes integer YOw,player GOw,real gOw,real hOw,real FOw,real kOw,real jOw,string xOw,string vOw returns nothing
set Dd[Ad]=vOw
set Ad=Ad+1
call puw(YOw,GOw,gOw,hOw,FOw,kOw,"when calling construct_Entity5 in FxEntity, line 12")
set Ei[YOw]=false
call Pmu(YOw,jOw,xOw,"when calling setupFx in FxEntity, line 14")
set Ad=Ad-1
endfunction
function wUw takes integer HZw,real JZw,real KZw,real LZw,real XZw,player CZw,real VZw,string BZw,string NZw returns nothing
local integer MZw
set Dd[Ad]=NZw
set Ad=Ad+1
call mOw(HZw,CZw,JZw,KZw,LZw,XZw,VZw,BZw,"when calling construct_FxEntity in Projectile, line 20")
set FO[HZw]=false
set kO[HZw]=false
set jO[HZw]=0.
set xO[HZw]=1.0
set vO[HZw]=0.
set mO[HZw]=0.
set QO[HZw]=0.
set MZw=HZw
set GO[MZw]=JZw
set gO[MZw]=KZw
set hO[MZw]=LZw
call oHu(HZw,VZw,"when calling setXYAngle in Projectile, line 23")
set It[HZw]=false
set mt[HZw]=0.
set Ad=Ad-1
endfunction
function Pvw takes integer jvw,real xvw,real vvw,real mvw,real Qvw,player Wvw,real Evw,string Zvw,integer Uvw,string Ivw returns nothing
set Dd[Ad]=Ivw
set Ad=Ad+1
call wUw(jvw,xvw,vvw,mvw,Qvw,Wvw,Evw,Zvw,"when calling construct_Projectile in PhysicsProjectile, line 12")
set Bo[jvw]=0.
set No[jvw]=0.9
call bmw(jvw)
call oHu(jvw,Evw,"when calling setXYAngle in PhysicsProjectile, line 14")
set Vo[jvw]=Uvw
set mt[jvw]=Co
set Ad=Ad-1
endfunction
function Dh takes real Ah returns real
return Cos(Ah)
endfunction
function Ph takes real Ih returns real
return Sin(Ih)
endfunction
function fuw takes integer nuw,string duw returns nothing
set Dd[Ad]=duw
set Ad=Ad+1
if not Vt[nuw]then
set Vt[nuw]=true
call qxu(nuw,"when calling removeFromInactive in DupletListModule, line 27")
call dxu(nuw,"when calling addToActive in DupletListModule, line 28")
endif
set Ad=Ad-1
endfunction
function Sxu takes integer txu,string ixu returns nothing
set Dd[Ad]=ixu
set Ad=Ad+1
if Oe[txu]==0 then
if txu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_activate","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_activate on invalid object.","when calling error in ")
endif
endif
call fuw(txu,"when calling activate in DupletListModule, line 24")
set Ad=Ad-1
endfunction
function uww takes integer Cww,real Vww,real Bww,real Nww,string Mww returns nothing
local integer www
set Dd[Ad]=Mww
set Ad=Ad+1
set www=Cww
set jt[www]=Vww
set xt[www]=Bww
set vt[www]=Nww
call Sxu(Cww,"when calling activate in Entity, line 125")
set Ad=Ad-1
endfunction
function vju takes integer hju,real Fju,real kju,real jju,string xju returns nothing
set Dd[Ad]=xju
set Ad=Ad+1
if Oe[hju]==0 then
if hju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_setVel","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_setVel on invalid object.","when calling error in ")
endif
endif
call uww(hju,Fju,kju,jju,"when calling setVel in Entity, line 123")
set Ad=Ad-1
endfunction
function gZw takes integer nZw,real dZw,string fZw returns nothing
local integer RZw
local integer TZw
local integer YZw
local real GZw
set Dd[Ad]=fZw
set Ad=Ad+1
set jO[nZw]=dZw
set YZw=nZw
set RZw=nZw
set GZw=Dh(YO[RZw])*dZw
set TZw=nZw
call vju(YZw,GZw,Ph(YO[TZw])*dZw,0.,"when calling setVel in Projectile, line 37")
set Ad=Ad-1
endfunction
function VDu takes integer LDu,real XDu,string CDu returns nothing
set Dd[Ad]=CDu
set Ad=Ad+1
if Oe[LDu]==0 then
if LDu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setSpeed","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setSpeed on invalid object.","when calling error in ")
endif
endif
call gZw(LDu,XDu,"when calling setSpeed in Projectile, line 35")
set Ad=Ad-1
endfunction
function Uh takes real Zh returns real
return Zh
endfunction
function qlu takes real llu,real blu,real ylu,real plu,real elu returns real
return Uh(Atan2(elu-blu,plu-llu))
endfunction
function BPw takes integer DPw,real HPw,real JPw,real KPw,real LPw,real XPw,string CPw returns nothing
local integer VPw
set Dd[Ad]=CPw
set Ad=Ad+1
call Pvw(DPw,HPw,JPw,KPw,16.,cw,0.,"Abilities\\Weapons\\DragonHawkMissile\\DragonHawkMissile.mdl",0,"when calling construct_PhysicsProjectile in Rocket, line 14")
call PingMinimapForForce(GetPlayersAll(),HPw,JPw,5.)
call oHu(DPw,qlu(HPw,JPw,KPw,LPw,XPw),"when calling setXYAngle in Rocket, line 17")
call VDu(DPw,GetRandomReal(5.,7.),"when calling setSpeed in Rocket, line 18")
set VPw=DPw
set vt[VPw]=GetRandomReal(15.,16.)
set Ad=Ad-1
endfunction
function DHu takes string PHu returns integer
local integer AHu
set Dd[Ad]=PHu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set AHu=oe
set Oe[AHu]=833
else
call tsw("Out of memory: Could not create Rocket.","when calling error in ")
set AHu=0
endif
else
set ce=ce-1
set AHu=Se[ce]
set Oe[AHu]=833
endif
set Ad=Ad-1
return AHu
endfunction
function APw takes real QPw,real WPw,real EPw,real ZPw,real UPw,string IPw returns integer
local integer PPw
set Dd[Ad]=IPw
set Ad=Ad+1
set PPw=DHu("when calling Rocket in Rocket, line 14")
call BPw(PPw,QPw,WPw,EPw,ZPw,UPw,"when calling construct_Rocket in Rocket, line 14")
set Ad=Ad-1
return PPw
endfunction
function fou takes real pou,real eou,real qou,real aou,real nou,real dou returns real
set of=pou+aou
set Of=eou+nou
set lf=qou+dou
return of
endfunction
function hPw takes integer RPw,unit TPw,real YPw,real GPw,string gPw returns nothing
set Dd[Ad]=gPw
set Ad=Ad+1
call APw(fou(Otu(TPw),wf,uf,0.,0.,90.),Of,lf,YPw,GPw,"when calling new_Rocket in Rocket, line 55")
set Ad=Ad-1
endfunction
function LTu takes integer ATu,unit DTu,real HTu,real JTu,string KTu returns nothing
set Dd[Ad]=KTu
set Ad=Ad+1
if pe[ATu]==0 then
if ATu==0 then
call tsw("Nullpointer exception when calling OnPointCast.ClosureEvents_OnPointCast_fireEx","when calling error in ")
else
call tsw("Called OnPointCast.ClosureEvents_OnPointCast_fireEx on invalid object.","when calling error in ")
endif
endif
call hPw(ATu,DTu,HTu,JTu,"when calling Rocket_closure_impl in ClosureEvents, line 88")
set Ad=Ad-1
endfunction
function Osw takes nothing returns real
set Hd=GetSpellTargetX()
set Jd=GetSpellTargetY()
return Hd
endfunction
function WL takes integer vL,unit mL,string QL returns nothing
set Dd[Ad]=QL
set Ad=Ad+1
call LTu(vL,mL,Osw(),Jd,"when calling fireEx in ClosureEvents, line 86")
set Ad=Ad-1
endfunction
function Agw takes integer Zgw,string Ugw returns integer
local integer Igw
local integer Pgw
set Dd[Ad]=Ugw
set Ad=Ad+1
set Igw=Nc[co[Zgw]]
set Pgw=0
if Igw!=co[Zgw]then
set Pgw=Bc[Igw]
call sAu(Zgw,Igw,"when calling removeEntry in LinkedList, line 87")
endif
set Ad=Ad-1
return Pgw
endfunction
function CIu takes integer KIu,string LIu returns integer
local integer XIu
set Dd[Ad]=LIu
set Ad=Ad+1
if yn[KIu]==0 then
if KIu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_pop","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_pop on invalid object.","when calling error in ")
endif
endif
set XIu=Agw(KIu,"when calling pop in LinkedList, line 82")
set Ad=Ad-1
return XIu
endfunction
function PLw takes sound ULw,integer ILw returns nothing
call SetSoundVolume(ULw,ILw)
endfunction
function QLw takes sound vLw,integer mLw returns nothing
call SetSoundChannel(vLw,mLw)
endfunction
function nLw takes integer qLw returns nothing
local integer aLw=qLw
set Ml[aLw]=0.
set wb[aLw]=0.
set ub[aLw]=0.
set tb[qLw]=null
set ib[qLw]=null
set Sb[qLw]=0
endfunction
function sLu takes string uLu returns integer
local integer rLu
set Dd[Ad]=uLu
set Ad=Ad+1
if Qn==0 then
if Wn<32768 then
set Wn=Wn+1
set rLu=Wn
set En[rLu]=874
else
call tsw("Out of memory: Could not create SoundInstance.","when calling error in ")
set rLu=0
endif
else
set Qn=Qn-1
set rLu=mn[Qn]
set En[rLu]=874
endif
set Ad=Ad-1
return rLu
endfunction
function eLw takes string yLw returns integer
local integer pLw
set Dd[Ad]=yLw
set Ad=Ad+1
set pLw=sLu("when calling SoundInstance in SoundUtils, line 25")
call nLw(pLw)
set Ad=Ad-1
return pLw
endfunction
function hLw takes sound GLw,integer gLw returns nothing
call SetSoundDuration(GLw,gLw)
endfunction
function oKw takes integer BJw,string NJw returns integer
local integer MJw
local sound wKw
local sound uKw
local sound rKw
local integer sKw
local sound tKw
local sound iKw
local sound SKw
local sound cKw
set Dd[Ad]=NJw
set Ad=Ad+1
if sPu(Hl[BJw],"when calling size in SoundUtils, line 55")>0 then
set MJw=CIu(Hl[BJw],"when calling pop in SoundUtils, line 56")
set wKw=rb[MJw]
call PLw(wKw,hl)
set uKw=wKw
call ZLw(uKw,Fl)
set rKw=uKw
call QLw(rKw,jl)
set Ad=Ad-1
set wKw=null
set uKw=null
set rKw=null
set tKw=null
set iKw=null
set SKw=null
set cKw=null
return MJw
else
set sKw=eLw("when calling new_SoundInstance in SoundUtils, line 61")
set rb[sKw]=CreateSound(Jl[BJw],Ll[BJw],Xl[BJw],Cl[BJw],Vl[BJw],Bl[BJw],Nl[BJw])
set sb[sKw]=BJw
set tKw=rb[sKw]
call hLw(tKw,Kl[BJw])
set iKw=tKw
call QLw(iKw,jl)
set SKw=iKw
call PLw(SKw,hl)
set cKw=SKw
call ZLw(cKw,Fl)
if Xl[BJw]then
call SetSoundDistances(rb[sKw],xl,vl)
call SetSoundDistanceCutoff(rb[sKw],ml)
call SetSoundConeAngles(rb[sKw],0.,0.,hl)
call SetSoundConeOrientation(rb[sKw],0.,0.,0.)
endif
set Ad=Ad-1
set wKw=null
set uKw=null
set rKw=null
set tKw=null
set iKw=null
set SKw=null
set cKw=null
return sKw
endif
endfunction
function hKu takes integer YKu,string GKu returns integer
local integer gKu
set Dd[Ad]=GKu
set Ad=Ad+1
if vn[YKu]==0 then
if YKu==0 then
call tsw("Nullpointer exception when calling SoundDefinition.SoundUtils_SoundDefinition_getSound","when calling error in ")
else
call tsw("Called SoundDefinition.SoundUtils_SoundDefinition_getSound on invalid object.","when calling error in ")
endif
endif
set gKu=oKw(YKu,"when calling getSound in SoundUtils, line 54")
set Ad=Ad-1
return gKu
endfunction
function rLw takes integer CKw,player VKw,integer BKw,string NKw returns integer
local integer MKw
local timer wLw
local timer uLw
set Dd[Ad]=NKw
set Ad=Ad+1
set Kl[CKw]=BKw
set MKw=hKu(CKw,"when calling getSound in SoundUtils, line 104")
set ib[MKw]=VKw
set wLw=b2w("when calling getTimer in SoundUtils, line 106")
call s2w(wLw,MKw,"when calling setData in SoundUtils, line 107")
set uLw=wLw
call j2w(uLw,0.,dg)
set Ad=Ad-1
set wLw=null
set uLw=null
return MKw
endfunction
function XKu takes integer DKu,player HKu,integer JKu,string KKu returns integer
local integer LKu
set Dd[Ad]=KKu
set Ad=Ad+1
if vn[DKu]==0 then
if DKu==0 then
call tsw("Nullpointer exception when calling SoundDefinition.SoundUtils_SoundDefinition_playForPlayer","when calling error in ")
else
call tsw("Called SoundDefinition.SoundUtils_SoundDefinition_playForPlayer on invalid object.","when calling error in ")
endif
endif
set LKu=rLw(DKu,HKu,JKu,"when calling playForPlayer in SoundUtils, line 102")
set Ad=Ad-1
return LKu
endfunction
function XKw takes integer HKw,player JKw,string KKw returns integer
local integer LKw
set Dd[Ad]=KKw
set Ad=Ad+1
set LKw=XKu(HKw,JKw,kl,"when calling playForPlayer in SoundUtils, line 98")
set Ad=Ad-1
return LKw
endfunction
function AKu takes integer ZKu,player UKu,string IKu returns integer
local integer PKu
set Dd[Ad]=IKu
set Ad=Ad+1
if vn[ZKu]==0 then
if ZKu==0 then
call tsw("Nullpointer exception when calling SoundDefinition.SoundUtils_SoundDefinition_playForPlayer","when calling error in ")
else
call tsw("Called SoundDefinition.SoundUtils_SoundDefinition_playForPlayer on invalid object.","when calling error in ")
endif
endif
set PKu=XKw(ZKu,UKu,"when calling playForPlayer in SoundUtils, line 97")
set Ad=Ad-1
return PKu
endfunction
function YM takes integer RM,string TM returns nothing
set Dd[Ad]=TM
set Ad=Ad+1
call J4u(0,RM,"when calling UnitEntity_onDestroy in Creep, line 38",0,null)
set Ad=Ad-1
endfunction
function kU takes integer hU,string FU returns nothing
set Dd[Ad]=FU
set Ad=Ad+1
call YM(hU,"when calling Creep_onDestroy in Boss, line 6")
set Ad=Ad-1
endfunction
function bZ takes integer OZ,string lZ returns nothing
set Dd[Ad]=lZ
set Ad=Ad+1
call kU(OZ,"when calling Boss_onDestroy in BossTwo, line 37")
set Ad=Ad-1
endfunction
function mfu takes integer xfu,string vfu returns nothing
set Dd[Ad]=vfu
set Ad=Ad+1
if Oe[xfu]==0 then
call tsw("Double free: object of type BossTwo","when calling error in ")
else
set Se[ce]=xfu
set ce=ce+1
set Oe[xfu]=0
endif
set Ad=Ad-1
endfunction
function AE takes integer IE,string PE returns nothing
set Dd[Ad]=PE
set Ad=Ad+1
call bZ(IE,"when calling BossTwo_onDestroy in BossTwo, line 37")
call mfu(IE,"when calling BossTwo in BossTwo, line 37")
set Ad=Ad-1
endfunction
function kmu takes integer hmu,string Fmu returns nothing
set Dd[Ad]=Fmu
set Ad=Ad+1
if Oe[hmu]==0 then
call tsw("Double free: object of type FlameMissile","when calling error in ")
else
set Se[ce]=hmu
set ce=ce+1
set Oe[hmu]=0
endif
set Ad=Ad-1
endfunction
function cWu takes integer iWu,string SWu returns nothing
set Dd[Ad]=SWu
set Ad=Ad+1
if Fa[iWu]==0 then
call tsw("Double free: object of type Fx","when calling error in ")
else
set Ga[ga]=iWu
set ga=ga+1
set Fa[iWu]=0
endif
set Ad=Ad-1
endfunction
function g2w takes timer G2w returns real
return TimerGetRemaining(G2w)
endfunction
function Z2 takes integer m2,unit Q2,real W2 returns nothing
local integer E2
set ns[m2]=0
set qs[m2]=Q2
set as[m2]=Hyw()+W2
if ds==0 then
set ds=m2
set fs=ds
else
set E2=ds
loop
exitwhen not(ns[E2]!=0 and as[E2]<as[m2])
set E2=ns[E2]
endloop
if as[E2]<as[m2]then
if E2==fs then
set ns[E2]=m2
set fs=m2
else
set ns[m2]=ns[E2]
set ns[E2]=m2
endif
elseif E2==ds then
set ds=m2
set ns[m2]=E2
elseif E2==fs then
set ns[E2]=m2
set fs=E2
else
set ns[m2]=ns[E2]
set ns[E2]=m2
endif
if g2w(es)>0. and W2<g2w(es) then
call j2w(es,W2,HG)
elseif g2w(es)<=0. then
call j2w(es,W2,JG)
endif
endif
endfunction
function rhu takes string whu returns integer
local integer uhu
set Dd[Ad]=whu
set Ad=Ad+1
if Wq==0 then
if Eq<32768 then
set Eq=Eq+1
set uhu=Eq
set Zq[uhu]=711
else
call tsw("Out of memory: Could not create DelayNode.","when calling error in ")
set uhu=0
endif
else
set Wq=Wq-1
set uhu=Qq[Wq]
set Zq[uhu]=711
endif
set Ad=Ad-1
return uhu
endfunction
function g2 takes unit R2,real T2,string Y2 returns integer
local integer G2
set Dd[Ad]=Y2
set Ad=Ad+1
set G2=rhu("when calling DelayNode in DummyRecycler, line 80")
call Z2(G2,R2,T2)
set Ad=Ad-1
return G2
endfunction
function b5 takes unit o5,real O5,string l5 returns nothing
set Dd[Ad]=l5
set Ad=Ad+1
call g2(o5,O5,"when calling new_DelayNode in DummyRecycler, line 43")
set Ad=Ad-1
endfunction
function xbw takes integer kbw,string jbw returns nothing
set Dd[Ad]=jbw
set Ad=Ad+1
if Ui[kbw]!=null then
call p5(Ui[kbw])
endif
call b5(Zi[kbw],1.,"when calling recycle in Fx, line 184")
set Ad=Ad-1
endfunction
function Flw takes integer glw,string hlw returns nothing
set Dd[Ad]=hlw
set Ad=Ad+1
call xbw(glw,"when calling Fx_onDestroy in Fx, line 180")
call cWu(glw,"when calling Fx in Fx, line 180")
set Ad=Ad-1
endfunction
function Bmu takes integer Cmu,string Vmu returns nothing
set Dd[Ad]=Vmu
set Ad=Ad+1
if Fa[Cmu]==0 then
if Cmu==0 then
call tsw("Nullpointer exception when calling Fx.destroyFx","when calling error in ")
else
call tsw("Called Fx.destroyFx on invalid object.","when calling error in ")
endif
endif
call Flw(Cmu,"when calling destroyFx in Fx, line 20")
set Ad=Ad-1
endfunction
function Niu takes unit Ciu,real Viu,real Biu returns nothing
call SetUnitPosition(Ciu,Viu,Biu)
endfunction
function Glw takes integer Tlw,string Ylw returns nothing
set Dd[Ad]=Ylw
set Ad=Ad+1
call Niu(Zi[Tlw],2147483647.,2147483647.)
call Bmu(Tlw,"when calling Fx in Fx, line 190")
set Ad=Ad-1
endfunction
function uWu takes integer MQu,string wWu returns nothing
set Dd[Ad]=wWu
set Ad=Ad+1
if Fa[MQu]==0 then
if MQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_hiddenDestroy","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_hiddenDestroy on invalid object.","when calling error in ")
endif
endif
call Glw(MQu,"when calling hiddenDestroy in Fx, line 188")
set Ad=Ad-1
endfunction
function EOw takes integer QOw,string WOw returns nothing
set Dd[Ad]=WOw
set Ad=Ad+1
if Ei[QOw]then
call uWu(Wi[QOw],"when calling hiddenDestroy in FxEntity, line 50")
else
call Bmu(Wi[QOw],"when calling Fx in FxEntity, line 52")
endif
call auw(QOw,"when calling Entity_onDestroy in FxEntity, line 8")
set Ad=Ad-1
endfunction
function sUw takes integer uUw,string rUw returns nothing
set Dd[Ad]=rUw
set Ad=Ad+1
call EOw(uUw,"when calling FxEntity_onDestroy in Projectile, line 4")
set Ad=Ad-1
endfunction
function pow takes integer bow,string yow returns nothing
set Dd[Ad]=yow
set Ad=Ad+1
call sUw(bow,"when calling Projectile_onDestroy in FlamethrowerTower, line 30")
set Ad=Ad-1
endfunction
function Acw takes integer Icw,string Pcw returns nothing
set Dd[Ad]=Pcw
set Ad=Ad+1
call pow(Icw,"when calling FlameMissile_onDestroy in FlamethrowerTower, line 30")
call kmu(Icw,"when calling FlameMissile in FlamethrowerTower, line 30")
set Ad=Ad-1
endfunction
function BLu takes integer CLu,string VLu returns nothing
set Dd[Ad]=VLu
set Ad=Ad+1
if Oe[CLu]==0 then
call tsw("Double free: object of type SpecialTwo","when calling error in ")
else
set Se[ce]=CLu
set ce=ce+1
set Oe[CLu]=0
endif
set Ad=Ad-1
endfunction
function nNw takes integer qNw,string aNw returns nothing
set Dd[Ad]=aNw
set Ad=Ad+1
call YM(qNw,"when calling Creep_onDestroy in Special, line 13")
set Ad=Ad-1
endfunction
function NBw takes integer VBw,string BBw returns nothing
set Dd[Ad]=BBw
set Ad=Ad+1
call nNw(VBw,"when calling Special_onDestroy in SpecialTwo, line 6")
set Ad=Ad-1
endfunction
function BVw takes integer CVw,string VVw returns nothing
set Dd[Ad]=VVw
set Ad=Ad+1
call NBw(CVw,"when calling SpecialTwo_onDestroy in SpecialTwo, line 6")
call BLu(CVw,"when calling SpecialTwo in SpecialTwo, line 6")
set Ad=Ad-1
endfunction
function ULu takes integer ELu,string ZLu returns nothing
set Dd[Ad]=ZLu
set Ad=Ad+1
if Oe[ELu]==0 then
call tsw("Double free: object of type SpecialOne","when calling error in ")
else
set Se[ce]=ELu
set ce=ce+1
set Oe[ELu]=0
endif
set Ad=Ad-1
endfunction
function dVw takes integer aVw,string nVw returns nothing
set Dd[Ad]=nVw
set Ad=Ad+1
call nNw(aVw,"when calling Special_onDestroy in SpecialOne, line 5")
set Ad=Ad-1
endfunction
function CCw takes integer LCw,string XCw returns nothing
set Dd[Ad]=XCw
set Ad=Ad+1
call dVw(LCw,"when calling SpecialOne_onDestroy in SpecialOne, line 5")
call ULu(LCw,"when calling SpecialOne in SpecialOne, line 5")
set Ad=Ad-1
endfunction
function aWu takes integer eWu,string qWu returns nothing
set Dd[Ad]=qWu
set Ad=Ad+1
if Oe[eWu]==0 then
call tsw("Double free: object of type Treasure","when calling error in ")
else
set Se[ce]=eWu
set ce=ce+1
set Oe[eWu]=0
endif
set Ad=Ad-1
endfunction
function uyw takes integer Mbw,string wyw returns nothing
set Dd[Ad]=wyw
set Ad=Ad+1
call J4u(0,Mbw,"when calling UnitEntity_onDestroy in GameConditions, line 18",0,null)
set Ad=Ad-1
endfunction
function Hbw takes integer Abw,string Dbw returns nothing
set Dd[Ad]=Dbw
set Ad=Ad+1
call uyw(Abw,"when calling Treasure_onDestroy in GameConditions, line 18")
call aWu(Abw,"when calling Treasure in GameConditions, line 18")
set Ad=Ad-1
endfunction
function Yfu takes integer Rfu,string Tfu returns nothing
set Dd[Ad]=Tfu
set Ad=Ad+1
if Oe[Rfu]==0 then
call tsw("Double free: object of type BossThree","when calling error in ")
else
set Se[ce]=Rfu
set ce=ce+1
set Oe[Rfu]=0
endif
set Ad=Ad-1
endfunction
function nE takes integer qE,string aE returns nothing
set Dd[Ad]=aE
set Ad=Ad+1
call kU(qE,"when calling Boss_onDestroy in BossThree, line 30")
set Ad=Ad-1
endfunction
function JW takes integer DW,string HW returns nothing
set Dd[Ad]=HW
set Ad=Ad+1
call nE(DW,"when calling BossThree_onDestroy in BossThree, line 30")
call Yfu(DW,"when calling BossThree in BossThree, line 30")
set Ad=Ad-1
endfunction
function Dfu takes integer Pfu,string Afu returns nothing
set Dd[Ad]=Afu
set Ad=Ad+1
if Oe[Pfu]==0 then
call tsw("Double free: object of type Tentacle","when calling error in ")
else
set Se[ce]=Pfu
set ce=ce+1
set Oe[Pfu]=0
endif
set Ad=Ad-1
endfunction
function SU takes integer tU,string iU returns nothing
set Dd[Ad]=iU
set Ad=Ad+1
call YM(tU,"when calling Creep_onDestroy in BossTwo, line 31")
set Ad=Ad-1
endfunction
function JZ takes integer DZ,string HZ returns nothing
set Dd[Ad]=HZ
set Ad=Ad+1
call SU(DZ,"when calling Tentacle_onDestroy in BossTwo, line 31")
call Dfu(DZ,"when calling Tentacle in BossTwo, line 31")
set Ad=Ad-1
endfunction
function KHu takes integer HHu,string JHu returns nothing
set Dd[Ad]=JHu
set Ad=Ad+1
if Oe[HHu]==0 then
call tsw("Double free: object of type Rocket","when calling error in ")
else
set Se[ce]=HHu
set ce=ce+1
set Oe[HHu]=0
endif
set Ad=Ad-1
endfunction
function KSu takes unit ASu,real DSu,real HSu,real JSu returns nothing
call SetUnitX(ASu,DSu)
call SetUnitY(ASu,HSu)
call SetUnitFlyHeight(ASu,JSu-xcu(DSu,HSu,JSu),0.)
endfunction
function NCu takes integer VCu,string BCu returns nothing
set Dd[Ad]=BCu
set Ad=Ad+1
if Oe[VCu]==0 then
call tsw("Double free: object of type TowerBlockadeMissile","when calling error in ")
else
set Se[ce]=VCu
set ce=ce+1
set Oe[VCu]=0
endif
set Ad=Ad-1
endfunction
function V5w takes integer X5w,string C5w returns nothing
set Dd[Ad]=C5w
set Ad=Ad+1
call sUw(X5w,"when calling Projectile_onDestroy in TowerBlockade, line 14")
set Ad=Ad-1
endfunction
function L5w takes integer J5w,string K5w returns nothing
set Dd[Ad]=K5w
set Ad=Ad+1
call V5w(J5w,"when calling TowerBlockadeMissile_onDestroy in TowerBlockade, line 14")
call NCu(J5w,"when calling TowerBlockadeMissile in TowerBlockade, line 14")
set Ad=Ad-1
endfunction
function V8w takes integer X8w,string C8w returns nothing
set Dd[Ad]=C8w
set Ad=Ad+1
call J4u(0,X8w,"when calling UnitEntity_onDestroy in TrooperTower, line 14",0,null)
set Ad=Ad-1
endfunction
function oBu takes integer SBu,string cBu returns nothing
set Dd[Ad]=cBu
set Ad=Ad+1
if Oe[SBu]==0 then
call tsw("Double free: object of type TroopGround","when calling error in ")
else
set Se[ce]=SBu
set ce=ce+1
set Oe[SBu]=0
endif
set Ad=Ad-1
endfunction
function L8w takes integer J8w,string K8w returns nothing
set Dd[Ad]=K8w
set Ad=Ad+1
call V8w(J8w,"when calling TroopGround_onDestroy in TrooperTower, line 14")
call oBu(J8w,"when calling TroopGround in TrooperTower, line 14")
set Ad=Ad-1
endfunction
function Fnw takes integer gnw,string hnw returns nothing
set Dd[Ad]=hnw
set Ad=Ad+1
call sUw(gnw,"when calling Projectile_onDestroy in HealbackTower, line 97")
set Ad=Ad-1
endfunction
function SZu takes integer tZu,string iZu returns nothing
set Dd[Ad]=iZu
set Ad=Ad+1
if Oe[tZu]==0 then
call tsw("Double free: object of type HealbackMissile","when calling error in ")
else
set Se[ce]=tZu
set ce=ce+1
set Oe[tZu]=0
endif
set Ad=Ad-1
endfunction
function Law takes integer Jaw,string Kaw returns nothing
set Dd[Ad]=Kaw
set Ad=Ad+1
call Fnw(Jaw,"when calling HealbackMissile_onDestroy in HealbackTower, line 97")
call SZu(Jaw,"when calling HealbackMissile in HealbackTower, line 97")
set Ad=Ad-1
endfunction
function a9u takes integer e9u,string q9u returns nothing
set Dd[Ad]=q9u
set Ad=Ad+1
if not IsUnitHidden(Nt[e9u]) then
call SetUnitExploded(Nt[e9u],true)
endif
call Sww(Nt[e9u],0)
call KillUnit(Nt[e9u])
call biu(Nt[e9u])
call J4u(0,e9u,"when calling UnitEntity_onDestroy in TrooperTower, line 20",0,null)
set Ad=Ad-1
endfunction
function rBu takes integer wBu,string uBu returns nothing
set Dd[Ad]=uBu
set Ad=Ad+1
if Oe[wBu]==0 then
call tsw("Double free: object of type Troop","when calling error in ")
else
set Se[ce]=wBu
set ce=ce+1
set Oe[wBu]=0
endif
set Ad=Ad-1
endfunction
function M8w takes integer B8w,string N8w returns nothing
set Dd[Ad]=N8w
set Ad=Ad+1
call a9u(B8w,"when calling Troop_onDestroy in TrooperTower, line 28")
call rBu(B8w,"when calling Troop in TrooperTower, line 28")
set Ad=Ad-1
endfunction
function NHu takes integer VHu,string BHu returns nothing
set Dd[Ad]=BHu
set Ad=Ad+1
if Oe[VHu]==0 then
call tsw("Double free: object of type Shrapnell","when calling error in ")
else
set Se[ce]=VHu
set ce=ce+1
set Oe[VHu]=0
endif
set Ad=Ad-1
endfunction
function ODu takes integer cDu,string oDu returns nothing
set Dd[Ad]=oDu
set Ad=Ad+1
if Oe[cDu]==0 then
call tsw("Double free: object of type PhysicsProjectile","when calling error in ")
else
set Se[ce]=cDu
set ce=ce+1
set Oe[cDu]=0
endif
set Ad=Ad-1
endfunction
function Xmu takes integer Kmu,string Lmu returns nothing
set Dd[Ad]=Lmu
set Ad=Ad+1
if Oe[Kmu]==0 then
call tsw("Double free: object of type FxEntity","when calling error in ")
else
set Se[ce]=Kmu
set ce=ce+1
set Oe[Kmu]=0
endif
set Ad=Ad-1
endfunction
function OOw takes integer cOw,string oOw returns nothing
set Dd[Ad]=oOw
set Ad=Ad+1
call EOw(cOw,"when calling FxEntity_onDestroy in FxEntity, line 48")
call Xmu(cOw,"when calling FxEntity in FxEntity, line 48")
set Ad=Ad-1
endfunction
function Kfu takes integer Hfu,string Jfu returns nothing
set Dd[Ad]=Jfu
set Ad=Ad+1
if Oe[Hfu]==0 then
call tsw("Double free: object of type Boss","when calling error in ")
else
set Se[ce]=Hfu
set ce=ce+1
set Oe[Hfu]=0
endif
set Ad=Ad-1
endfunction
function OU takes integer cU,string oU returns nothing
set Dd[Ad]=oU
set Ad=Ad+1
call kU(cU,"when calling Boss_onDestroy in Boss, line 6")
call Kfu(cU,"when calling Boss in Boss, line 6")
set Ad=Ad-1
endfunction
function xww takes integer kww returns real
local integer jww=kww
set rT=ht[jww]
set sT=Ft[jww]
set tT=kt[jww]
return rT
endfunction
function Oju takes integer Nku,string Mku returns real
local real wju
local real uju
local real rju
local real sju
local real tju
local real iju
local real Sju
local real cju
local real oju
set Dd[Ad]=Mku
set Ad=Ad+1
if Oe[Nku]==0 then
if Nku==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_getPos","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_getPos on invalid object.","when calling error in ")
endif
endif
if Oe[Nku]<=838 then
set sju=xww(Nku)
set tju=sT
set iju=tT
set wju=sju
set uju=tju
set rju=iju
else
set Sju=prw(Nku)
set cju=ST
set oju=cT
set wju=Sju
set uju=cju
set rju=oju
endif
set Ad=Ad-1
set bf=wju
set yf=uju
set pf=rju
return bf
endfunction
function PSu takes unit mSu,real QSu,real WSu,real ESu returns nothing
local unit ZSu=mSu
local unit USu
local unit ISu
call TSu(ZSu,QSu)
set USu=ZSu
call vSu(USu,WSu)
set ISu=USu
call Nru(ISu,ESu,0.)
set ZSu=null
set USu=null
set ISu=null
endfunction
function dLu takes integer aLu,string nLu returns nothing
set Dd[Ad]=nLu
set Ad=Ad+1
if Oe[aLu]==0 then
call tsw("Double free: object of type SpecialFive","when calling error in ")
else
set Se[ce]=aLu
set ce=ce+1
set Oe[aLu]=0
endif
set Ad=Ad-1
endfunction
function nCw takes integer qCw,string aCw returns nothing
set Dd[Ad]=aCw
set Ad=Ad+1
call nNw(qCw,"when calling Special_onDestroy in SpecialFive, line 10")
set Ad=Ad-1
endfunction
function PXw takes integer UXw,string IXw returns nothing
set Dd[Ad]=IXw
set Ad=Ad+1
call nCw(UXw,"when calling SpecialFive_onDestroy in SpecialFive, line 10")
call dLu(UXw,"when calling SpecialFive in SpecialFive, line 10")
set Ad=Ad-1
endfunction
function KCw takes integer HCw,string JCw returns nothing
set Dd[Ad]=JCw
set Ad=Ad+1
call nNw(HCw,"when calling Special_onDestroy in SpecialFour, line 5")
set Ad=Ad-1
endfunction
function vLu takes integer jLu,string xLu returns nothing
set Dd[Ad]=xLu
set Ad=Ad+1
if Oe[jLu]==0 then
call tsw("Double free: object of type SpecialFour","when calling error in ")
else
set Se[ce]=jLu
set ce=ce+1
set Oe[jLu]=0
endif
set Ad=Ad-1
endfunction
function RCw takes integer dCw,string fCw returns nothing
set Dd[Ad]=fCw
set Ad=Ad+1
call KCw(dCw,"when calling SpecialFour_onDestroy in SpecialFour, line 5")
call vLu(dCw,"when calling SpecialFour in SpecialFour, line 5")
set Ad=Ad-1
endfunction
function RGu takes string dGu returns integer
local integer fGu
set Dd[Ad]=dGu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set fGu=ae
set ne[fGu]=668
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set fGu=0
endif
else
set qe=qe-1
set fGu=ee[qe]
set ne[fGu]=668
endif
set Ad=Ad-1
return fGu
endfunction
function Bpw takes group Cpw returns unit
local unit Vpw=FirstOfGroup(Cpw)
call GroupRemoveUnit(Cpw,Vpw)
set Pg=Vpw
set Vpw=null
return Pg
endfunction
function Ch takes unit Xh returns boolean
return (not IsUnitType(Xh,UNIT_TYPE_DEAD))and(not IsUnitType(Xh,UNIT_TYPE_MAGIC_IMMUNE)) and(not IsUnitType(Xh,UNIT_TYPE_STRUCTURE))
endfunction
function TOw takes integer dOw,string fOw returns unit
local unit ROw
set Dd[Ad]=fOw
set Ad=Ad+1
set ROw=RQu(Wi[dOw],"when calling getDummy in FxEntity, line 38")
set Ad=Ad-1
set Ug=ROw
set ROw=null
return Ug
endfunction
function Jmu takes integer Amu,string Dmu returns unit
local unit Hmu
set Dd[Ad]=Dmu
set Ad=Ad+1
if Oe[Amu]==0 then
if Amu==0 then
call tsw("Nullpointer exception when calling FxEntity.FxEntity_FxEntity_getDummy","when calling error in ")
else
call tsw("Called FxEntity.FxEntity_FxEntity_getDummy on invalid object.","when calling error in ")
endif
endif
set Hmu=TOw(Amu,"when calling getDummy in FxEntity, line 37")
set Ad=Ad-1
set Lg=Hmu
set Hmu=null
return Lg
endfunction
function Jpw takes group Hpw returns boolean
return FirstOfGroup(Hpw)!=null
endfunction
function msu takes unit ksu,unit jsu,real xsu,attacktype vsu returns nothing
call UnitDamageTarget(ksu,jsu,xsu,false,false,vsu,DAMAGE_TYPE_UNIVERSAL,WEAPON_TYPE_WHOKNOWS)
endfunction
function JF takes integer jF,string xF returns nothing
local unit vF
local group mF
local integer QF
local real WF
local real EF
local integer ZF
local real UF
local real IF
local integer PF
local group AF
local real DF
local string HF
set Dd[Ad]=xF
set Ad=Ad+1
set AF=OS
set QF=jF
set EF=ht[QF]
set WF=EF
set DF=WF
set ZF=jF
set IF=Ft[ZF]
set UF=IF
call GroupEnumUnitsInRange(AF,DF,UF,Qt[jF],null)
set mF=OS
loop
exitwhen not Jpw(mF)
set vF=Bpw(mF)
if Ch(vF) and IsUnitEnemy(vF,Et[jF]) then
call msu(Jmu(jF,"when calling getDummy in ArtilleryTower, line 62"),vF,M[jF],ATTACK_TYPE_SIEGE)
endif
endloop
set HF=v
set PF=jF
call p5(G5(HF,ht[PF],Ft[PF],kt[PF]))
call sUw(jF,"when calling Projectile_onDestroy in ArtilleryTower, line 41")
set Ad=Ad-1
set vF=null
set mF=null
set AF=null
endfunction
function sau takes integer uau,string rau returns nothing
set Dd[Ad]=rau
set Ad=Ad+1
if Oe[uau]==0 then
call tsw("Double free: object of type ArtilleryMissile","when calling error in ")
else
set Se[ce]=uau
set ce=ce+1
set Oe[uau]=0
endif
set Ad=Ad-1
endfunction
function SF takes integer tF,string iF returns nothing
set Dd[Ad]=iF
set Ad=Ad+1
call JF(tF,"when calling ArtilleryMissile_onDestroy in ArtilleryTower, line 58")
call sau(tF,"when calling ArtilleryMissile in ArtilleryTower, line 58")
set Ad=Ad-1
endfunction
function Ssu takes player Mru,integer wsu,real usu,real rsu,real ssu,real tsu returns unit
local unit isu=CreateUnit(Mru,wsu,usu,rsu,Fh(tsu))
call Nru(isu,ssu-xcu(usu,rsu,ssu),0.)
set Jg=isu
set isu=null
return Jg
endfunction
function JLu takes integer DLu,string HLu returns nothing
set Dd[Ad]=HLu
set Ad=Ad+1
if Oe[DLu]==0 then
call tsw("Double free: object of type SpecialThree","when calling error in ")
else
set Se[ce]=DLu
set ce=ce+1
set Oe[DLu]=0
endif
set Ad=Ad-1
endfunction
function LVw takes integer JVw,string KVw returns nothing
set Dd[Ad]=KVw
set Ad=Ad+1
call nNw(JVw,"when calling Special_onDestroy in SpecialThree, line 5")
set Ad=Ad-1
endfunction
function TVw takes integer fVw,string RVw returns nothing
set Dd[Ad]=RVw
set Ad=Ad+1
call LVw(fVw,"when calling SpecialThree_onDestroy in SpecialThree, line 5")
call JLu(fVw,"when calling SpecialThree in SpecialThree, line 5")
set Ad=Ad-1
endfunction
function bku takes integer Oku,string lku returns nothing
set Dd[Ad]=lku
set Ad=Ad+1
if Oe[Oku]==0 then
call tsw("Double free: object of type EndBoss","when calling error in ")
else
set Se[ce]=Oku
set ce=ce+1
set Oe[Oku]=0
endif
set Ad=Ad-1
endfunction
function a2w takes timer q2w returns nothing
call DestroyTimer(q2w)
endfunction
function i0w takes integer s0w,string t0w returns nothing
set Dd[Ad]=t0w
set Ad=Ad+1
call xIu(dt[s0w],"when calling LinkedList in EndBoss, line 105")
call a2w(nt[s0w])
call kU(s0w,"when calling Boss_onDestroy in EndBoss, line 18")
set Ad=Ad-1
endfunction
function U8 takes integer E8,string Z8 returns nothing
set Dd[Ad]=Z8
set Ad=Ad+1
call i0w(E8,"when calling EndBoss_onDestroy in EndBoss, line 104")
call bku(E8,"when calling EndBoss in EndBoss, line 104")
set Ad=Ad-1
endfunction
function ANw takes integer INw,string PNw returns nothing
set Dd[Ad]=PNw
set Ad=Ad+1
call sUw(INw,"when calling Projectile_onDestroy in SphereTower, line 55")
set Ad=Ad-1
endfunction
function yXu takes integer lXu,string bXu returns nothing
set Dd[Ad]=bXu
set Ad=Ad+1
if Oe[lXu]==0 then
call tsw("Double free: object of type Sphere","when calling error in ")
else
set Se[ce]=lXu
set ce=ce+1
set Oe[lXu]=0
endif
set Ad=Ad-1
endfunction
function UNw takes integer ENw,string ZNw returns nothing
set Dd[Ad]=ZNw
set Ad=Ad+1
call ANw(ENw,"when calling Sphere_onDestroy in SphereTower, line 55")
call yXu(ENw,"when calling Sphere in SphereTower, line 55")
set Ad=Ad-1
endfunction
function fXw takes integer nXw,string dXw returns nothing
set Dd[Ad]=dXw
set Ad=Ad+1
call nNw(nXw,"when calling Special_onDestroy in SpecialFive, line 5")
set Ad=Ad-1
endfunction
function yLu takes integer lLu,string bLu returns nothing
set Dd[Ad]=bLu
set Ad=Ad+1
if Oe[lLu]==0 then
call tsw("Double free: object of type Spawn","when calling error in ")
else
set Se[ce]=lLu
set ce=ce+1
set Oe[lLu]=0
endif
set Ad=Ad-1
endfunction
function VLw takes integer XLw,string CLw returns nothing
set Dd[Ad]=CLw
set Ad=Ad+1
call fXw(XLw,"when calling Spawn_onDestroy in SpecialFive, line 5")
call yLu(XLw,"when calling Spawn in SpecialFive, line 5")
set Ad=Ad-1
endfunction
function bGu takes integer OGu,string lGu returns nothing
set Dd[Ad]=lGu
set Ad=Ad+1
if Oe[OGu]==0 then
call tsw("Double free: object of type Creep","when calling error in ")
else
set Se[ce]=OGu
set ce=ce+1
set Oe[OGu]=0
endif
set Ad=Ad-1
endfunction
function VN takes integer XN,string CN returns nothing
set Dd[Ad]=CN
set Ad=Ad+1
call YM(XN,"when calling Creep_onDestroy in Creep, line 38")
call bGu(XN,"when calling Creep in Creep, line 38")
set Ad=Ad-1
endfunction
function UW takes integer EW,string ZW returns nothing
set Dd[Ad]=ZW
set Ad=Ad+1
call kU(EW,"when calling Boss_onDestroy in BossOne, line 5")
set Ad=Ad-1
endfunction
function pfu takes integer bfu,string yfu returns nothing
set Dd[Ad]=yfu
set Ad=Ad+1
if Oe[bfu]==0 then
call tsw("Double free: object of type BossOne","when calling error in ")
else
set Se[ce]=bfu
set ce=ce+1
set Oe[bfu]=0
endif
set Ad=Ad-1
endfunction
function VQ takes integer XQ,string CQ returns nothing
set Dd[Ad]=CQ
set Ad=Ad+1
call UW(XQ,"when calling BossOne_onDestroy in BossOne, line 5")
call pfu(XQ,"when calling BossOne in BossOne, line 5")
set Ad=Ad-1
endfunction
function w7w takes integer N6w,string M6w returns nothing
set Dd[Ad]=M6w
set Ad=Ad+1
call J4u(0,N6w,"when calling UnitEntity_onDestroy in Tower, line 20",0,null)
set Ad=Ad-1
endfunction
function B4w takes integer C4w,string V4w returns nothing
set Dd[Ad]=V4w
set Ad=Ad+1
call w7w(C4w,"when calling Tower_onDestroy in ThermoTower, line 8")
set Ad=Ad-1
endfunction
function gCu takes integer YCu,string GCu returns nothing
set Dd[Ad]=GCu
set Ad=Ad+1
if Oe[YCu]==0 then
call tsw("Double free: object of type ThermoTower","when calling error in ")
else
set Se[ce]=YCu
set ce=ce+1
set Oe[YCu]=0
endif
set Ad=Ad-1
endfunction
function W4w takes integer m4w,string Q4w returns nothing
set Dd[Ad]=Q4w
set Ad=Ad+1
call B4w(m4w,"when calling ThermoTower_onDestroy in ThermoTower, line 8")
call gCu(m4w,"when calling ThermoTower in ThermoTower, line 8")
set Ad=Ad-1
endfunction
function Axw takes integer Pxw returns nothing
endfunction
function UAu takes integer EAu,string ZAu returns nothing
set Dd[Ad]=ZAu
set Ad=Ad+1
if He[EAu]==0 then
call tsw("Double free: object of type OnExpireEvent","when calling error in ")
else
set Pe[Ae]=EAu
set Ae=Ae+1
set He[EAu]=0
endif
set Ad=Ad-1
endfunction
function Jxw takes integer Dxw,string Hxw returns nothing
set Dd[Ad]=Hxw
set Ad=Ad+1
call Axw(Dxw)
call UAu(Dxw,"when calling OnExpireEvent in PhysicsProjectile, line 5")
set Ad=Ad-1
endfunction
function WAu takes integer mAu,string QAu returns nothing
set Dd[Ad]=QAu
set Ad=Ad+1
if He[mAu]==0 then
if mAu==0 then
call tsw("Nullpointer exception when calling OnExpireEvent.destroyOnExpireEvent","when calling error in ")
else
call tsw("Called OnExpireEvent.destroyOnExpireEvent on invalid object.","when calling error in ")
endif
endif
call Jxw(mAu,"when calling destroyOnExpireEvent in PhysicsProjectile, line 5")
set Ad=Ad-1
endfunction
function Ik takes integer Zk,string Uk returns nothing
set Dd[Ad]=Uk
set Ad=Ad+1
call w7w(Zk,"when calling Tower_onDestroy in ArtilleryTower, line 11")
set Ad=Ad-1
endfunction
function yau takes integer lau,string bau returns nothing
set Dd[Ad]=bau
set Ad=Ad+1
if Oe[lau]==0 then
call tsw("Double free: object of type ArtilleryTower","when calling error in ")
else
set Se[ce]=lau
set ce=ce+1
set Oe[lau]=0
endif
set Ad=Ad-1
endfunction
function XF takes integer KF,string LF returns nothing
set Dd[Ad]=LF
set Ad=Ad+1
call Ik(KF,"when calling ArtilleryTower_onDestroy in ArtilleryTower, line 11")
call yau(KF,"when calling ArtilleryTower in ArtilleryTower, line 11")
set Ad=Ad-1
endfunction
function svu takes integer uvu,string rvu returns nothing
set Dd[Ad]=rvu
set Ad=Ad+1
if Oe[uvu]==0 then
call tsw("Double free: object of type UnitEntity","when calling error in ")
else
set Se[ce]=uvu
set ce=ce+1
set Oe[uvu]=0
endif
set Ad=Ad-1
endfunction
function Zrw takes integer Wrw,string Erw returns nothing
set Dd[Ad]=Erw
set Ad=Ad+1
call J4u(0,Wrw,"when calling UnitEntity_onDestroy in Entity, line 262",0,null)
call svu(Wrw,"when calling UnitEntity in Entity, line 262")
set Ad=Ad-1
endfunction
function PH takes integer UH,string IH returns nothing
set Dd[Ad]=IH
set Ad=Ad+1
set SO[wO[kQw(Et[UH])]]=0
call J4u(0,UH,"when calling UnitEntity_onDestroy in Builder, line 11",0,null)
set Ad=Ad-1
endfunction
function yTu takes integer lTu,string bTu returns nothing
set Dd[Ad]=bTu
set Ad=Ad+1
if Oe[lTu]==0 then
call tsw("Double free: object of type Builder","when calling error in ")
else
set Se[ce]=lTu
set ce=ce+1
set Oe[lTu]=0
endif
set Ad=Ad-1
endfunction
function aH takes integer eH,string qH returns nothing
set Dd[Ad]=qH
set Ad=Ad+1
call PH(eH,"when calling Builder_onDestroy in Builder, line 31")
call yTu(eH,"when calling Builder in Builder, line 31")
set Ad=Ad-1
endfunction
function Eow takes integer Qow,string Wow returns nothing
set Dd[Ad]=Wow
set Ad=Ad+1
call w7w(Qow,"when calling Tower_onDestroy in FlamethrowerTower, line 15")
set Ad=Ad-1
endfunction
function Wmu takes integer mmu,string Qmu returns nothing
set Dd[Ad]=Qmu
set Ad=Ad+1
if Oe[mmu]==0 then
call tsw("Double free: object of type FlamethrowerTower","when calling error in ")
else
set Se[ce]=mmu
set ce=ce+1
set Oe[mmu]=0
endif
set Ad=Ad-1
endfunction
function aow takes integer eow,string qow returns nothing
set Dd[Ad]=qow
set Ad=Ad+1
call Eow(eow,"when calling FlamethrowerTower_onDestroy in FlamethrowerTower, line 15")
call Wmu(eow,"when calling FlamethrowerTower in FlamethrowerTower, line 15")
set Ad=Ad-1
endfunction
function OUw takes real cUw returns integer
local integer oUw
if cUw>0. then
set oUw=bUw(cUw+.5)
else
set oUw=bUw(cUw-.5)
endif
return oUw
endfunction
function bFw takes nothing returns boolean
set ao=ao+1
if ao>=no then
set ao=0
set no=no+4+GetRandomInt(-1,2)+OUw(do/4.)
if uO then
set no=no+2
endif
set do=do+1
return true
endif
return false
endfunction
function Kdu takes integer Hdu,string Jdu returns nothing
set Dd[Ad]=Jdu
set Ad=Ad+1
if Oe[Hdu]==0 then
call tsw("Double free: object of type BossFive","when calling error in ")
else
set Se[ce]=Hdu
set ce=ce+1
set Oe[Hdu]=0
endif
set Ad=Ad-1
endfunction
function Xm takes integer Km,string Lm returns nothing
set Dd[Ad]=Lm
set Ad=Ad+1
call kU(Km,"when calling Boss_onDestroy in BossFive, line 5")
set Ad=Ad-1
endfunction
function bm takes integer Om,string lm returns nothing
set Dd[Ad]=lm
set Ad=Ad+1
call Xm(Om,"when calling BossFive_onDestroy in BossFive, line 5")
call Kdu(Om,"when calling BossFive in BossFive, line 5")
set Ad=Ad-1
endfunction
function cL takes integer SL returns nothing
set Gu[SL]=0
set gu[SL]=0
set hu[SL]=0
endfunction
function CHu takes string LHu returns integer
local integer XHu
set Dd[Ad]=LHu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set XHu=oe
set Oe[XHu]=834
else
call tsw("Out of memory: Could not create Shrapnell.","when calling error in ")
set XHu=0
endif
else
set ce=ce-1
set XHu=Se[ce]
set Oe[XHu]=834
endif
set Ad=Ad-1
return XHu
endfunction
function aZw takes integer eZw,real qZw returns nothing
set QO[eZw]=qZw
set FO[eZw]=true
endfunction
function KDu takes integer DDu,real HDu,string JDu returns nothing
set Dd[Ad]=JDu
set Ad=Ad+1
if Oe[DDu]==0 then
if DDu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setTimed","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setTimed on invalid object.","when calling error in ")
endif
endif
call aZw(DDu,HDu)
set Ad=Ad-1
endfunction
function OSu takes unit cSu,real oSu returns nothing
call SetUnitScale(cSu,oSu,oSu,oSu)
endfunction
function COw takes integer LOw,real XOw returns nothing
call OSu(Zi[LOw],XOw)
endfunction
function iQu takes integer rQu,real sQu,string tQu returns nothing
set Dd[Ad]=tQu
set Ad=Ad+1
if Fa[rQu]==0 then
if rQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setScale","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setScale on invalid object.","when calling error in ")
endif
endif
call COw(rQu,sQu)
set Ad=Ad-1
endfunction
function gB takes unit fB,integer RB,integer TB,integer YB,integer GB returns nothing
call SetUnitVertexColor(fB,RB,TB,YB,GB)
endfunction
function ilw takes integer MOw,integer wlw,integer ulw,integer rlw,integer slw returns nothing
local integer tlw=MOw
set Ii[tlw]=wlw
set Pi[tlw]=ulw
set Ai[tlw]=rlw
set Di[tlw]=slw
call gB(Zi[MOw],wlw,ulw,rlw,slw)
endfunction
function kQu takes integer TQu,integer YQu,integer GQu,integer gQu,integer hQu,string FQu returns nothing
set Dd[Ad]=FQu
set Ad=Ad+1
if Fa[TQu]==0 then
if TQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setColor","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setColor on invalid object.","when calling error in ")
endif
endif
call ilw(TQu,YQu,GQu,gQu,hQu)
set Ad=Ad-1
endfunction
function vh takes real xh returns real
return xh*X
endfunction
function TAw takes integer qAw,real aAw,real nAw,real dAw,string fAw returns nothing
local integer RAw
set Dd[Ad]=fAw
set Ad=Ad+1
call Pvw(qAw,aAw,nAw,dAw,16.,cw,0.,"Abilities\\Weapons\\DruidoftheTalonMissile\\DruidoftheTalonMissile.mdl",0,"when calling construct_PhysicsProjectile in Rocket, line 36")
call oHu(qAw,vh(GetRandomReal(0.,360.)),"when calling setXYAngle in Rocket, line 38")
call VDu(qAw,GetRandomReal(5.,11.),"when calling setSpeed in Rocket, line 39")
call kQu(Wi[qAw],GetRandomInt(0,255),GetRandomInt(0,255),GetRandomInt(0,255),255,"when calling setColor in Rocket, line 40")
call iQu(Wi[qAw],GetRandomReal(0.5,2.),"when calling setScale in Rocket, line 41")
set RAw=qAw
set vt[RAw]=GetRandomReal(7.,17.)
set JO[qAw]=GetRandomReal(1.,2.5)
call KDu(qAw,JO[qAw],"when calling setTimed in Rocket, line 44")
set Ad=Ad-1
endfunction
function eAw takes real OAw,real lAw,real bAw,string yAw returns integer
local integer pAw
set Dd[Ad]=yAw
set Ad=Ad+1
set pAw=CHu("when calling Shrapnell in Rocket, line 36")
call TAw(pAw,OAw,lAw,bAw,"when calling construct_Shrapnell in Rocket, line 36")
set Ad=Ad-1
return pAw
endfunction
function W8w takes trigger x8w,player v8w,playerunitevent m8w,boolexpr Q8w returns nothing
call TriggerRegisterPlayerUnitEvent(x8w,v8w,m8w,Q8w)
endfunction
function i8w takes trigger s8w,boolexpr t8w returns nothing
call TriggerAddCondition(s8w,t8w)
endfunction
function r8w takes trigger w8w,code u8w returns nothing
call TriggerAddAction(w8w,u8w)
endfunction
function MUw takes playerunitevent DUw,code HUw,code JUw,code KUw returns nothing
local integer LUw=Csu(DUw)
local integer XUw
local filterfunc CUw
local trigger VUw
local player BUw
local playerunitevent NUw
if EO[LUw]==null then
set EO[LUw]=CreateTrigger()
set XUw=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen XUw<0
set VUw=EO[LUw]
set BUw=OO[XUw]
set NUw=DUw
if HUw!=null then
set CUw=Filter(HUw)
else
set CUw=null
endif
call W8w(VUw,BUw,NUw,CUw)
set XUw=XUw-1
endloop
endif
if JUw!=null then
call i8w(EO[LUw],Filter(JUw))
endif
if KUw!=null then
call r8w(EO[LUw],KUw)
endif
set CUw=null
set VUw=null
set BUw=null
set NUw=null
endfunction
function AUw takes playerunitevent IUw,code PUw returns nothing
call MUw(IUw,null,PUw,null)
endfunction
function bfw takes integer lfw returns string
return I2S(lfw)
endfunction
function qsw takes eventid psw returns boolean
local integer esw=Csu(psw)
return (esw>=261 and esw<=268)or esw==17
endfunction
function ysw takes eventid lsw returns boolean
local integer bsw=Csu(lsw)
return (bsw>=18 and bsw<=51)or(bsw>=269 and bsw<=277)
endfunction
function TJ takes eventid dJ,string fJ returns integer
local integer RJ
set Dd[Ad]=fJ
set Ad=Ad+1
set RJ=Csu(dJ)
set du=du+1
set nu[RJ]=du
if ysw(dJ) then
call DEw("reg handleid: "+bfw(RJ)+" -> eventId: "+bfw(du))
call AUw(ConvertPlayerUnitEvent(RJ),FG)
elseif dJ!=EVENT_UNIT_DAMAGED and dJ!=EVENT_PLAYER_LEAVE and dJ!=pu and(not qsw(dJ)) then
call tsw("registering handleid: "+bfw(RJ)+" non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.","when calling error in ClosureEvents, line 241")
endif
set Ad=Ad-1
return du
endfunction
function nJ takes eventid eJ,string qJ returns integer
local integer aJ
set Dd[Ad]=qJ
set Ad=Ad+1
set aJ=nu[Csu(eJ)]
if aJ==0 then
set aJ=TJ(eJ,"when calling registerEventId in ClosureEvents, line 227")
endif
set Ad=Ad-1
return aJ
endfunction
function fK takes unit eK,eventid qK,integer aK,string nK returns integer
local integer dK
set Dd[Ad]=nK
set Ad=Ad+1
set dK=e_u(eK)
if dK<=0 then
set Ad=Ad-1
return aK
endif
set Gu[aK]=nJ(qK,"when calling toIntId in ClosureEvents, line 122")
if Yu[dK]!=0 then
set hu[Yu[dK]]=aK
set gu[aK]=Yu[dK]
endif
set Yu[dK]=aK
set Ad=Ad-1
return aK
endfunction
function KIw takes integer HIw,string JIw returns nothing
set Dd[Ad]=JIw
set Ad=Ad+1
call J4u(0,HIw,"when calling UnitEntity_onDestroy in Reinforcements, line 10",0,null)
set Ad=Ad-1
endfunction
function jHu takes integer FHu,string kHu returns nothing
set Dd[Ad]=kHu
set Ad=Ad+1
if Oe[FHu]==0 then
call tsw("Double free: object of type Reinforcement","when calling error in ")
else
set Se[ce]=FHu
set ce=ce+1
set Oe[FHu]=0
endif
set Ad=Ad-1
endfunction
function gIw takes integer YIw,string GIw returns nothing
set Dd[Ad]=GIw
set Ad=Ad+1
call KIw(YIw,"when calling Reinforcement_onDestroy in Reinforcements, line 10")
call jHu(YIw,"when calling Reinforcement in Reinforcements, line 10")
set Ad=Ad-1
endfunction
function xVu takes integer kVu,string jVu returns nothing
set Dd[Ad]=jVu
set Ad=Ad+1
if Oe[kVu]==0 then
call tsw("Double free: object of type Tower","when calling error in ")
else
set Se[ce]=kVu
set ce=ce+1
set Oe[kVu]=0
endif
set Ad=Ad-1
endfunction
function h6w takes integer G6w,string g6w returns nothing
set Dd[Ad]=g6w
set Ad=Ad+1
call w7w(G6w,"when calling Tower_onDestroy in Tower, line 20")
call xVu(G6w,"when calling Tower in Tower, line 20")
set Ad=Ad-1
endfunction
function iBu takes string sBu returns integer
local integer tBu
set Dd[Ad]=sBu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set tBu=oe
set Oe[tBu]=870
else
call tsw("Out of memory: Could not create TroopGround.","when calling error in ")
set tBu=0
endif
else
set ce=ce-1
set tBu=Se[ce]
set Oe[tBu]=870
endif
set Ad=Ad-1
return tBu
endfunction
function jQ takes integer FQ,string kQ returns nothing
set Dd[Ad]=kQ
set Ad=Ad+1
call kU(FQ,"when calling Boss_onDestroy in BossFour, line 31")
set Ad=Ad-1
endfunction
function tfu takes integer rfu,string sfu returns nothing
set Dd[Ad]=sfu
set Ad=Ad+1
if Oe[rfu]==0 then
call tsw("Double free: object of type BossFour","when calling error in ")
else
set Se[ce]=rfu
set ce=ce+1
set Oe[rfu]=0
endif
set Ad=Ad-1
endfunction
function iQ takes integer sQ,string tQ returns nothing
set Dd[Ad]=tQ
set Ad=Ad+1
call jQ(sQ,"when calling BossFour_onDestroy in BossFour, line 31")
call tfu(sQ,"when calling BossFour in BossFour, line 31")
set Ad=Ad-1
endfunction
function gxu takes integer Yxu,string Gxu returns nothing
set Dd[Ad]=Gxu
set Ad=Ad+1
if Oe[Yxu]==0 then
call tsw("Double free: object of type Entity","when calling error in ")
else
set Se[ce]=Yxu
set ce=ce+1
set Oe[Yxu]=0
endif
set Ad=Ad-1
endfunction
function iuw takes integer suw,string tuw returns nothing
set Dd[Ad]=tuw
set Ad=Ad+1
call auw(suw,"when calling Entity_onDestroy in Entity, line 53")
call gxu(suw,"when calling Entity in Entity, line 53")
set Ad=Ad-1
endfunction
function STu takes integer tTu,string iTu returns nothing
set Dd[Ad]=iTu
set Ad=Ad+1
if Oe[tTu]==0 then
call tsw("Double free: object of type Ball","when calling error in ")
else
set Se[ce]=tTu
set ce=ce+1
set Oe[tTu]=0
endif
set Ad=Ad-1
endfunction
function pH takes integer bH,string yH returns nothing
set Dd[Ad]=yH
set Ad=Ad+1
call EOw(bH,"when calling FxEntity_onDestroy in Builder, line 55")
set Ad=Ad-1
endfunction
function lH takes integer oH,string OH returns nothing
set Dd[Ad]=OH
set Ad=Ad+1
call pH(oH,"when calling Ball_onDestroy in Builder, line 55")
call STu(oH,"when calling Ball in Builder, line 55")
set Ad=Ad-1
endfunction
function fHu takes integer nHu,string dHu returns nothing
set Dd[Ad]=dHu
set Ad=Ad+1
if Oe[nHu]==0 then
call tsw("Double free: object of type Projectile","when calling error in ")
else
set Se[ce]=nHu
set ce=ce+1
set Oe[nHu]=0
endif
set Ad=Ad-1
endfunction
function lZw takes integer oZw,string OZw returns nothing
set Dd[Ad]=OZw
set Ad=Ad+1
call sUw(oZw,"when calling Projectile_onDestroy in Projectile, line 4")
call fHu(oZw,"when calling Projectile in Projectile, line 4")
set Ad=Ad-1
endfunction
function nBu takes integer qBu,string aBu returns nothing
set Dd[Ad]=aBu
set Ad=Ad+1
if Oe[qBu]==0 then
call tsw("Double free: object of type TrooperTower","when calling error in ")
else
set Se[ce]=qBu
set ce=ce+1
set Oe[qBu]=0
endif
set Ad=Ad-1
endfunction
function nGu takes string qGu returns integer
local integer aGu
set Dd[Ad]=qGu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set aGu=Le
set Xe[aGu]=723
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set aGu=0
endif
else
set Ke=Ke-1
set aGu=Je[Ke]
set Xe[aGu]=723
endif
set Ad=Ad-1
return aGu
endfunction
function oGu takes string SGu returns integer
local integer cGu
set Dd[Ad]=SGu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set cGu=oe
set Oe[cGu]=842
else
call tsw("Out of memory: Could not create Creep.","when calling error in ")
set cGu=0
endif
else
set ce=ce-1
set cGu=Se[ce]
set Oe[cGu]=842
endif
set Ad=Ad-1
return cGu
endfunction
function cou takes real tou,real iou,real Sou returns real
set Vd=tou
set Bd=iou
set Nd=Sou
return Vd
endfunction
function oww takes unit cww returns real
if xi then
set YR=Otu(cww)
set GR=wf
set gR=uf
return YR
endif
set YR=cou(stu(cww),cf,0.)
set GR=Bd
set gR=Nd
return YR
endfunction
function Tmu takes integer fmu,string Rmu returns nothing
set Dd[Ad]=Rmu
set Ad=Ad+1
if Oe[fmu]==0 then
call tsw("Double free: object of type ForceField","when calling error in ")
else
set Se[ce]=fmu
set ce=ce+1
set Oe[fmu]=0
endif
set Ad=Ad-1
endfunction
function acw takes integer ecw,string qcw returns nothing
set Dd[Ad]=qcw
set Ad=Ad+1
call EOw(ecw,"when calling FxEntity_onDestroy in FieldGenerator, line 23")
set Ad=Ad-1
endfunction
function pcw takes integer bcw,string ycw returns nothing
set Dd[Ad]=ycw
set Ad=Ad+1
call acw(bcw,"when calling ForceField_onDestroy in FieldGenerator, line 23")
call Tmu(bcw,"when calling ForceField in FieldGenerator, line 23")
set Ad=Ad-1
endfunction
function Okw takes real ckw,real okw returns boolean
return ckw>go and ckw<Fo and okw>ho and okw<ko
endfunction
function pkw takes real lkw,real bkw,real ykw returns boolean
return Okw(lkw,bkw)
endfunction
function qSu takes unit pSu,real eSu returns nothing
call UnitApplyTimedLife(pSu,1112820806,eSu)
endfunction
function kNu takes integer hNu,string FNu returns nothing
set Dd[Ad]=FNu
set Ad=Ad+1
if Oe[hNu]==0 then
call tsw("Double free: object of type WaveMissile","when calling error in ")
else
set Se[ce]=hNu
set ce=ce+1
set Oe[hNu]=0
endif
set Ad=Ad-1
endfunction
function Ipw takes group Upw returns nothing
call DestroyGroup(Upw)
endfunction
function UEw takes string ZEw returns nothing
call YEw(lO,3,ZEw)
endfunction
function Zpw takes group Epw returns nothing
call GroupClear(Epw)
endfunction
function M0u takes group N0u returns integer
return Csu(N0u)
endfunction
function bpw takes group opw,string Opw returns boolean
local boolean lpw
set Dd[Ad]=Opw
set Ad=Ad+1
set lpw=nEu(rS,M0u(opw),"when calling has in GroupUtils, line 108")
set Ad=Ad-1
return lpw
endfunction
function S_u takes boolean t_u returns integer
local integer i_u
if t_u then
set i_u=1
else
set i_u=0
endif
return i_u
endfunction
function Fpw takes group gpw,string hpw returns nothing
set Dd[Ad]=hpw
set Ad=Ad+1
set sS[tS]=gpw
call YEu(rS,M0u(sS[tS]),S_u(false),"when calling put in GroupUtils, line 118")
set tS=tS+1
set Ad=Ad-1
endfunction
function dpw takes group apw,string npw returns nothing
set Dd[Ad]=npw
set Ad=Ad+1
call Zpw(apw)
call Fpw(apw,"when calling push in GroupUtils, line 138")
set Ad=Ad-1
endfunction
function o_u takes integer c_u returns boolean
return c_u==1
endfunction
function qpw takes group ypw,string ppw returns boolean
local boolean epw
set Dd[Ad]=ppw
set Ad=Ad+1
set epw=o_u(kEu(rS,M0u(ypw),"when calling get in GroupUtils, line 112"))
set Ad=Ad-1
return epw
endfunction
function cpw takes group ipw,string Spw returns nothing
set Dd[Ad]=Spw
set Ad=Ad+1
if ipw==OS then
call UEw("Attemping to release ENUM_GROUP!")
elseif bpw(ipw,"when calling isRecyclable in GroupUtils, line 57") then
if qpw(ipw,"when calling isUsed in GroupUtils, line 58") then
call dpw(ipw,"when calling recycle in GroupUtils, line 59")
else
call UEw("Attemping to release an already released group!")
endif
else
call Zpw(ipw)
call Ipw(ipw)
endif
set Ad=Ad-1
endfunction
function wpu takes integer Nyu,string Myu returns nothing
set Dd[Ad]=Myu
set Ad=Ad+1
call cpw(mp[Nyu],"when calling release in WaveTower, line 76")
call sUw(Nyu,"when calling Projectile_onDestroy in WaveTower, line 35")
set Ad=Ad-1
endfunction
function ryu takes integer wyu,string uyu returns nothing
set Dd[Ad]=uyu
set Ad=Ad+1
call wpu(wyu,"when calling WaveMissile_onDestroy in WaveTower, line 75")
call kNu(wyu,"when calling WaveMissile in WaveTower, line 75")
set Ad=Ad-1
endfunction
function ZVu takes integer WVu,string EVu returns nothing
set Dd[Ad]=EVu
set Ad=Ad+1
if Oe[WVu]==0 then
call tsw("Double free: object of type Wall","when calling error in ")
else
set Se[ce]=WVu
set ce=ce+1
set Oe[WVu]=0
endif
set Ad=Ad-1
endfunction
function e7w takes integer y7w,string p7w returns nothing
set Dd[Ad]=p7w
set Ad=Ad+1
call J4u(0,y7w,"when calling UnitEntity_onDestroy in Tower, line 15",0,null)
set Ad=Ad-1
endfunction
function s7w takes integer u7w,string r7w returns nothing
set Dd[Ad]=r7w
set Ad=Ad+1
call e7w(u7w,"when calling Wall_onDestroy in Tower, line 15")
call ZVu(u7w,"when calling Wall in Tower, line 15")
set Ad=Ad-1
endfunction
function YSw takes integer TSw returns nothing
set fi=fi-1
if TSw!=ni then
set Ti[Ri[TSw]]=Ti[TSw]
else
set ni=Ti[TSw]
endif
if TSw!=di then
set Ri[Ti[TSw]]=Ri[TSw]
else
set di=Ri[TSw]
endif
endfunction
function Xvu takes integer Kvu,string Lvu returns nothing
set Dd[Ad]=Lvu
set Ad=Ad+1
if qa[Kvu]==0 then
if Kvu==0 then
call tsw("Nullpointer exception when calling FText.FText_FText_LinkedListModule_remove","when calling error in ")
else
call tsw("Called FText.FText_FText_LinkedListModule_remove on invalid object.","when calling error in ")
endif
endif
call YSw(Kvu)
set Ad=Ad-1
endfunction
function j4w takes texttag k4w returns nothing
call DestroyTextTag(k4w)
endfunction
function nSw takes integer qSw,string aSw returns nothing
set Dd[Ad]=aSw
set Ad=Ad+1
if pi[qSw]!=null then
call j4w(pi[qSw])
set pi[qSw]=null
endif
call Xvu(qSw,"when calling remove in LinkedListModule, line 49")
set Ad=Ad-1
endfunction
function wmu takes integer Nvu,string Mvu returns nothing
set Dd[Ad]=Mvu
set Ad=Ad+1
if qa[Nvu]==0 then
call tsw("Double free: object of type FText","when calling error in ")
else
set ya[pa]=Nvu
set pa=pa+1
set qa[Nvu]=0
endif
set Ad=Ad-1
endfunction
function oSw takes integer SSw,string cSw returns nothing
set Dd[Ad]=cSw
set Ad=Ad+1
call nSw(SSw,"when calling FText_onDestroy in FText, line 74")
call wmu(SSw,"when calling FText in FText, line 74")
set Ad=Ad-1
endfunction
function Yvu takes integer Rvu,string Tvu returns nothing
set Dd[Ad]=Tvu
set Ad=Ad+1
if qa[Rvu]==0 then
if Rvu==0 then
call tsw("Nullpointer exception when calling FText.destroyFText","when calling error in ")
else
call tsw("Called FText.destroyFText on invalid object.","when calling error in ")
endif
endif
call oSw(Rvu,"when calling destroyFText in FText, line 64")
set Ad=Ad-1
endfunction
function LDw takes integer JDw,string KDw returns nothing
set Dd[Ad]=KDw
set Ad=Ad+1
call biu(Nt[JDw])
call Yvu(sl[JDw],"when calling FText in Selector, line 79")
set cO[wO[kQw(Et[JDw])]]=0
call J4u(0,JDw,"when calling UnitEntity_onDestroy in Selector, line 25",0,null)
set Ad=Ad-1
endfunction
function cJu takes integer iJu,string SJu returns nothing
set Dd[Ad]=SJu
set Ad=Ad+1
if Oe[iJu]==0 then
call tsw("Double free: object of type Selector","when calling error in ")
else
set Se[ce]=iJu
set ce=ce+1
set Oe[iJu]=0
endif
set Ad=Ad-1
endfunction
function sDw takes integer uDw,string rDw returns nothing
set Dd[Ad]=rDw
set Ad=Ad+1
call LDw(uDw,"when calling Selector_onDestroy in Selector, line 77")
call cJu(uDw,"when calling Selector in Selector, line 77")
set Ad=Ad-1
endfunction
function Rpu takes integer dpu,string fpu returns nothing
set Dd[Ad]=fpu
set Ad=Ad+1
call w7w(dpu,"when calling Tower_onDestroy in WaveTower, line 11")
set Ad=Ad-1
endfunction
function UNu takes integer ENu,string ZNu returns nothing
set Dd[Ad]=ZNu
set Ad=Ad+1
if Oe[ENu]==0 then
call tsw("Double free: object of type WaveTower","when calling error in ")
else
set Se[ce]=ENu
set ce=ce+1
set Oe[ENu]=0
endif
set Ad=Ad-1
endfunction
function spu takes integer upu,string rpu returns nothing
set Dd[Ad]=rpu
set Ad=Ad+1
call Rpu(upu,"when calling WaveTower_onDestroy in WaveTower, line 11")
call UNu(upu,"when calling WaveTower in WaveTower, line 11")
set Ad=Ad-1
endfunction
function QGu takes integer vGu,string mGu returns nothing
set Dd[Ad]=mGu
set Ad=Ad+1
if Oe[vGu]==0 then
call tsw("Double free: object of type DestroyerSummoner","when calling error in ")
else
set Se[ce]=vGu
set ce=ce+1
set Oe[vGu]=0
endif
set Ad=Ad-1
endfunction
function g3 takes integer Y3,string G3 returns nothing
set Dd[Ad]=G3
set Ad=Ad+1
call YM(Y3,"when calling Creep_onDestroy in DestroyerSummoner, line 109")
set Ad=Ad-1
endfunction
function t3 takes integer r3,string s3 returns nothing
set Dd[Ad]=s3
set Ad=Ad+1
call g3(r3,"when calling DestroyerSummoner_onDestroy in DestroyerSummoner, line 109")
call QGu(r3,"when calling DestroyerSummoner in DestroyerSummoner, line 109")
set Ad=Ad-1
endfunction
function OXu takes integer cXu,string oXu returns nothing
set Dd[Ad]=oXu
set Ad=Ad+1
if Oe[cXu]==0 then
call tsw("Double free: object of type Special","when calling error in ")
else
set Se[ce]=cXu
set ce=ce+1
set Oe[cXu]=0
endif
set Ad=Ad-1
endfunction
function uNw takes integer MBw,string wNw returns nothing
set Dd[Ad]=wNw
set Ad=Ad+1
call nNw(MBw,"when calling Special_onDestroy in Special, line 13")
call OXu(MBw,"when calling Special in Special, line 13")
set Ad=Ad-1
endfunction
function utu takes unit wtu returns player
return GetOwningPlayer(wtu)
endfunction
function qKw takes integer OKw,integer lKw,string bKw returns integer
local integer yKw
local timer pKw
local timer eKw
set Dd[Ad]=bKw
set Ad=Ad+1
set Kl[OKw]=lKw
set yKw=hKu(OKw,"when calling getSound in SoundUtils, line 89")
set pKw=b2w("when calling getTimer in SoundUtils, line 90")
call s2w(pKw,yKw,"when calling setData in SoundUtils, line 91")
set eKw=pKw
call j2w(eKw,0.,ag)
set Ad=Ad-1
set pKw=null
set eKw=null
return yKw
endfunction
function EKu takes integer vKu,integer mKu,string QKu returns integer
local integer WKu
set Dd[Ad]=QKu
set Ad=Ad+1
if vn[vKu]==0 then
if vKu==0 then
call tsw("Nullpointer exception when calling SoundDefinition.SoundUtils_SoundDefinition_play","when calling error in ")
else
call tsw("Called SoundDefinition.SoundUtils_SoundDefinition_play on invalid object.","when calling error in ")
endif
endif
set WKu=qKw(vKu,mKu,"when calling play in SoundUtils, line 87")
set Ad=Ad-1
return WKu
endfunction
function JJw takes integer AJw,string DJw returns integer
local integer HJw
set Dd[Ad]=DJw
set Ad=Ad+1
set HJw=EKu(AJw,kl,"when calling play in SoundUtils, line 81")
set Ad=Ad-1
return HJw
endfunction
function xKu takes integer FKu,string kKu returns integer
local integer jKu
set Dd[Ad]=kKu
set Ad=Ad+1
if vn[FKu]==0 then
if FKu==0 then
call tsw("Nullpointer exception when calling SoundDefinition.SoundUtils_SoundDefinition_play","when calling error in ")
else
call tsw("Called SoundDefinition.SoundUtils_SoundDefinition_play on invalid object.","when calling error in ")
endif
endif
set jKu=JJw(FKu,"when calling play in SoundUtils, line 80")
set Ad=Ad-1
return jKu
endfunction
function Ndw takes integer Vdw,string Bdw returns nothing
set Dd[Ad]=Bdw
set Ad=Ad+1
call w7w(Vdw,"when calling Tower_onDestroy in HealbackTower, line 16")
set Ad=Ad-1
endfunction
function nZu takes integer qZu,string aZu returns nothing
set Dd[Ad]=aZu
set Ad=Ad+1
if Oe[qZu]==0 then
call tsw("Double free: object of type HealbackTower","when calling error in ")
else
set Se[ce]=qZu
set ce=ce+1
set Oe[qZu]=0
endif
set Ad=Ad-1
endfunction
function xnw takes integer knw,string jnw returns nothing
set Dd[Ad]=jnw
set Ad=Ad+1
call Ndw(knw,"when calling HealbackTower_onDestroy in HealbackTower, line 16")
call nZu(knw,"when calling HealbackTower in HealbackTower, line 16")
set Ad=Ad-1
endfunction
function UZw takes integer EZw returns real
local integer ZZw=EZw
return YO[ZZw]
endfunction
function yHu takes integer OHu,string lHu returns real
local real bHu
set Dd[Ad]=lHu
set Ad=Ad+1
if Oe[OHu]==0 then
if OHu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_getXYAngle","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_getXYAngle on invalid object.","when calling error in ")
endif
endif
set bHu=UZw(OHu)
set Ad=Ad-1
return bHu
endfunction
function J2u takes integer K4u,integer L4u,integer X4u,integer C4u,integer V4u,integer B4u,integer N4u,string M4u,real w2u,real u2u,real r2u,integer s2u,integer t2u,real i2u,real S2u,real c2u,string o2u,unit O2u,real l2u,real b2u,real y2u,real p2u,string e2u,player q2u,string a2u returns nothing
local integer n2u
local integer d2u
local integer f2u
local integer R2u
local integer T2u
local integer Y2u
local integer G2u
local unit g2u
local playerunitevent h2u
local real F2u
local integer k2u
local unit j2u
local unit x2u
local unit v2u
local integer m2u
local integer Q2u
local integer W2u
local integer E2u
local integer Z2u
local integer U2u
local integer I2u
local unit P2u
local unit A2u
local unit D2u
local unit H2u
if K4u==0 then
if L4u==0 then
if X4u==0 then
if C4u==0 then
if V4u==0 then
if B4u==0 then
set Dd[Ad]=M4u
set Ad=Ad+1
if Oe[N4u]==0 then
if N4u==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_terminate","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_terminate on invalid object.","when calling error in ")
endif
endif
call J2u(0,0,0,0,0,1,N4u,"when calling terminate in Entity, line 173",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
elseif B4u==1 then
set Dd[Ad]=M4u
set Ad=Ad+1
if not Ut[N4u]then
set Ut[N4u]=true
call J2u(0,0,0,0,0,2,N4u,"when calling Entity in Entity, line 176",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
elseif B4u==2 then
set Dd[Ad]=M4u
set Ad=Ad+1
if Oe[N4u]==0 then
if N4u==0 then
call tsw("Nullpointer exception when calling Entity.destroyEntity","when calling error in ")
else
call tsw("Called Entity.destroyEntity on invalid object.","when calling error in ")
endif
endif
if Oe[N4u]<=847 then
if Oe[N4u]<=835 then
if Oe[N4u]<=829 then
if Oe[N4u]<=826 then
if Oe[N4u]<=825 then
if Oe[N4u]<=824 then
call iuw(N4u,"when calling destroyEntity in Entity, line 54")
else
call OOw(N4u,"when calling destroyFxEntity in Entity, line 54")
endif
else
call lH(N4u,"when calling destroyBall in Entity, line 54")
endif
elseif Oe[N4u]<=828 then
if Oe[N4u]<=827 then
call pcw(N4u,"when calling destroyForceField in Entity, line 54")
else
call lZw(N4u,"when calling destroyProjectile in Entity, line 54")
endif
else
call SF(N4u,"when calling destroyArtilleryMissile in Entity, line 54")
endif
elseif Oe[N4u]<=832 then
if Oe[N4u]<=831 then
if Oe[N4u]<=830 then
call Acw(N4u,"when calling destroyFlameMissile in Entity, line 54")
else
call Law(N4u,"when calling destroyHealbackMissile in Entity, line 54")
endif
else
call J2u(1,N4u,0,0,0,0,0,"when calling destroyPhysicsProjectile in Entity, line 54",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
elseif Oe[N4u]<=834 then
if Oe[N4u]<=833 then
call J2u(0,0,0,1,N4u,0,0,"when calling destroyRocket in Entity, line 54",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
else
call J2u(0,0,0,0,1,N4u,0,"when calling destroyShrapnell in Entity, line 54",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
else
call UNw(N4u,"when calling destroySphere in Entity, line 54")
endif
elseif Oe[N4u]<=841 then
if Oe[N4u]<=838 then
if Oe[N4u]<=837 then
if Oe[N4u]<=836 then
call L5w(N4u,"when calling destroyTowerBlockadeMissile in Entity, line 54")
else
call ryu(N4u,"when calling destroyWaveMissile in Entity, line 54")
endif
else
call iuw(N4u,"when calling destroyEntity in Entity, line 54")
endif
elseif Oe[N4u]<=840 then
if Oe[N4u]<=839 then
call Zrw(N4u,"when calling destroyUnitEntity in Entity, line 54")
else
call J4u(3,2,null,N4u,"when calling destroyBlockadeShip in Entity, line 54")
endif
else
call aH(N4u,"when calling destroyBuilder in Entity, line 54")
endif
elseif Oe[N4u]<=844 then
if Oe[N4u]<=843 then
if Oe[N4u]<=842 then
call VN(N4u,"when calling destroyCreep in Entity, line 54")
else
call OU(N4u,"when calling destroyBoss in Entity, line 54")
endif
else
call bm(N4u,"when calling destroyBossFive in Entity, line 54")
endif
elseif Oe[N4u]<=846 then
if Oe[N4u]<=845 then
call iQ(N4u,"when calling destroyBossFour in Entity, line 54")
else
call VQ(N4u,"when calling destroyBossOne in Entity, line 54")
endif
else
call JW(N4u,"when calling destroyBossThree in Entity, line 54")
endif
elseif Oe[N4u]<=859 then
if Oe[N4u]<=853 then
if Oe[N4u]<=850 then
if Oe[N4u]<=849 then
if Oe[N4u]<=848 then
call AE(N4u,"when calling destroyBossTwo in Entity, line 54")
else
call U8(N4u,"when calling destroyEndBoss in Entity, line 54")
endif
else
call t3(N4u,"when calling destroyDestroyerSummoner in Entity, line 54")
endif
elseif Oe[N4u]<=852 then
if Oe[N4u]<=851 then
call uNw(N4u,"when calling destroySpecial in Entity, line 54")
else
call VLw(N4u,"when calling destroySpawn in Entity, line 54")
endif
else
call PXw(N4u,"when calling destroySpecialFive in Entity, line 54")
endif
elseif Oe[N4u]<=856 then
if Oe[N4u]<=855 then
if Oe[N4u]<=854 then
call RCw(N4u,"when calling destroySpecialFour in Entity, line 54")
else
call CCw(N4u,"when calling destroySpecialOne in Entity, line 54")
endif
else
call TVw(N4u,"when calling destroySpecialThree in Entity, line 54")
endif
elseif Oe[N4u]<=858 then
if Oe[N4u]<=857 then
call BVw(N4u,"when calling destroySpecialTwo in Entity, line 54")
else
call JZ(N4u,"when calling destroyTentacle in Entity, line 54")
endif
else
call gIw(N4u,"when calling destroyReinforcement in Entity, line 54")
endif
elseif Oe[N4u]<=865 then
if Oe[N4u]<=862 then
if Oe[N4u]<=861 then
if Oe[N4u]<=860 then
call sDw(N4u,"when calling destroySelector in Entity, line 54")
else
call h6w(N4u,"when calling destroyTower in Entity, line 54")
endif
else
call XF(N4u,"when calling destroyArtilleryTower in Entity, line 54")
endif
elseif Oe[N4u]<=864 then
if Oe[N4u]<=863 then
call aow(N4u,"when calling destroyFlamethrowerTower in Entity, line 54")
else
call xnw(N4u,"when calling destroyHealbackTower in Entity, line 54")
endif
else
call W4w(N4u,"when calling destroyThermoTower in Entity, line 54")
endif
elseif Oe[N4u]<=868 then
if Oe[N4u]<=867 then
if Oe[N4u]<=866 then
call J2u(0,0,0,0,0,3,N4u,"when calling destroyTrooperTower in Entity, line 54",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
else
call spu(N4u,"when calling destroyWaveTower in Entity, line 54")
endif
else
call Hbw(N4u,"when calling destroyTreasure in Entity, line 54")
endif
elseif Oe[N4u]<=870 then
if Oe[N4u]<=869 then
call M8w(N4u,"when calling destroyTroop in Entity, line 54")
else
call L8w(N4u,"when calling destroyTroopGround in Entity, line 54")
endif
else
call s7w(N4u,"when calling destroyWall in Entity, line 54")
endif
set Ad=Ad-1
elseif B4u==3 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,0,0,4,N4u,"when calling TrooperTower_onDestroy in TrooperTower, line 95",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call nBu(N4u,"when calling TrooperTower in TrooperTower, line 95")
set Ad=Ad-1
elseif B4u==4 then
set Dd[Ad]=M4u
set Ad=Ad+1
set n2u=lgw(Xy[N4u],"when calling iterator in TrooperTower, line 96")
loop
exitwhen not nGw(n2u)
set d2u=qGw(n2u)
set f2u=d2u
call J2u(0,0,1,0,0,0,0,null,ht[f2u],Ft[f2u],kt[f2u],0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,Et[d2u],"when calling new_TroopGround in TrooperTower, line 97")
call J2u(0,0,0,0,0,0,d2u,"when calling terminate in TrooperTower, line 98",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endloop
call RGw(n2u,"when calling close in TrooperTower, line 96")
call xIu(Xy[N4u],"when calling LinkedList in TrooperTower, line 99")
call w7w(N4u,"when calling Tower_onDestroy in TrooperTower, line 35")
set Ad=Ad-1
endif
elseif V4u==1 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,0,2,B4u,0,"when calling Shrapnell_onDestroy in Rocket, line 33",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call NHu(B4u,"when calling Shrapnell in Rocket, line 33")
set Ad=Ad-1
elseif V4u==2 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,0,3,B4u,0,"when calling PhysicsProjectile_onDestroy in Rocket, line 33",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
elseif V4u==3 then
set Dd[Ad]=M4u
set Ad=Ad+1
if Vo[B4u]!=0 then
call J2u(0,0,0,0,4,Vo[B4u],B4u,"when calling onExpire in PhysicsProjectile, line 26",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call WAu(Vo[B4u],"when calling OnExpireEvent in PhysicsProjectile, line 27")
endif
call sUw(B4u,"when calling Projectile_onDestroy in PhysicsProjectile, line 8")
set Ad=Ad-1
elseif V4u==4 then
set Dd[Ad]=M4u
set Ad=Ad+1
if He[B4u]==0 then
if B4u==0 then
call tsw("Nullpointer exception when calling OnExpireEvent.PhysicsProjectile_OnExpireEvent_onExpire","when calling error in ")
else
call tsw("Called OnExpireEvent.PhysicsProjectile_OnExpireEvent_onExpire on invalid object.","when calling error in ")
endif
endif
call J2u(0,0,0,0,5,B4u,N4u,"when calling BossOne_closure_impl in PhysicsProjectile, line 6",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
elseif V4u==5 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,0,6,0,0,null,Oju(N4u,"when calling getPos in BossOne, line 14"),yf,pf,1966092374,12,Up,Ip,yHu(N4u,"when calling getXYAngle in BossOne, line 14"),"when calling new_Creep in BossOne, line 14",null,0.,0.,0.,0.,null,null,null)
set R2u=vg
set Ad=Ad-1
set vg=R2u
set g2u=null
set h2u=null
set j2u=null
set x2u=null
set v2u=null
set P2u=null
set A2u=null
set D2u=null
set H2u=null
return
elseif V4u==6 then
set Dd[Ad]=o2u
set Ad=Ad+1
set T2u=oGu("when calling Creep in Creep, line 42")
call J2u(0,0,0,0,7,T2u,0,null,w2u,u2u,r2u,s2u,t2u,i2u,S2u,c2u,"when calling construct_Creep in Creep, line 42",null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
set vg=T2u
set g2u=null
set h2u=null
set j2u=null
set x2u=null
set v2u=null
set P2u=null
set A2u=null
set D2u=null
set H2u=null
return
elseif V4u==7 then
set Dd[Ad]=o2u
set Ad=Ad+1
call J2u(0,0,0,0,8,B4u,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Iru(rr,s2u,EOu(w2u,u2u,r2u),Ef,c2u),w2u,u2u,r2u,16.,"when calling construct_UnitEntity3 in Creep, line 42",null,null)
call Tiu(Nt[B4u],"birth")
set tr[B4u]=t2u
set ir[B4u]=bFw()
call qSu(Nt[B4u],5.15*60.)
set g2u=Nt[B4u]
set h2u=EVENT_PLAYER_UNIT_DEATH
set Y2u=nGu("when calling alloc_Closure in Creep, line 50")
call cL(Y2u)
set Sr[Y2u]=B4u
call fK(g2u,h2u,Y2u,"when calling add in Creep, line 50")
set F2u=GetRandomReal(0.01,0.2)
set G2u=RGu("when calling alloc_Closure in Creep, line 51")
call VC(G2u)
set cr[G2u]=B4u
set k2u=G2u
set lr[k2u]=i2u
set br[k2u]=S2u
call gX(F2u,G2u,"when calling doAfter in Creep, line 51")
set Ad=Ad-1
elseif V4u==8 then
set Dd[Ad]=e2u
set Ad=Ad+1
call puw(B4u,utu(O2u),l2u,b2u,y2u,p2u,"when calling construct_Entity5 in Entity, line 206")
set Nt[B4u]=null
call J2u(0,0,0,0,9,B4u,0,null,0.,0.,0.,0,0,0.,0.,0.,null,O2u,0.,0.,0.,0.,"when calling setupUnitEntity in Entity, line 208",null,null)
set Ad=Ad-1
elseif V4u==9 then
set Dd[Ad]=e2u
set Ad=Ad+1
if Oe[B4u]==0 then
if B4u==0 then
call tsw("Nullpointer exception when calling UnitEntity.Entity_UnitEntity_setupUnitEntity","when calling error in ")
else
call tsw("Called UnitEntity.Entity_UnitEntity_setupUnitEntity on invalid object.","when calling error in ")
endif
endif
call J2u(0,0,0,0,10,B4u,0,null,0.,0.,0.,0,0,0.,0.,0.,null,O2u,0.,0.,0.,0.,"when calling setupUnitEntity in Entity, line 210",null,null)
set Ad=Ad-1
elseif V4u==10 then
set Dd[Ad]=e2u
set Ad=Ad+1
set Nt[B4u]=O2u
if not xtu(O2u) then
call J2u(0,0,0,0,0,0,B4u,"when calling terminate in Entity, line 213",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call tsw("Trying to assign entity to unit that is not alive","when calling error in Entity, line 214")
endif
if sww(O2u)!=0 then
call J2u(0,0,0,0,0,0,B4u,"when calling terminate in Entity, line 216",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call tsw("Trying to assign entity to unit that already has an entity","when calling error in Entity, line 217")
endif
set j2u=O2u
call Sww(j2u,B4u)
set x2u=j2u
call Osu(x2u,tw)
set v2u=x2u
call eiu(v2u,tw)
if xi then
set P2u=O2u
set m2u=B4u
call KSu(P2u,ht[m2u],Ft[m2u],kt[m2u])
else
set A2u=O2u
set Q2u=B4u
call PSu(A2u,ht[Q2u],Ft[Q2u],kt[Q2u])
endif
set Ad=Ad-1
endif
elseif C4u==1 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,2,V4u,0,0,"when calling Rocket_onDestroy in Rocket, line 26",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call KHu(V4u,"when calling Rocket in Rocket, line 26")
set Ad=Ad-1
elseif C4u==2 then
set Dd[Ad]=M4u
set Ad=Ad+1
call f1w(Oju(V4u,"when calling getPos in Rocket, line 27"),yf,pf,0.,0.,17.5,"HELP!",25.,2.,255,50,50,255,"when calling new_TextTagEntity in Rocket, line 27")
call xKu(HO,"when calling play in Rocket, line 28")
set W2u=0
loop
exitwhen W2u>16
call eAw(Oju(V4u,"when calling getPos in Rocket, line 30"),yf,pf,"when calling new_Shrapnell in Rocket, line 30")
set W2u=W2u+1
endloop
call J2u(0,0,0,0,3,V4u,0,"when calling PhysicsProjectile_onDestroy in Rocket, line 12",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
endif
elseif X4u==1 then
set Dd[Ad]=a2u
set Ad=Ad+1
set E2u=iBu("when calling TroopGround in TrooperTower, line 16")
call J2u(0,0,2,E2u,0,0,0,null,w2u,u2u,r2u,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,q2u,"when calling construct_TroopGround in TrooperTower, line 16")
set Ad=Ad-1
set vg=E2u
set g2u=null
set h2u=null
set j2u=null
set x2u=null
set v2u=null
set P2u=null
set A2u=null
set D2u=null
set H2u=null
return
elseif X4u==2 then
set Dd[Ad]=a2u
set Ad=Ad+1
call J2u(0,0,3,C4u,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Ssu(q2u,Jy,w2u,u2u,r2u,0.),0.,0.,0.,0.,"when calling construct_UnitEntity in TrooperTower, line 16",null,null)
call J2u(0,1,C4u,0,0,0,0,null,w2u,u2u,r2u,0,0,0.,0.,0.,"when calling setXY in TrooperTower, line 18",null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
elseif X4u==3 then
set Dd[Ad]=e2u
set Ad=Ad+1
call puw(C4u,utu(O2u),oww(O2u),GR,gR,0.,"when calling construct_Entity5 in Entity, line 198")
set Nt[C4u]=null
call J2u(0,0,0,0,9,C4u,0,null,0.,0.,0.,0,0,0.,0.,0.,null,O2u,0.,0.,0.,0.,"when calling setupUnitEntity in Entity, line 200",null,null)
set Ad=Ad-1
endif
elseif L4u==1 then
set Dd[Ad]=o2u
set Ad=Ad+1
if Oe[X4u]==0 then
if X4u==0 then
call tsw("Nullpointer exception when calling UnitEntity.Entity_UnitEntity_setXY","when calling error in ")
else
call tsw("Called UnitEntity.Entity_UnitEntity_setXY on invalid object.","when calling error in ")
endif
endif
call J2u(0,2,X4u,0,0,0,0,null,w2u,u2u,r2u,0,0,0.,0.,0.,"when calling setXY in Entity, line 237",null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
elseif L4u==2 then
set Dd[Ad]=o2u
set Ad=Ad+1
if pkw(w2u,u2u,r2u) then
set Z2u=X4u
set ht[Z2u]=w2u
set Ft[Z2u]=u2u
set kt[Z2u]=r2u
if xi then
set D2u=Nt[X4u]
set U2u=X4u
call KSu(D2u,ht[U2u],Ft[U2u],kt[U2u])
else
set H2u=Nt[X4u]
set I2u=X4u
call PSu(H2u,ht[I2u],Ft[I2u],kt[I2u])
endif
else
call J2u(0,0,0,0,0,0,X4u,"when calling terminate in Entity, line 245",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endif
elseif K4u==1 then
set Dd[Ad]=M4u
set Ad=Ad+1
call J2u(0,0,0,0,3,L4u,0,"when calling PhysicsProjectile_onDestroy in PhysicsProjectile, line 24",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
call ODu(L4u,"when calling PhysicsProjectile in PhysicsProjectile, line 24")
set Ad=Ad-1
endif
set g2u=null
set h2u=null
set j2u=null
set x2u=null
set v2u=null
set P2u=null
set A2u=null
set D2u=null
set H2u=null
endfunction
function fMw takes string dMw returns string
return StringCase(dMw,false)
endfunction
function fsu takes unit nsu,integer dsu returns item
return UnitAddItemById(nsu,dsu)
endfunction
function OTu takes string cTu returns integer
local integer oTu
set Dd[Ad]=cTu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set oTu=oe
set Oe[oTu]=841
else
call tsw("Out of memory: Could not create Builder.","when calling error in ")
set oTu=0
endif
else
set ce=ce-1
set oTu=Se[ce]
set Oe[oTu]=841
endif
set Ad=Ad-1
return oTu
endfunction
function Etu takes unit Qtu,string Wtu returns boolean
return IssueImmediateOrder(Qtu,Wtu)
endfunction
function Rtu takes unit dtu,real ftu returns real
set fR=itu(dtu)
set RR=ctu(dtu)
set TR=ftu
return fR
endfunction
function Kou takes real Aou,real Dou,real Hou,real Jou returns real
set Kf=Aou*Jou
set Lf=Dou*Jou
set Xf=Hou*Jou
return Kf
endfunction
function YOu takes real fOu,real ROu,real TOu returns real
return fOu*fOu+ROu*ROu+TOu*TOu
endfunction
function Zww takes integer vww,real mww,real Qww,real Www returns nothing
local integer Eww=vww
set ht[Eww]=mww
set Ft[Eww]=Qww
set kt[Eww]=Www
endfunction
function nlw takes integer plw,real elw,real qlw,real alw returns nothing
call KSu(Zi[plw],elw,qlw,alw)
endfunction
function HQu takes integer UQu,real IQu,real PQu,real AQu,string DQu returns nothing
set Dd[Ad]=DQu
set Ad=Ad+1
if Fa[UQu]==0 then
if UQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setXYZ","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setXYZ on invalid object.","when calling error in ")
endif
endif
call nlw(UQu,IQu,PQu,AQu)
set Ad=Ad-1
endfunction
function wOw takes integer Xow,real Cow,real Vow,real Bow,string Now returns nothing
local integer Mow
set Dd[Ad]=Now
set Ad=Ad+1
set Mow=Xow
set ht[Mow]=Cow
set Ft[Mow]=Vow
set kt[Mow]=Bow
call HQu(Wi[Xow],Cow,Vow,Bow,"when calling setXYZ in FxEntity, line 46")
set Ad=Ad-1
endfunction
function qju takes integer lju,real bju,real yju,real pju,string eju returns nothing
set Dd[Ad]=eju
set Ad=Ad+1
if Oe[lju]==0 then
if lju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_setXY","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_setXY on invalid object.","when calling error in ")
endif
endif
if Oe[lju]<=837 then
if Oe[lju]<=824 then
call Zww(lju,bju,yju,pju)
else
call wOw(lju,bju,yju,pju,"when calling setXY in Entity, line 107")
endif
elseif Oe[lju]<=838 then
call Zww(lju,bju,yju,pju)
else
call J2u(0,2,lju,0,0,0,0,null,bju,yju,pju,0,0,0.,0.,0.,"when calling setXY in Entity, line 107",null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endfunction
function Fuw takes integer huw returns nothing
set Lt=Lt+1
if Lt==1 then
set Ht=huw
set Xt[huw]=0
else
set Xt[huw]=Jt
set Ct[Jt]=huw
set Xt[Ht]=huw
endif
set Ct[huw]=0
set Jt=huw
endfunction
function Txu takes integer fxu,string Rxu returns nothing
set Dd[Ad]=Rxu
set Ad=Ad+1
if Oe[fxu]==0 then
if fxu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_addToInactive","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_addToInactive on invalid object.","when calling error in ")
endif
endif
call Fuw(fxu)
set Ad=Ad-1
endfunction
function Yuw takes integer Ruw,string Tuw returns nothing
set Dd[Ad]=Tuw
set Ad=Ad+1
if Vt[Ruw]then
set Vt[Ruw]=false
call yxu(Ruw,"when calling removeFromActive in DupletListModule, line 21")
call Txu(Ruw,"when calling addToInactive in DupletListModule, line 22")
endif
set Ad=Ad-1
endfunction
function sxu takes integer uxu,string rxu returns nothing
set Dd[Ad]=rxu
set Ad=Ad+1
if Oe[uxu]==0 then
if uxu==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_DupletListModule_deactivate","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_DupletListModule_deactivate on invalid object.","when calling error in ")
endif
endif
call Yuw(uxu,"when calling deactivate in DupletListModule, line 18")
set Ad=Ad-1
endfunction
function wuw takes integer hww,string Fww_2 returns nothing
local real kww
local real jww
local integer xww_2
local integer vww
local integer mww
local integer Qww
local integer Www
local integer Eww
local integer Zww_2
local real Uww
local real Iww
local integer Pww
local integer Aww
local real Dww
local real Hww
local integer Jww
local integer Kww
local boolean Lww
local real Xww
local real Cww
local real Vww
local integer Bww
local integer Nww
local integer Mww
set Dd[Ad]=Fww_2
set Ad=Ad+1
if It[hww] and(not Zt[hww]) then
set xww_2=hww
set Lww=YOu(jt[xww_2],xt[xww_2],vt[xww_2])<1.5
else
set Lww=false
endif
if Lww then
call sxu(hww,"when calling deactivate in Entity, line 153")
else
set vww=hww
set Bww=vww
set mww=hww
set Xww=ht[mww]
set Cww=Ft[mww]
set Vww=kt[mww]
set Qww=hww
set ht[Bww]=fou(Xww,Cww,Vww,Kou(jt[Qww],xt[Qww],vt[Qww],Wt[hww]),Lf,Xf)
set Ft[vww]=Of
set kt[vww]=lf
set Nww=hww
set Www=hww
call qju(Nww,ht[Www],Ft[Www],kt[Www],"when calling setXY in Entity, line 156")
if xi then
set Eww=hww
set jww=xcu(ht[Eww],Ft[Eww],kt[Eww])
else
set jww=0.
endif
set kww=jww
set Zww_2=hww
set Iww=kt[Zww_2]
set Uww=Iww
if Uww>kww then
set Pww=hww
set Mww=Pww
set Aww=hww
set Hww=vt[Aww]
set Dww=Hww
set vt[Mww]=Dww+mt[hww]
call Xju(hww,true,"when calling setFlying in Entity, line 161")
else
set Jww=hww
set vt[Jww]=0.
set Kww=hww
set kt[Kww]=kww
call Xju(hww,false,"when calling setFlying in Entity, line 165")
endif
endif
set Ad=Ad-1
endfunction
function Qrw takes integer grw,string hrw returns nothing
local integer Frw
local integer krw
local real jrw
local real xrw
local unit vrw
local integer mrw
set Dd[Ad]=hrw
set Ad=Ad+1
set Frw=grw
set mrw=Frw
set vrw=Nt[grw]
set krw=grw
set xrw=kt[krw]
set jrw=xrw
set ht[mrw]=Rtu(vrw,jrw)
set Ft[Frw]=RR
set kt[Frw]=TR
call wuw(grw,"when calling update in Entity, line 227")
set Ad=Ad-1
set vrw=null
endfunction
function Xru takes player Pru,integer Aru,real Dru,real Hru,real Jru,real Kru returns unit
local unit Lru=CreateUnit(Pru,Aru,Dru,Hru,Fh(Kru))
call Nru(Lru,Jru,0.)
set Hg=Lru
set Lru=null
return Hg
endfunction
function Wbu takes integer Qbu returns nothing
call DWw(Qbu,9999.,Rp,Tp)
set Fp[Qbu]=false
set Gp[Qbu]=Ni
set gp[Qbu]=Ni
set hp[Qbu]=Ni
endfunction
function dNu takes string aNu returns integer
local integer nNu
set Dd[Ad]=aNu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set nNu=Ue
set Ie[nNu]=646
else
call tsw("Out of memory: Could not create WarningBuff.","when calling error in ")
set nNu=0
endif
else
set Ze=Ze-1
set nNu=Ee[Ze]
set Ie[nNu]=646
endif
set Ad=Ad-1
return nNu
endfunction
function mbu takes string xbu returns integer
local integer vbu
set Dd[Ad]=xbu
set Ad=Ad+1
set vbu=dNu("when calling WarningBuff in WarningBuff, line 21")
call Wbu(vbu)
set Ad=Ad-1
return vbu
endfunction
function TNu takes string fNu returns integer
local integer RNu
set Dd[Ad]=fNu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set RNu=Le
set Xe[RNu]=736
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set RNu=0
endif
else
set Ke=Ke-1
set RNu=Je[Ke]
set Xe[RNu]=736
endif
set Ad=Ad-1
return RNu
endfunction
function rP takes integer uP returns nothing
endfunction
function nRu takes integer qRu,string aRu returns nothing
set Dd[Ad]=aRu
set Ad=Ad+1
if Ie[qRu]==0 then
if qRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_onApply","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_onApply on invalid object.","when calling error in ")
endif
endif
call rP(qRu)
set Ad=Ad-1
endfunction
function ZWw takes integer vWw,integer mWw,string QWw returns nothing
local integer WWw
local integer EWw
set Dd[Ad]=QWw
set Ad=Ad+1
set uu[vWw]=mWw
if not KU(mWw) then
call qI(mWw,"when calling newBuffs in PresetBuffs, line 14")
endif
set WWw=lgw(iI(mWw),"when calling iterator in PresetBuffs, line 15")
loop
exitwhen not nGw(WWw)
set EWw=qGw(WWw)
if Ie[EWw]==Ie[vWw]then
set ru[EWw]=ru[vWw]
set uu[vWw]=0
call J4u(2,vWw,"when calling terminate in PresetBuffs, line 19",0,null)
call RGw(WWw,"when calling close in PresetBuffs, line 15")
set Ad=Ad-1
return
endif
endloop
call RGw(WWw,"when calling close in PresetBuffs, line 15")
call VU(mWw,vWw,"when calling addBuff in PresetBuffs, line 21")
call QRu(vWw,"when calling refresh in PresetBuffs, line 22")
call nRu(vWw,"when calling onApply in PresetBuffs, line 23")
set Ad=Ad-1
endfunction
function Wlu takes integer klu,integer jlu,string xlu returns nothing
local integer vlu
local unit mlu
local playerunitevent Qlu
set Dd[Ad]=xlu
set Ad=Ad+1
call ZWw(klu,jlu,"when calling apply in WarningBuff, line 28")
set Gp[klu]=Ni
set kp[klu]=Et[jlu]
set mlu=Nt[jlu]
set Qlu=EVENT_PLAYER_UNIT_DEATH
set vlu=TNu("when calling alloc_Closure in WarningBuff, line 31")
call cL(vlu)
set Yp[vlu]=klu
call fK(mlu,Qlu,vlu,"when calling add in WarningBuff, line 31")
set Ad=Ad-1
set mlu=null
set Qlu=null
endfunction
function yNu takes integer ONu,integer lNu,string bNu returns nothing
set Dd[Ad]=bNu
set Ad=Ad+1
if Ie[ONu]==0 then
if ONu==0 then
call tsw("Nullpointer exception when calling WarningBuff.WarningBuff_WarningBuff_apply","when calling error in ")
else
call tsw("Called WarningBuff.WarningBuff_WarningBuff_apply on invalid object.","when calling error in ")
endif
endif
call Wlu(ONu,lNu,"when calling apply in WarningBuff, line 27")
set Ad=Ad-1
endfunction
function ZH takes integer hH,real FH,real kH,real jH,integer xH,integer vH,string mH returns nothing
local unit QH
local unit WH
local unit EH
set Dd[Ad]=mH
set Ad=Ad+1
call J2u(0,0,3,hH,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Xru(rO[xH],vH,FH,kH,jH,0.),0.,0.,0.,0.,"when calling construct_UnitEntity in Builder, line 13",null,null)
set QH=Nt[hH]
call Osu(QH,Sw)
set WH=QH
call Osu(WH,1095331446)
set EH=WH
call Osu(EH,1097364080)
if vH==LO then
call ySu(Nt[hH],0.25)
endif
if GetLocalPlayer()==rO[xH]then
call PanCameraToTimed(itu(Nt[hH]),ctu(Nt[hH]),0.)
endif
call Etu(Nt[hH],"repairon")
call NQw(rO[xH],Nt[hH])
call yNu(mbu("when calling new_WarningBuff in Builder, line 24"),hH,"when calling apply in Builder, line 24")
call Qrw(hH,"when calling update in Builder, line 26")
call KSu(Nt[hH],FH,kH,jH)
set Ad=Ad-1
set QH=null
set WH=null
set EH=null
endfunction
function gH takes real nH,real dH,real fH,integer RH,integer TH,string YH returns integer
local integer GH
set Dd[Ad]=YH
set Ad=Ad+1
set GH=OTu("when calling Builder in Builder, line 13")
call ZH(GH,nH,dH,fH,RH,TH,"when calling construct_Builder in Builder, line 13")
set Ad=Ad-1
return GH
endfunction
function mQw takes player vQw returns string
return GetPlayerName(vQw)
endfunction
function ntu takes unit atu returns real
set ef=itu(atu)
set qf=ctu(atu)
set af=0.
return ef
endfunction
function pJu takes string bJu returns integer
local integer yJu
set Dd[Ad]=bJu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set yJu=ae
set ne[yJu]=683
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set yJu=0
endif
else
set qe=qe-1
set yJu=ee[qe]
set ne[yJu]=683
endif
set Ad=Ad-1
return yJu
endfunction
function ADw takes integer QDw,integer WDw,string EDw returns nothing
local integer ZDw
local integer UDw
local effect IDw
local integer PDw
set Dd[Ad]=EDw
set Ad=Ad+1
set ZDw=wO[kQw(yl[QDw])]
set UDw=WDw
if UDw==VO then
set SO[ZDw]=gH(ntu(Nt[pl[QDw]]),qf,af,ZDw,LO,"when calling new_Builder in Selector, line 47")
call fsu(Nt[SO[ZDw]],MO)
if fMw(mQw(yl[QDw]))=="cokemonkey11" or fMw(mQw(yl[QDw]))=="waterknight" then
set IDw=G5(I,wvu(SO[ZDw],"when calling getPos in Selector, line 50"),sf,tf)
set PDw=pJu("when calling alloc_Closure in Selector, line 51")
call VC(PDw)
set bl[PDw]=IDw
call gX(5.,PDw,"when calling doAfter in Selector, line 51")
call AKu(rl,yl[QDw],"when calling playForPlayer in Selector, line 52")
endif
elseif UDw==BO then
set SO[ZDw]=gH(ntu(Nt[pl[QDw]]),qf,af,ZDw,XO,"when calling new_Builder in Selector, line 54")
call fsu(Nt[SO[ZDw]],wl)
elseif UDw==NO then
set SO[ZDw]=gH(ntu(Nt[pl[QDw]]),qf,af,ZDw,CO,"when calling new_Builder in Selector, line 57")
call fsu(Nt[SO[ZDw]],ul)
endif
call fsu(Nt[SO[ZDw]],AO)
call J2u(0,0,0,0,0,0,pl[QDw],"when calling terminate in Selector, line 60",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
set IDw=null
endfunction
function SUw takes real iUw returns real
return iUw*iUw
endfunction
function VOu takes real JOu,real KOu,real LOu,real XOu,real COu returns real
return SquareRoot(SUw(XOu-JOu)+SUw(COu-KOu))
endfunction
function giu takes unit Yiu,integer Giu returns nothing
call SetUnitAnimationByIndex(Yiu,Giu)
endfunction
function ylw takes integer Olw,real llw returns nothing
local integer blw=bUw(Fh(llw)+90.5)
if blw>=180 then
set blw=179
elseif blw<0 then
set blw=0
endif
call giu(Zi[Olw],blw)
endfunction
function ZQu takes integer QQu,real WQu,string EQu returns nothing
set Dd[Ad]=EQu
set Ad=Ad+1
if Fa[QQu]==0 then
if QQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_setZAngle","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_setZAngle on invalid object.","when calling error in ")
endif
endif
call ylw(QQu,WQu)
set Ad=Ad-1
endfunction
function DZw takes integer IZw,real PZw,string AZw returns nothing
set Dd[Ad]=AZw
set Ad=Ad+1
call ZQu(Wi[IZw],PZw,"when calling setZAngle in Projectile, line 53")
set Ad=Ad-1
endfunction
function aHu takes integer pHu,real eHu,string qHu returns nothing
set Dd[Ad]=qHu
set Ad=Ad+1
if Oe[pHu]==0 then
if pHu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setZAngle","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setZAngle on invalid object.","when calling error in ")
endif
endif
call DZw(pHu,eHu,"when calling setZAngle in Projectile, line 52")
set Ad=Ad-1
endfunction
function xZw takes integer jZw returns real
return jO[jZw]
endfunction
function tHu takes integer uHu,string rHu returns real
local real sHu
set Dd[Ad]=rHu
set Ad=Ad+1
if Oe[uHu]==0 then
if uHu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_getSpeed","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_getSpeed on invalid object.","when calling error in ")
endif
endif
set sHu=xZw(uHu)
set Ad=Ad-1
return sHu
endfunction
function kF takes integer nF,real dF,real fF,real RF,real TF,player YF,real GF,real gF,string hF returns nothing
local integer FF
set Dd[Ad]=hF
set Ad=Ad+1
call wUw(nF,dF,fF,RF,TF,YF,GF,h,"when calling construct_Projectile in ArtilleryTower, line 44")
call VDu(nF,V+GetRandomReal(-10.,6.),"when calling setSpeed in ArtilleryTower, line 46")
call aHu(nF,vh(-45),"when calling setZAngle in ArtilleryTower, line 47")
set FF=nF
set vt[FF]=-tHu(nF,"when calling getSpeed in ArtilleryTower, line 48")
set M[nF]=gF
set Ad=Ad-1
endfunction
function wau takes string Nqu returns integer
local integer Mqu
set Dd[Ad]=Nqu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set Mqu=oe
set Oe[Mqu]=829
else
call tsw("Out of memory: Could not create ArtilleryMissile.","when calling error in ")
set Mqu=0
endif
else
set ce=ce-1
set Mqu=Se[ce]
set Oe[Mqu]=829
endif
set Ad=Ad-1
return Mqu
endfunction
function aF takes real cF,real oF,real OF,real lF,player bF,real yF,real pF,string eF returns integer
local integer qF
set Dd[Ad]=eF
set Ad=Ad+1
set qF=wau("when calling ArtilleryMissile in ArtilleryTower, line 44")
call kF(qF,cF,oF,OF,lF,bF,yF,pF,"when calling construct_ArtilleryMissile in ArtilleryTower, line 44")
set Ad=Ad-1
return qF
endfunction
function dau takes string aau returns integer
local integer nau
set Dd[Ad]=aau
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set nau=ae
set ne[nau]=657
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set nau=0
endif
else
set qe=qe-1
set nau=ee[qe]
set ne[nau]=657
endif
set Ad=Ad-1
return nau
endfunction
function kX takes integer hX,string FX returns integer
set Dd[Ad]=FX
set Ad=Ad+1
call gX(0.,hX,"when calling doAfter in ClosureTimers, line 22")
set Ad=Ad-1
return hX
endfunction
function lcu takes real Scu,real ccu,real ocu,real Ocu returns real
set Kd=Scu+ocu
set Ld=ccu+Ocu
return Kd
endfunction
function sou takes real uou,real rou returns real
set Nf=Cos(uou)*rou
set Mf=Sin(uou)*rou
return Nf
endfunction
function wou takes real Vcu,real Bcu,real Ncu,real Mcu returns real
set Xd=lcu(Vcu,Bcu,sou(Ncu,Mcu),Mf)
set Cd=Ld
return Xd
endfunction
function Gk takes integer lk,integer bk,string yk returns nothing
local integer pk
local real ek
local integer qk
local integer ak
local real nk
local real dk
local integer fk
local integer Rk
local real Tk
local real Yk
set Dd[Ad]=yk
set Ad=Ad+1
if bk==N then
set fk=uw[lk]
if VOu(ht[fk],Ft[fk],kt[fk],Osw(),Jd)>2950. then
set pk=dau("when calling alloc_Closure in ArtilleryTower, line 25")
call VC(pk)
set ww[pk]=uw[lk]
call kX(pk,"when calling nullTimer in ArtilleryTower, line 25")
endif
set Rk=uw[lk]
set ek=qlu(ht[Rk],Ft[Rk],kt[Rk],Osw(),Jd)
set qk=0
set ak=3+rw[uw[lk]]*3
loop
exitwhen qk>ak
set Tk=lcu(Osw(),Jd,GetRandomReal(-200.,200.),GetRandomReal(-200.,200.))
set Yk=Ld
set nk=Tk
set dk=Yk
call aF(cou(wou(nk,dk,ek,-1000.),Cd,1000.),Bd,Nd,50.+rw[uw[lk]]*50,Et[uw[lk]],ek,250.+rw[uw[lk]]*225,"when calling new_ArtilleryMissile in ArtilleryTower, line 32")
set qk=qk+1
endloop
endif
set Ad=Ad-1
endfunction
function jTu takes integer hTu,integer FTu,string kTu returns nothing
set Dd[Ad]=kTu
set Ad=Ad+1
if pe[hTu]==0 then
if hTu==0 then
call tsw("Nullpointer exception when calling OnCast.ClosureEvents_OnCast_fireEx","when calling error in ")
else
call tsw("Called OnCast.ClosureEvents_OnCast_fireEx on invalid object.","when calling error in ")
endif
endif
if pe[hTu]<=795 then
call Gk(hTu,FTu,"when calling ArtilleryTower_closure_impl in ClosureEvents, line 81")
else
call ADw(hTu,FTu,"when calling Selector_closure_impl in ClosureEvents, line 81")
endif
set Ad=Ad-1
endfunction
function kL takes integer gL,unit hL,string FL returns nothing
set Dd[Ad]=FL
set Ad=Ad+1
call jTu(gL,GetSpellAbilityId(),"when calling fireEx in ClosureEvents, line 79")
set Ad=Ad-1
endfunction
function w3 takes integer NM,unit MM returns nothing
call Wsu(MM)
call k5(F,stu(MM),cf)
endfunction
function ZTu takes integer QTu,unit WTu,string ETu returns nothing
set Dd[Ad]=ETu
set Ad=Ad+1
if pe[QTu]==0 then
if QTu==0 then
call tsw("Nullpointer exception when calling OnCastListener.ClosureEvents_OnCastListener_fire","when calling error in ")
else
call tsw("Called OnCastListener.ClosureEvents_OnCastListener_fire on invalid object.","when calling error in ")
endif
endif
if pe[QTu]<=796 then
if pe[QTu]<=793 then
call w3(QTu,WTu)
else
call kL(QTu,WTu,"when calling fire in ClosureEvents, line 56")
endif
elseif pe[QTu]<=798 then
call WL(QTu,WTu,"when calling fire in ClosureEvents, line 56")
else
call AL(QTu,WTu,"when calling fire in ClosureEvents, line 56")
endif
set Ad=Ad-1
endfunction
function iL takes string wL returns nothing
local unit uL
local integer rL
local integer sL
local integer tL
set Dd[Ad]=wL
set Ad=Ad+1
set uL=GetTriggerUnit()
set rL=GetSpellAbilityId()
if nEu(Ru,B0u(uL),"when calling has in ClosureEvents, line 187") then
set sL=kEu(Ru,B0u(uL),"when calling get in ClosureEvents, line 188")
loop
exitwhen not(sL!=0)
if ju[sL]==-1 or ju[sL]==rL then
call ZTu(sL,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 191")
endif
set sL=Fu[sL]
endloop
endif
if nEu(fu,rL,"when calling has in ClosureEvents, line 193") then
set tL=kEu(fu,rL,"when calling get in ClosureEvents, line 194")
loop
exitwhen not(tL!=0)
if xu[tL]==null or xu[tL]==uL then
call ZTu(tL,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 197")
endif
set tL=Fu[tL]
endloop
endif
set Ad=Ad-1
set uL=null
endfunction
function OK takes string oK returns nothing
set Dd[Ad]=oK
set Ad=Ad+1
call iL("when calling onSpellEffect in ClosureEvents, line 302")
set Ad=Ad-1
endfunction
function C1u takes nothing returns nothing
set Ad=0
call OK("ClosureEvents, line 302")
endfunction
function qXu takes string pXu returns integer
local integer eXu
set Dd[Ad]=pXu
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set eXu=ye
set pe[eXu]=801
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set eXu=0
endif
else
set be=be-1
set eXu=le[be]
set pe[eXu]=801
endif
set Ad=Ad-1
return eXu
endfunction
function AMw takes string UMw returns boolean
local integer IMw
local integer PMw
set Dd[Ad]=UMw
set Ad=Ad+1
set Xb=1093677389
set Cb=1097364080
set PMw=Xb
set IMw=qXu("when calling alloc_Closure in SuperCharge, line 10")
call HL(IMw)
call AK(PMw,IMw,"when calling onTargetCast in SuperCharge, line 10")
set Ad=Ad-1
return true
endfunction
function D1u takes nothing returns boolean
set Ad=0
return AMw("SuperCharge, line 1")
endfunction
function DNw takes nothing returns boolean
set Db[0]="Asshat!"
set Db[1]="gtfo"
set Db[2]="wtf?"
set Db[3]="really?"
set Db[4]="Dumbass!"
set Db[5]="STOP"
set Db[6]="Are you serious?"
set Db[7]="u wot m8"
set Db[8]="*poke*"
set Db[9]="wake up!"
set Db[10]="Heyyyy"
set Db[11]=":^)"
set Db[12]="^)^"
set Db[13]="Juicebag"
set Db[14]="whoopsie"
set Db[15]="monkey!"
set Db[16]="get shrekt"
set Db[17]="nou"
set Db[18]="reported!"
set Db[19]="Bengel.."
set Db[20]="calm down"
return true
endfunction
function Dk takes nothing returns boolean
set sw=0.030
set tw=1097691750
set iw=1097625443
set Sw=1097167976
set cw=OO[PLAYER_NEUTRAL_PASSIVE]
return true
endfunction
function Q2w takes timer x2w,real v2w,code m2w returns nothing
call TimerStart(x2w,v2w,true,m2w)
endfunction
function Dyw takes nothing returns boolean
set Bi=CreateTimer()
call j2w(Bi,100000.,null)
call Q2w(CreateTimer(),sw,ig)
return true
endfunction
function E0w takes nothing returns boolean
set At=0
set Dt=0
set Ht=0
set Jt=0
set Kt=0
set Lt=0
return true
endfunction
function EEu takes string QEu returns integer
local integer WEu
set Dd[Ad]=QEu
set Ad=Ad+1
if Wa==0 then
if Ea<32768 then
set Ea=Ea+1
set WEu=Ea
set Za[WEu]=887
else
call tsw("Out of memory: Could not create HashMap.","when calling error in ")
set WEu=0
endif
else
set Wa=Wa-1
set WEu=Qa[Wa]
set Za[WEu]=887
endif
set Ad=Ad-1
return WEu
endfunction
function Q3w takes integer m3w returns nothing
endfunction
function rqw takes integer uqw returns nothing
call Q3w(uqw)
endfunction
function wqw takes string New returns integer
local integer Mew
set Dd[Ad]=New
set Ad=Ad+1
set Mew=EEu("when calling HashMap in HashMap, line 7")
call rqw(Mew)
set Ad=Ad-1
return Mew
endfunction
function OTw takes string oTw returns boolean
set Dd[Ad]=oTw
set Ad=Ad+1
set qc=5000
set ac="0aUb1GLwR2kHvP3CQIM4npFs5iSW6tzAr7TNxo8JXVjy9OcdEfBKgqeuYDhmlZ"
set nc=wqw("when calling new_HashMap in LZW, line 16")
set dc=0
set Ad=Ad-1
return true
endfunction
function E1u takes nothing returns boolean
set Ad=0
return OTw("LZW, line 1")
endfunction
function Ebu takes nothing returns boolean
set jp=1747988814
set xp=192.
return true
endfunction
function Exw takes nothing returns boolean
set Co=-0.8
return true
endfunction
function BKu takes string CKu returns integer
local integer VKu
set Dd[Ad]=CKu
set Ad=Ad+1
if jn==0 then
if xn<32768 then
set xn=xn+1
set VKu=xn
set vn[VKu]=873
else
call tsw("Out of memory: Could not create SoundDefinition.","when calling error in ")
set VKu=0
endif
else
set jn=jn-1
set VKu=kn[jn]
set vn[VKu]=873
endif
set Ad=Ad-1
return VKu
endfunction
function bLw takes integer cLw,string oLw,boolean OLw,string lLw returns nothing
set Dd[Ad]=lLw
set Ad=Ad+1
set Hl[cLw]=Ngw("when calling new_LinkedList in SoundUtils, line 34")
set Kl[cLw]=10000
set Xl[cLw]=false
set Cl[cLw]=false
set Vl[cLw]=Yl
set Bl[cLw]=Gl
set Nl[cLw]=gl
set Jl[cLw]=oLw
set Ll[cLw]=OLw
set Ad=Ad-1
endfunction
function VJw takes string KJw,boolean LJw,string XJw returns integer
local integer CJw
set Dd[Ad]=XJw
set Ad=Ad+1
set CJw=BKu("when calling SoundDefinition in SoundUtils, line 45")
call bLw(CJw,KJw,LJw,"when calling construct_SoundDefinition in SoundUtils, line 45")
set Ad=Ad-1
return CJw
endfunction
function qPw takes string ePw returns boolean
set Dd[Ad]=ePw
set Ad=Ad+1
set AO=1227894832
set DO=1093677402
set HO=VJw(bb,false,"when calling new_SoundDefinition in Rocket, line 10")
set Ad=Ad-1
return true
endfunction
function F1u takes nothing returns boolean
set Ad=0
return qPw("Rocket, line 1")
endfunction
function Y0u takes string a0u returns nothing
local integer n0u
local integer d0u
local integer f0u
local integer R0u
local integer T0u
set Dd[Ad]=a0u
set Ad=Ad+1
set n0u=sww(GetTriggerUnit())
set d0u=lgw(Xy[n0u],"when calling iterator in TrooperTower, line 66")
loop
exitwhen not nGw(d0u)
set f0u=qGw(d0u)
call gB(Nt[f0u],Au,Du,Hu,Ju)
call VSu(Nt[f0u])
set T0u=f0u
set R0u=f0u
call J2u(0,1,T0u,0,0,0,0,null,ht[R0u],Ft[R0u],kt[R0u],0,0,0.,0.,0.,"when calling setXY in TrooperTower, line 69",null,0.,0.,0.,0.,null,null,null)
endloop
call RGw(d0u,"when calling close in TrooperTower, line 66")
set Ad=Ad-1
endfunction
function F4u takes nothing returns nothing
set Ad=0
call Y0u("TrooperTower, line 104")
endfunction
function Iku takes string Zku returns integer
local integer Uku
set Dd[Ad]=Zku
set Ad=Ad+1
if Sa==0 then
if ca<32768 then
set ca=ca+1
set Uku=ca
else
call tsw("Out of memory: Could not create Music.","when calling error in ")
set Uku=0
endif
else
set Sa=Sa-1
set Uku=ia[Sa]
endif
set Ad=Ad-1
return Uku
endfunction
function iMw takes string rMw,integer sMw,integer tMw returns string
return SubString(rMw,sMw,tMw)
endfunction
function uMw takes string wMw returns integer
return StringLength(wMw)
endfunction
function vMw takes string kMw,string jMw returns integer
local integer xMw=uMw(kMw)-uMw(jMw)
loop
exitwhen xMw<0
if iMw(kMw,xMw,xMw+uMw(jMw))==jMw then
return xMw
endif
set xMw=xMw-1
endloop
return -1
endfunction
function e0w takes integer b0w,integer y0w,string p0w returns nothing
set Rt[b0w]=p0w
call GetSoundFileDuration(p0w)
call iMw(p0w,vMw(p0w,"\\")+1,vMw(p0w,"."))
endfunction
function l0w takes integer S0w,string c0w,string o0w returns integer
local integer O0w
set Dd[Ad]=o0w
set Ad=Ad+1
set O0w=Iku("when calling Music in EndBoss, line 161")
call e0w(O0w,S0w,c0w)
set Ad=Ad-1
return O0w
endfunction
function J7 takes string H7 returns boolean
set Dd[Ad]=H7
set Ad=Ad+1
set st=1848651856
set tt=l0w(808464432,"Sound\\Music\\mp3Music\\Doom.mp3","when calling new_Music in EndBoss, line 10")
set St=1000
set ct=8.
set ot=.33
set Ot=.10
set Ad=Ad-1
return true
endfunction
function G1u takes nothing returns boolean
set Ad=0
return J7("EndBoss, line 1")
endfunction
function DKw takes string aKw returns nothing
local timer nKw
local integer dKw
local timer fKw
local timer RKw
local integer TKw
local real YKw
local real GKw
local integer gKw
local real hKw
local real FKw
local integer kKw
local real jKw
local real xKw
local integer vKw
local real mKw
local real QKw
local integer WKw
local real EKw
local real ZKw
local boolean UKw
local sound IKw
local real PKw
local real AKw
set Dd[Ad]=aKw
set Ad=Ad+1
set nKw=GetExpiredTimer()
set dKw=c2w(nKw,"when calling getData in SoundUtils, line 125")
if tb[dKw]!=null then
call AttachSoundToUnit(rb[dKw],tb[dKw])
endif
set TKw=dKw
set GKw=Ml[TKw]
set YKw=GKw
if YKw!=0. then
set gKw=dKw
set FKw=wb[gKw]
set hKw=FKw
set UKw=hKw!=0.
else
set UKw=false
endif
if UKw then
set IKw=rb[dKw]
set kKw=dKw
set xKw=Ml[kKw]
set jKw=xKw
set PKw=jKw
set vKw=dKw
set QKw=wb[vKw]
set mKw=QKw
set AKw=mKw
set WKw=dKw
set ZKw=ub[WKw]
set EKw=ZKw
call SetSoundPosition(IKw,PKw,AKw,EKw)
endif
if ib[dKw]!=null then
if GetLocalPlayer()==ib[dKw]then
call StartSound(rb[dKw])
endif
else
call StartSound(rb[dKw])
endif
call e2w(nKw,"when calling release in SoundUtils, line 135")
set fKw=b2w("when calling getTimer in SoundUtils, line 136")
call s2w(fKw,dKw,"when calling setData in SoundUtils, line 137")
set RKw=fKw
call j2w(RKw,Kl[sb[dKw]]*0.001,ng)
set Ad=Ad-1
set nKw=null
set fKw=null
set RKw=null
set IKw=null
endfunction
function G4u takes nothing returns nothing
set Ad=0
call DKw("SoundUtils, line 106")
endfunction
function Gh takes nothing returns boolean
return true
endfunction
function uRu takes string Mfu returns integer
local integer wRu
set Dd[Ad]=Mfu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set wRu=ae
set ne[wRu]=660
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set wRu=0
endif
else
set qe=qe-1
set wRu=ee[qe]
set ne[wRu]=660
endif
set Ad=Ad-1
return wRu
endfunction
function EI takes integer xI,string vI returns nothing
local unit mI
local integer QI
local integer WI
set Dd[Ad]=vI
set Ad=Ad+1
set mI=GetTriggerUnit()
if Ytu(mI)>0 then
set QI=sww(mI)
if QI!=0 and(not Ut[QI]) then
endif
set WI=uRu("when calling alloc_Closure in Buff, line 151")
call VC(WI)
set Nw[WI]=mI
set Mw[WI]=QI
call gX(0.01,WI,"when calling doAfter in Buff, line 151")
endif
set Ad=Ad-1
set mI=null
endfunction
function CEw takes integer XEw returns nothing
set TO=XEw
endfunction
function EEw takes string mEw,real QEw,player WEw returns nothing
call DisplayTimedTextToPlayer(WEw,0.,0.,QEw,mEw)
endfunction
function cMw takes string SMw returns integer
return S2I(SMw)
endfunction
function nMw takes string eMw,string qMw returns boolean
local integer aMw=uMw(eMw)
if uMw(qMw)>aMw then
return false
endif
return iMw(eMw,0,uMw(qMw))==qMw
endfunction
function LM takes integer DM returns nothing
local string HM=GetEventPlayerChatString()
local integer JM
local integer KM
if nMw(HM,"-d ") then
set JM=cMw(iMw(HM,3,4))
if JM>=0 and JM<5 then
set KM=JM
call CEw(KM)
call EEw("Loglevel adjusted to: "+nEw(KM),10.,GetTriggerPlayer())
endif
endif
endfunction
function Jfw takes item Hfw returns nothing
call RemoveItem(Hfw)
endfunction
function Lfw takes item Kfw returns integer
return GetItemTypeId(Kfw)
endfunction
function HVu takes string AVu returns integer
local integer DVu
set Dd[Ad]=AVu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set DVu=ae
set ne[DVu]=691
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set DVu=0
endif
else
set qe=qe-1
set DVu=ee[qe]
set ne[DVu]=691
endif
set Ad=Ad-1
return DVu
endfunction
function PVu takes string UVu returns integer
local integer IVu
set Dd[Ad]=UVu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set IVu=tq
set iq[IVu]=757
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set IVu=0
endif
else
set sq=sq-1
set IVu=rq[sq]
set iq[IVu]=757
endif
set Ad=Ad-1
return IVu
endfunction
function NL takes integer BL returns nothing
set mu[Qu]=BL
set Qu=Qu+1
endfunction
function oYu takes integer SYu,string cYu returns nothing
set Dd[Ad]=cYu
set Ad=Ad+1
if iq[SYu]==0 then
call tsw("Double free: object of type ForGroupCallback","when calling error in ")
else
set rq[sq]=SYu
set sq=sq+1
set iq[SYu]=0
endif
set Ad=Ad-1
endfunction
function fX takes integer nX,string dX returns nothing
set Dd[Ad]=dX
set Ad=Ad+1
call oYu(nX,"when calling ForGroupCallback in ClosureForGroups, line 3")
set Ad=Ad-1
endfunction
function uYu takes integer MTu,string wYu returns nothing
set Dd[Ad]=wYu
set Ad=Ad+1
if iq[MTu]==0 then
if MTu==0 then
call tsw("Nullpointer exception when calling ForGroupCallback.destroyForGroupCallback","when calling error in ")
else
call tsw("Called ForGroupCallback.destroyForGroupCallback on invalid object.","when calling error in ")
endif
endif
call fX(MTu,"when calling destroyForGroupCallback in ClosureForGroups, line 3")
set Ad=Ad-1
endfunction
function wX takes string ML returns nothing
set Dd[Ad]=ML
set Ad=Ad+1
call Zpw(vu)
set Qu=Qu-1
call uYu(mu[Qu],"when calling ForGroupCallback in ClosureForGroups, line 21")
set Ad=Ad-1
endfunction
function lX takes player cX,integer oX,string OX returns nothing
set Dd[Ad]=OX
set Ad=Ad+1
call NL(oX)
call GroupEnumUnitsOfPlayer(vu,cX,Wu)
call wX("when calling popCallback in ClosureForGroups, line 57")
set Ad=Ad-1
endfunction
function Y7w takes string n7w returns nothing
local integer d7w
local integer f7w
local player R7w
local real T7w
set Dd[Ad]=n7w
set Ad=Ad+1
call xKu(Uy,"when calling play in TownBell, line 19")
set Iy=utu(GetManipulatingUnit())
set R7w=OO[8]
set d7w=PVu("when calling alloc_Closure in TownBell, line 21")
call lX(R7w,d7w,"when calling forUnitsOfPlayer in TownBell, line 21")
set T7w=Zy
set f7w=HVu("when calling alloc_Closure in TownBell, line 29")
call VC(f7w)
call gX(T7w,f7w,"when calling doAfter in TownBell, line 29")
set Py=Py+1
set Ad=Ad-1
set R7w=null
endfunction
function M7w takes integer B7w,string N7w returns nothing
set Dd[Ad]=N7w
set Ad=Ad+1
if Lfw(GetManipulatedItem())==Qy then
call Jfw(GetManipulatedItem())
call Y7w("when calling onTownBell in TownBell, line 44")
endif
set Ad=Ad-1
endfunction
function EHu takes string QHu returns integer
local integer WHu
set Dd[Ad]=QHu
set Ad=Ad+1
if ja==0 then
if xa<32768 then
set xa=xa+1
set WHu=xa
set va[WHu]=780
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set WHu=0
endif
else
set ja=ja-1
set WHu=ka[ja]
set va[WHu]=780
endif
set Ad=Ad-1
return WHu
endfunction
function Xiu takes unit Jiu,real Kiu,real Liu returns nothing
call SetUnitPosition(Jiu,Kiu,Liu)
endfunction
function iB takes integer uB,integer rB,integer sB,integer tB returns integer
set sR=uB
set tR=rB
set iR=sB
return sR
endfunction
function lWw takes playercolor SWw returns integer
local integer cWw=0
local integer oWw=0
local integer OWw=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen oWw>OWw
if qO[oWw]==SWw then
set cWw=oWw
exitwhen true
endif
set oWw=oWw+1
endloop
return cWw
endfunction
function VV takes playercolor UV returns integer
local integer IV
local integer PV
local integer AV
local integer DV
local integer HV
local integer JV
local integer KV
local integer LV
local integer XV
local integer CV
if lWw(UV)<=Vu then
set DV=lWw(UV)
set HV=Bu[DV]
set JV=Nu[DV]
set KV=Mu[DV]
set IV=HV
set PV=JV
set AV=KV
else
set LV=iB(Ku,Lu,Xu,Cu)
set XV=tR
set CV=iR
set IV=LV
set PV=XV
set AV=CV
endif
set wR=IV
set uR=PV
set rR=AV
return wR
endfunction
function WB takes integer vB returns string
local integer mB=vB/16
local integer QB=vB-mB*16
return wr[mB]+wr[QB]
endfunction
function wB takes integer BV,integer NV,integer MV returns string
return "|cff"+WB(BV)+WB(NV)+WB(MV)
endfunction
function ZV takes player EV returns string
return wB(VV(iWw(EV)),uR,rR)+GetPlayerName(EV)+"|r"
endfunction
function BEu takes integer CEu,string VEu returns nothing
set Dd[Ad]=VEu
set Ad=Ad+1
if Aa[CEu]==0 then
call tsw("Double free: object of type EntityWithDist","when calling error in ")
else
set Ua[Ia]=CEu
set Ia=Ia+1
set Aa[CEu]=0
endif
set Ad=Ad-1
endfunction
function Qaw takes integer maw returns nothing
endfunction
function Faw takes integer gaw,string haw returns nothing
set Dd[Ad]=haw
set Ad=Ad+1
call Qaw(gaw)
call BEu(gaw,"when calling EntityWithDist in HealbackTower, line 86")
set Ad=Ad-1
endfunction
function JEu takes integer DEu,string HEu returns nothing
set Dd[Ad]=HEu
set Ad=Ad+1
if Aa[DEu]==0 then
if DEu==0 then
call tsw("Nullpointer exception when calling EntityWithDist.destroyEntityWithDist","when calling error in ")
else
call tsw("Called EntityWithDist.destroyEntityWithDist on invalid object.","when calling error in ")
endif
endif
call Faw(DEu,"when calling destroyEntityWithDist in HealbackTower, line 86")
set Ad=Ad-1
endfunction
function gdw takes integer Tdw,integer Ydw,string Gdw returns nothing
set Dd[Ad]=Gdw
set Ad=Ad+1
if sPu(vS[Tdw],"when calling size in HealbackTower, line 62")<mS[Tdw]then
call j3u(vS[Tdw],YS[Ydw],"when calling add in HealbackTower, line 63")
endif
call JEu(Ydw,"when calling EntityWithDist in HealbackTower, line 64")
set Ad=Ad-1
endfunction
function yAu takes integer lAu,integer bAu returns integer
return 0
endfunction
function jhw takes integer hhw,integer Fhw,string khw returns nothing
set Dd[Ad]=khw
set Ad=Ad+1
call j3u(io[hhw],yAu(So[hhw],Fhw),"when calling add in LinkedList, line 239")
set Ad=Ad-1
endfunction
function pPw takes integer lPw,integer bPw,string yPw returns nothing
set Dd[Ad]=yPw
set Ad=Ad+1
call QRu(bPw,"when calling refresh in RevivalSystem, line 16")
set Ad=Ad-1
endfunction
function TQw takes player fQw,playerstate RQw returns integer
return GetPlayerState(fQw,RQw)
endfunction
function yQw takes player OQw,playerstate lQw,integer bQw returns nothing
call SetPlayerState(OQw,lQw,TQw(OQw,lQw)+bQw)
endfunction
function dQw takes player aQw,integer nQw returns nothing
call yQw(aQw,PLAYER_STATE_RESOURCE_LUMBER,nQw)
endfunction
function oQw takes player SQw,integer cQw returns nothing
call yQw(SQw,PLAYER_STATE_RESOURCE_GOLD,cQw)
endfunction
function yyw takes integer oyw,integer Oyw returns player
local player lyw=rO[Oyw]
local player byw
call oQw(lyw,100000)
set byw=lyw
call dQw(byw,10000)
set Ig=byw
set lyw=null
set byw=null
return Ig
endfunction
function GIu takes integer RIu,integer TIu,string YIu returns nothing
set Dd[Ad]=YIu
set Ad=Ad+1
if va[RIu]==0 then
if RIu==0 then
call tsw("Nullpointer exception when calling LLItrClosure.LinkedList_LLItrClosure_run","when calling error in ")
else
call tsw("Called LLItrClosure.LinkedList_LLItrClosure_run on invalid object.","when calling error in ")
endif
endif
if va[RIu]<=778 then
if va[RIu]<=777 then
call yyw(RIu,TIu)
else
call gdw(RIu,TIu,"when calling HealbackTower_closure_impl in LinkedList, line 465")
endif
elseif va[RIu]<=779 then
call jhw(RIu,TIu,"when calling LinkedList_closure_impl in LinkedList, line 465")
else
call pPw(RIu,TIu,"when calling RevivalSystem_closure_impl in LinkedList, line 465")
endif
set Ad=Ad-1
endfunction
function FIu takes integer gIu,string hIu returns nothing
set Dd[Ad]=hIu
set Ad=Ad+1
if va[gIu]==0 then
call tsw("Double free: object of type LLItrClosure","when calling error in ")
else
set ka[ja]=gIu
set ja=ja+1
set va[gIu]=0
endif
set Ad=Ad-1
endfunction
function Sgw takes integer tgw,string igw returns nothing
set Dd[Ad]=igw
set Ad=Ad+1
call FIu(tgw,"when calling LLItrClosure in LinkedList, line 464")
set Ad=Ad-1
endfunction
function fIu takes integer nIu,string dIu returns nothing
set Dd[Ad]=dIu
set Ad=Ad+1
if va[nIu]==0 then
if nIu==0 then
call tsw("Nullpointer exception when calling LLItrClosure.destroyLLItrClosure","when calling error in ")
else
call tsw("Called LLItrClosure.destroyLLItrClosure on invalid object.","when calling error in ")
endif
endif
call Sgw(nIu,"when calling destroyLLItrClosure in LinkedList, line 464")
set Ad=Ad-1
endfunction
function bhw takes integer chw,integer ohw,string Ohw returns integer
local integer lhw
set Dd[Ad]=Ohw
set Ad=Ad+1
set lhw=Mc[co[chw]]
loop
exitwhen not(lhw!=co[chw])
call GIu(ohw,Bc[lhw],"when calling run in LinkedList, line 200")
set lhw=Mc[lhw]
endloop
call fIu(ohw,"when calling LLItrClosure in LinkedList, line 202")
set Ad=Ad-1
return chw
endfunction
function aPu takes integer yPu,integer pPu,string ePu returns integer
local integer qPu
set Dd[Ad]=ePu
set Ad=Ad+1
if yn[yPu]==0 then
if yPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_forEach","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_forEach on invalid object.","when calling error in ")
endif
endif
set qPu=bhw(yPu,pPu,"when calling forEach in LinkedList, line 197")
set Ad=Ad-1
return qPu
endfunction
function m5 takes string j5,real x5,real v5 returns effect
return AddSpecialEffect(j5,x5,v5)
endfunction
function vEw takes string jEw,real xEw returns nothing
call DisplayTimedTextToPlayer(lO,0.,0.,xEw,jEw)
endfunction
function OPw takes integer BIw,string NIw returns nothing
local integer MIw
local real wPw
local real uPw
local string rPw
local integer sPw
local integer tPw
local integer iPw
local integer SPw
local real cPw
local real oPw
set Dd[Ad]=NIw
set Ad=Ad+1
if Lfw(GetManipulatedItem())==1227894839 then
set MIw=wO[kQw(GetTriggerPlayer())]
set cPw=EOu(wvu(SO[MIw],"when calling getPos in RevivalSystem, line 10"),sf,tf)
set oPw=Ef
set wPw=cPw
set uPw=oPw
set rPw=""
set sPw=lgw(Mo,"when calling iterator in RevivalSystem, line 12")
loop
exitwhen not nGw(sPw)
set tPw=qGw(sPw)
if not tO[tPw]then
set rPw=rPw+" "+ZV(rO[tPw])
call Xiu(Nt[SO[tPw]],wou(wPw,uPw,Uh(GetRandomReal(0.,1.)),64.),Cd)
set SPw=iI(SO[tPw])
set iPw=EHu("when calling alloc_Closure in RevivalSystem, line 16")
call aPu(SPw,iPw,"when calling forEach in RevivalSystem, line 16")
call p5(m5(D,stu(Nt[SO[tPw]]),cf))
call EEw("|cffFFCC00>>|r You have been revived!",15.,rO[tPw])
set tO[tPw]=true
endif
endloop
call RGw(sPw,"when calling close in RevivalSystem, line 12")
if uMw(rPw)>0 then
set rPw=rPw+"."
call vEw("|cffFFCC00>>|r "+ZV(GetTriggerPlayer())+" |cff21C55Ahas revived the following players:|r "+rPw,15.)
endif
endif
set Ad=Ad-1
endfunction
function Q0u takes integer v0u,string m0u returns nothing
set Dd[Ad]=m0u
set Ad=Ad+1
call J2u(0,0,0,0,0,0,Vy[v0u],"when calling terminate in TrooperTower, line 47",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
endfunction
function P3u takes integer E3u,integer Z3u returns integer
local integer U3u=HS
local integer I3u
if E3u<U3u then
set I3u=E3u
else
set I3u=U3u
endif
set U3u=I3u
if Z3u<U3u then
set I3u=Z3u
else
set I3u=U3u
endif
set U3u=I3u
return U3u
endfunction
function DIw takes integer WIw,real EIw,real ZIw,player UIw,integer IIw,real PIw,string AIw returns nothing
set Dd[Ad]=AIw
set Ad=Ad+1
call J2u(0,0,3,WIw,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Iru(UIw,IIw,EIw,ZIw,PIw),0.,0.,0.,0.,"when calling construct_UnitEntity in Reinforcements, line 12",null,null)
call k5(U,EIw,ZIw)
call qSu(Nt[WIw],60.)
set Ad=Ad-1
endfunction
function hHu takes string GHu returns integer
local integer gHu
set Dd[Ad]=GHu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set gHu=oe
set Oe[gHu]=859
else
call tsw("Out of memory: Could not create Reinforcement.","when calling error in ")
set gHu=0
endif
else
set ce=ce-1
set gHu=Se[ce]
set Oe[gHu]=859
endif
set Ad=Ad-1
return gHu
endfunction
function QIw takes real hIw,real FIw,player kIw,integer jIw,real xIw,string vIw returns integer
local integer mIw
set Dd[Ad]=vIw
set Ad=Ad+1
set mIw=hHu("when calling Reinforcement in Reinforcements, line 12")
call DIw(mIw,hIw,FIw,kIw,jIw,xIw,"when calling construct_Reinforcement in Reinforcements, line 12")
set Ad=Ad-1
return mIw
endfunction
function dIw takes string cIw returns nothing
local integer oIw
local player OIw
local integer lIw
local integer bIw
local integer yIw
local real pIw
local integer eIw
local integer qIw
local integer aIw
local real nIw
set Dd[Ad]=cIw
set Ad=Ad+1
set oIw=OUw(Hyw()/80.+1.5)
set OIw=utu(GetManipulatingUnit())
set lIw=P3u(7,oIw)
set bIw=0
set yIw=lIw-1
loop
exitwhen bIw>yIw
set pIw=vh(bIw*(360./lIw))
call QIw(wou(Up,Ip,pIw,256.),Cd,OIw,IO,pIw,"when calling new_Reinforcement in Reinforcements, line 23")
set bIw=bIw+1
endloop
if oIw>=5 then
set eIw=P3u(7,oIw-4)
set qIw=0
set aIw=eIw-1
loop
exitwhen qIw>aIw
set nIw=vh(-15.+qIw*(360./eIw))
call QIw(wou(Up,Ip,nIw,256.),Cd,OIw,PO,nIw,"when calling new_Reinforcement in Reinforcements, line 29")
set qIw=qIw+1
endloop
endif
set Ad=Ad-1
set OIw=null
endfunction
function TIw takes integer fIw,string RIw returns nothing
set Dd[Ad]=RIw
set Ad=Ad+1
if Lfw(GetManipulatedItem())==UO then
call Jfw(GetManipulatedItem())
call dIw("when calling onReinforcements in Reinforcements, line 35")
endif
set Ad=Ad-1
endfunction
function cRu takes string iRu returns integer
local integer SRu
set Dd[Ad]=iRu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set SRu=ae
set ne[SRu]=661
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set SRu=0
endif
else
set qe=qe-1
set SRu=ee[qe]
set ne[SRu]=661
endif
set Ad=Ad-1
return SRu
endfunction
function XI takes integer DI,string HI returns nothing
local unit JI
local integer KI
local integer LI
set Dd[Ad]=HI
set Ad=Ad+1
set JI=GetTriggerUnit()
if sww(JI)!=0 then
set KI=sww(JI)
set LI=cRu("when calling alloc_Closure in Buff, line 161")
call VC(LI)
set wu[LI]=KI
call gX(0.01,LI,"when calling doAfter in Buff, line 161")
endif
set Ad=Ad-1
set JI=null
endfunction
function C1 takes nothing returns real
if ss!=0 and GetEventDamageSource()==Cr[ss] and GetTriggerUnit()==Xr[ss] and GetEventDamage()==Nr[ss]then
return Mr[ss]
endif
return GetEventDamage()
endfunction
function Jnw takes integer Hnw returns real
return aS[Hnw-1]
endfunction
function Cnw takes integer Xnw returns real
return dS[Xnw-1]
endfunction
function Lnw takes integer Knw returns integer
return nS[Knw-1]
endfunction
function Mou takes real Lou,real Xou,real Cou,real Vou,real Bou,real Nou returns real
set bR=Lou+Vou
set yR=Xou+Bou
set pR=Cou+Nou
return bR
endfunction
function pZw takes integer bZw,real yZw returns nothing
set vO[bZw]=yZw*yZw
set kO[bZw]=true
endfunction
function ADu takes integer UDu,real IDu,string PDu returns nothing
set Dd[Ad]=PDu
set Ad=Ad+1
if Oe[UDu]==0 then
if UDu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setRanged","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setRanged on invalid object.","when calling error in ")
endif
endif
call pZw(UDu,IDu)
set Ad=Ad-1
endfunction
function HOu takes real ZOu,real UOu,real IOu,real POu,real AOu,real DOu returns real
return SquareRoot(SUw(POu-ZOu)+SUw(AOu-UOu))
endfunction
function Ylu takes real alu,real nlu,real dlu,real flu,real Rlu,real Tlu returns real
return Uh(Atan2(Rlu-nlu,flu-alu))
endfunction
function gww takes integer oww_2,real Oww,real lww,real bww,real yww,string pww returns nothing
local real eww
local real qww
local real aww
local real nww
local integer dww
local integer fww
local integer Rww
local real Tww
local real Yww
local real Gww_2
set Dd[Ad]=pww
set Ad=Ad+1
set dww=oww_2
set eww=HOu(ht[dww],Ft[dww],kt[dww],Oww,lww,bww)/yww
set fww=oww_2
set qww=Ylu(ht[fww],Ft[fww],kt[fww],Oww,lww,bww)
set aww=0.
if xi then
set aww=xcu(Oww,lww,bww)
endif
if eww<1. then
set eww=1./yww
endif
set Gww_2=(-(mt[oww_2]*eww))/2.
set Rww=oww_2
set Yww=kt[Rww]
set Tww=Yww
set nww=Gww_2-Tww/eww+aww/eww
call vju(oww_2,cou(sou(qww,yww),Mf,nww),Bd,Nd,"when calling setVel in Entity, line 145")
set Ad=Ad-1
endfunction
function Hju takes integer Zju,real Uju,real Iju,real Pju,real Aju,string Dju returns nothing
set Dd[Ad]=Dju
set Ad=Ad+1
if Oe[Zju]==0 then
if Zju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_setTarget","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_setTarget on invalid object.","when calling error in ")
endif
endif
call gww(Zju,Uju,Iju,Pju,Aju,"when calling setTarget in Entity, line 134")
set Ad=Ad-1
endfunction
function slu takes real BOu,real NOu,real MOu,real wlu,real ulu,real rlu returns real
return SUw(wlu-BOu)+SUw(ulu-NOu)+SUw(rlu-MOu)
endfunction
function Gnw takes integer Onw,real lnw,real bnw,real ynw,player pnw,real enw,integer qnw,string anw returns nothing
local integer nnw
local integer dnw
local real fnw
local real Rnw
local real Tnw
local integer Ynw
set Dd[Ad]=anw
set Ad=Ad+1
call wUw(Onw,lnw,bnw,ynw,fS,pnw,Ylu(lnw,bnw,ynw,wvu(qnw,"when calling getPos in HealbackTower, line 104"),sf,tf),TS,"when calling construct_Projectile in HealbackTower, line 103")
call kQu(Wi[Onw],0,255,0,255,"when calling setColor in HealbackTower, line 105")
set gS[Onw]=enw
set hS[Onw]=qnw
set nnw=Onw
set FS[nnw]=lnw
set kS[nnw]=bnw
set jS[nnw]=ynw
set Ynw=Onw
set fnw=wvu(qnw,"when calling getPos in HealbackTower, line 109")
set Rnw=sf
set Tnw=tf
set dnw=Onw
set xS[Ynw]=slu(fnw,Rnw,Tnw,FS[dnw],kS[dnw],jS[dnw])
call Hju(Onw,Mou(Otu(Nt[qnw]),wf,uf,0.,0.,32.),yR,pR,19.25,"when calling setTarget in HealbackTower, line 110")
call kQu(Wi[Onw],215,255,215,168,"when calling setColor in HealbackTower, line 111")
call ADu(Onw,2000.,"when calling setRanged in HealbackTower, line 112")
set Ad=Ad-1
endfunction
function sZu takes string uZu returns integer
local integer rZu
set Dd[Ad]=uZu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set rZu=oe
set Oe[rZu]=831
else
call tsw("Out of memory: Could not create HealbackMissile.","when calling error in ")
set rZu=0
endif
else
set ce=ce-1
set rZu=Se[ce]
set Oe[rZu]=831
endif
set Ad=Ad-1
return rZu
endfunction
function rnw takes real Xaw,real Caw,real Vaw,player Baw,real Naw,integer Maw,string wnw returns integer
local integer unw
set Dd[Ad]=wnw
set Ad=Ad+1
set unw=sZu("when calling HealbackMissile in HealbackTower, line 103")
call Gnw(unw,Xaw,Caw,Vaw,Baw,Naw,Maw,"when calling construct_HealbackMissile in HealbackTower, line 103")
set Ad=Ad-1
return unw
endfunction
function GZu takes string TZu returns integer
local integer YZu
set Dd[Ad]=TZu
set Ad=Ad+1
if ja==0 then
if xa<32768 then
set xa=xa+1
set YZu=xa
set va[YZu]=778
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set YZu=0
endif
else
set ja=ja-1
set YZu=ka[ja]
set va[YZu]=778
endif
set Ad=Ad-1
return YZu
endfunction
function Bhw takes integer Xhw,string Chw returns nothing
local integer Vhw
set Dd[Ad]=Chw
set Ad=Ad+1
set Vhw=Mc[co[Xhw]]
loop
exitwhen not(Vhw!=co[Xhw])
set Vhw=Mc[Vhw]
call WUu(Nc[Vhw],"when calling LLEntry in LinkedList, line 332")
endloop
set Mc[co[Xhw]]=co[Xhw]
set Nc[co[Xhw]]=co[Xhw]
set oo[Xhw]=0
set Ad=Ad-1
endfunction
function HPu takes integer APu,string DPu returns nothing
set Dd[Ad]=DPu
set Ad=Ad+1
if yn[APu]==0 then
if APu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_clear","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_clear on invalid object.","when calling error in ")
endif
endif
call Bhw(APu,"when calling clear in LinkedList, line 328")
set Ad=Ad-1
endfunction
function Ehw takes integer xhw,integer vhw returns integer
local integer mhw=vhw
local integer Qhw=vhw
local integer Whw
loop
exitwhen not(Mc[mhw]!=co[xhw] and Mc[Mc[mhw]]!=co[xhw])
set mhw=Mc[Mc[mhw]]
set Qhw=Mc[Qhw]
endloop
set Whw=Mc[Qhw]
set Mc[Qhw]=co[xhw]
return Whw
endfunction
function PPu takes integer EPu,integer ZPu,string UPu returns integer
local integer IPu
set Dd[Ad]=UPu
set Ad=Ad+1
if yn[EPu]==0 then
if EPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_split","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_split on invalid object.","when calling error in ")
endif
endif
set IPu=Ehw(EPu,ZPu)
set Ad=Ad-1
return IPu
endfunction
function P0u takes integer I0u returns real
return I0u/Ny
endfunction
function ZYw takes integer QYw,real WYw,real EYw returns integer
return bUw(WYw-EYw)
endfunction
function AYw takes integer UYw,integer IYw,integer PYw returns integer
return ZYw(UYw,P0u(IYw),P0u(PYw))
endfunction
function Jdw takes integer Adw,integer Ddw,integer Hdw returns integer
return GS[Ddw]-GS[Hdw]
endfunction
function KYw takes integer DYw,integer HYw,integer JYw returns integer
return HYw-JYw
endfunction
function gUu takes integer fUu,integer RUu,integer TUu,string YUu returns integer
local integer GUu
set Dd[Ad]=YUu
set Ad=Ad+1
if Ka[fUu]==0 then
if fUu==0 then
call tsw("Nullpointer exception when calling Comparator.LinkedList_Comparator_compare","when calling error in ")
else
call tsw("Called Comparator.LinkedList_Comparator_compare on invalid object.","when calling error in ")
endif
endif
if Ka[fUu]<=697 then
if Ka[fUu]<=696 then
set GUu=Jdw(fUu,RUu,TUu)
else
set GUu=AYw(fUu,RUu,TUu)
endif
else
set GUu=KYw(fUu,RUu,TUu)
endif
set Ad=Ad-1
return GUu
endfunction
function Lhw takes integer Zhw,integer Uhw,integer Ihw,integer Phw,string Ahw returns integer
local integer Dhw
local integer Hhw
local integer Jhw
local integer Khw
set Dd[Ad]=Ahw
set Ad=Ad+1
set Dhw=Ihw
set Hhw=Phw
if Dhw==co[Zhw]then
set Ad=Ad-1
return Hhw
endif
if Hhw==co[Zhw]then
set Ad=Ad-1
return Dhw
endif
if gUu(Uhw,Bc[Dhw],Bc[Hhw],"when calling compare in LinkedList, line 281")<0 then
set Jhw=Dhw
set Khw=Dhw
set Dhw=Mc[Dhw]
else
set Jhw=Hhw
set Khw=Hhw
set Hhw=Mc[Hhw]
endif
loop
exitwhen not true
if Dhw==co[Zhw]then
set Mc[Khw]=Hhw
set Nc[Hhw]=Khw
exitwhen true
endif
if Hhw==co[Zhw]then
set Mc[Khw]=Dhw
set Nc[Dhw]=Khw
exitwhen true
endif
if gUu(Uhw,Bc[Dhw],Bc[Hhw],"when calling compare in LinkedList, line 299")<0 then
set Mc[Khw]=Dhw
set Nc[Dhw]=Khw
set Khw=Dhw
set Dhw=Mc[Dhw]
else
set Mc[Khw]=Hhw
set Nc[Hhw]=Khw
set Khw=Hhw
set Hhw=Mc[Hhw]
endif
endloop
set Ad=Ad-1
return Jhw
endfunction
function WPu takes integer kPu,integer jPu,integer xPu,integer vPu,string mPu returns integer
local integer QPu
set Dd[Ad]=mPu
set Ad=Ad+1
if yn[kPu]==0 then
if kPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_sortMerge","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_sortMerge on invalid object.","when calling error in ")
endif
endif
set QPu=Lhw(kPu,jPu,xPu,vPu,"when calling sortMerge in LinkedList, line 272")
set Ad=Ad-1
return QPu
endfunction
function ghw takes integer nhw,integer dhw,integer fhw,string Rhw returns integer
local integer Thw
local integer Yhw
local integer Ghw
set Dd[Ad]=Rhw
set Ad=Ad+1
if fhw==co[nhw] or Mc[fhw]==co[nhw]then
set Ad=Ad-1
return fhw
endif
set Thw=PPu(nhw,fhw,"when calling split in LinkedList, line 266")
set Yhw=ghw(nhw,dhw,fhw,"when calling sort in LinkedList, line 267")
set Thw=ghw(nhw,dhw,Thw,"when calling sort in LinkedList, line 268")
set Ghw=WPu(nhw,dhw,Yhw,Thw,"when calling sortMerge in LinkedList, line 269")
set Ad=Ad-1
return Ghw
endfunction
function FPu takes integer TPu,integer YPu,integer GPu,string gPu returns integer
local integer hPu
set Dd[Ad]=gPu
set Ad=Ad+1
if yn[TPu]==0 then
if TPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_sort","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_sort on invalid object.","when calling error in ")
endif
endif
set hPu=ghw(TPu,YPu,GPu,"when calling sort in LinkedList, line 262")
set Ad=Ad-1
return hPu
endfunction
function ahw takes integer yhw,integer phw,string ehw returns nothing
local integer qhw
set Dd[Ad]=ehw
set Ad=Ad+1
if phw!=0 and sPu(yhw,"when calling size in LinkedList, line 228")>1 then
set Mc[co[yhw]]=FPu(yhw,phw,Mc[co[yhw]],"when calling sort in LinkedList, line 229")
set Nc[Mc[co[yhw]]]=co[yhw]
set qhw=Mc[co[yhw]]
loop
exitwhen not(Mc[qhw]!=co[yhw])
set qhw=Mc[qhw]
endloop
set Nc[co[yhw]]=qhw
endif
set Ad=Ad-1
endfunction
function RPu takes integer nPu,integer dPu,string fPu returns nothing
set Dd[Ad]=fPu
set Ad=Ad+1
if yn[nPu]==0 then
if nPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_sortWith","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_sortWith on invalid object.","when calling error in ")
endif
endif
call ahw(nPu,dPu,"when calling sortWith in LinkedList, line 227")
set Ad=Ad-1
endfunction
function RZu takes string dZu returns integer
local integer fZu
set Dd[Ad]=dZu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set fZu=tq
set iq[fZu]=755
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set fZu=0
endif
else
set sq=sq-1
set fZu=rq[sq]
set iq[fZu]=755
endif
set Ad=Ad-1
return fZu
endfunction
function aX takes real bX,real yX,real pX,integer eX,string qX returns nothing
set Dd[Ad]=qX
set Ad=Ad+1
call NL(eX)
call GroupEnumUnitsInRange(vu,bX,yX,pX,Wu)
call wX("when calling popCallback in ClosureForGroups, line 83")
set Ad=Ad-1
endfunction
function ydw takes real Vnw,real Bnw,integer Nnw,real Mnw,string wdw returns integer
local integer udw
local integer rdw
local integer sdw
local real tdw
local real idw
local real Sdw
local integer cdw
local real odw
local real Odw
local real ldw
local real bdw
set Dd[Ad]=wdw
set Ad=Ad+1
set odw=Vnw
set Odw=Bnw
set ES=odw
set ZS=Odw
set ldw=Vnw
set bdw=Bnw
set tdw=ldw
set idw=bdw
set Sdw=Mnw
set udw=RZu("when calling alloc_Closure in HealbackTower, line 37")
call aX(tdw,idw,Sdw,udw,"when calling forUnitsInRange in HealbackTower, line 37")
call RPu(WS,US,"when calling sortWith in HealbackTower, line 58")
set rdw=Ngw("when calling new_LinkedList in HealbackTower, line 60")
set cdw=WS
set sdw=GZu("when calling alloc_Closure in HealbackTower, line 61")
set vS[sdw]=rdw
set mS[sdw]=Nnw
call aPu(cdw,sdw,"when calling forEach in HealbackTower, line 61")
call HPu(WS,"when calling clear in HealbackTower, line 66")
set Ad=Ad-1
return rdw
endfunction
function Pdw takes integer hdw,integer Fdw,real kdw,string jdw returns nothing
local real xdw
local real vdw
local real mdw
local integer Qdw
local integer Wdw
local integer Edw
local real Zdw
local real Udw
local real Idw
set Dd[Ad]=jdw
set Ad=Ad+1
set Zdw=Otu(Nt[Fdw])
set Udw=wf
set Idw=uf
set xdw=Zdw
set vdw=Udw
set mdw=Idw
set Qdw=ydw(EOu(xdw,vdw,mdw),Ef,Lnw(QS[hdw]),Cnw(QS[hdw]),"when calling getNearestBuilding in HealbackTower, line 75")
set Wdw=lgw(Qdw,"when calling iterator in HealbackTower, line 76")
loop
exitwhen not nGw(Wdw)
set Edw=qGw(Wdw)
call rnw(Mou(xdw,vdw,mdw,0.,0.,48.),yR,pR,Et[hdw],kdw,Edw,"when calling new_HealbackMissile in HealbackTower, line 77")
endloop
call RGw(Wdw,"when calling close in HealbackTower, line 76")
call xIu(Qdw,"when calling LinkedList in HealbackTower, line 78")
set Ad=Ad-1
endfunction
function bZu takes integer cZu,integer oZu,real OZu,string lZu returns nothing
set Dd[Ad]=lZu
set Ad=Ad+1
if Oe[cZu]==0 then
if cZu==0 then
call tsw("Nullpointer exception when calling HealbackTower.HealbackTower_HealbackTower_launchHealback","when calling error in ")
else
call tsw("Called HealbackTower.HealbackTower_HealbackTower_launchHealback on invalid object.","when calling error in ")
endif
endif
call Pdw(cZu,oZu,OZu,"when calling launchHealback in HealbackTower, line 72")
set Ad=Ad-1
endfunction
function Enw takes integer vnw,integer mnw,string Qnw returns nothing
local real Wnw
set Dd[Ad]=Qnw
set Ad=Ad+1
set Wnw=C1()
if Wnw>0. and Et[mnw]==rr then
call bZu(vnw,mnw,Wnw*Jnw(QS[vnw]),"when calling launchHealback in HealbackTower, line 84")
endif
set Ad=Ad-1
endfunction
function J4w takes integer H4w returns real
return 50.+40*py[H4w]
endfunction
function TCu takes integer dCu,string fCu returns real
local real RCu
set Dd[Ad]=fCu
set Ad=Ad+1
if Oe[dCu]==0 then
if dCu==0 then
call tsw("Nullpointer exception when calling ThermoTower.ThermoTower_ThermoTower_getDamage","when calling error in ")
else
call tsw("Called ThermoTower.ThermoTower_ThermoTower_getDamage on invalid object.","when calling error in ")
endif
endif
set RCu=J4w(dCu)
set Ad=Ad-1
return RCu
endfunction
function P4w takes integer E4w,integer Z4w,string U4w returns nothing
local timer I4w
set Dd[Ad]=U4w
set Ad=Ad+1
if yy[E4w]then
if GetUnitAbilityLevel(Nt[Z4w],ly)>0 then
call UnitDamageTarget(Nt[E4w],Nt[Z4w],TCu(E4w,"when calling getDamage in ThermoTower, line 19"),true,false,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
call eiu(Nt[Z4w],ly)
endif
call Osu(Nt[E4w],by)
set yy[E4w]=false
else
set I4w=b2w("when calling getTimer in ThermoTower, line 24")
call s2w(I4w,E4w,"when calling setData in ThermoTower, line 25")
call j2w(I4w,1.3,Rg)
set yy[E4w]=true
endif
set Ad=Ad-1
set I4w=null
endfunction
function gmu takes string Ymu returns integer
local integer Gmu
set Dd[Ad]=Ymu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set Gmu=oe
set Oe[Gmu]=830
else
call tsw("Out of memory: Could not create FlameMissile.","when calling error in ")
set Gmu=0
endif
else
set ce=ce-1
set Gmu=Se[ce]
set Oe[Gmu]=830
endif
set Ad=Ad-1
return Gmu
endfunction
function kZw takes integer hZw,real FZw returns nothing
set xO[hZw]=FZw
endfunction
function wHu takes integer BDu,real NDu,string MDu returns nothing
set Dd[Ad]=MDu
set Ad=Ad+1
if Oe[BDu]==0 then
if BDu==0 then
call tsw("Nullpointer exception when calling Projectile.Projectile_Projectile_setAcc","when calling error in ")
else
call tsw("Called Projectile.Projectile_Projectile_setAcc on invalid object.","when calling error in ")
endif
endif
call kZw(BDu,NDu)
set Ad=Ad-1
endfunction
function low takes integer wow,real uow,real row,real sow,real tow,real iow,real Sow,player cow,integer oow,string Oow returns nothing
set Dd[Ad]=Oow
set Ad=Ad+1
call wUw(wow,uow,row,sow,hi,cow,Uh(qlu(uow,row,sow,tow,iow)+GetRandomReal(-0.025,0.025)),gi,"when calling construct_Projectile in FlamethrowerTower, line 34")
call iQu(Wi[wow],0.2,"when calling setScale in FlamethrowerTower, line 36")
call VDu(wow,Sow+GetRandomReal(-0.5,0.5),"when calling setSpeed in FlamethrowerTower, line 37")
call ADu(wow,712.+GetRandomReal(-5.,5.),"when calling setRanged in FlamethrowerTower, line 38")
call wHu(wow,1.0195+GetRandomReal(-0.0025,0.0075),"when calling setAcc in FlamethrowerTower, line 39")
call kQu(Wi[wow],GetRandomInt(0,255),GetRandomInt(0,255),GetRandomInt(0,255),255,"when calling setColor in FlamethrowerTower, line 40")
call iQu(Wi[wow],0.75,"when calling setScale in FlamethrowerTower, line 41")
set ki[wow]=oow
set Ei[wow]=true
set Ad=Ad-1
endfunction
function Mcw takes real Dcw,real Hcw,real Jcw,real Kcw,real Lcw,real Xcw,player Ccw,integer Vcw,string Bcw returns integer
local integer Ncw
set Dd[Ad]=Bcw
set Ad=Ad+1
set Ncw=gmu("when calling FlameMissile in FlamethrowerTower, line 34")
call low(Ncw,Dcw,Hcw,Jcw,Kcw,Lcw,Xcw,Ccw,Vcw,"when calling construct_FlameMissile in FlamethrowerTower, line 34")
set Ad=Ad-1
return Ncw
endfunction
function Tcw takes integer Rcw returns real
return 6.45+Rcw*1.55
endfunction
function Wcu takes real vcu,real mcu,real Qcu returns real
set hR=vcu
set FR=mcu
set kR=hcu(vcu,mcu)+Qcu
return hR
endfunction
function Tow takes integer now,integer dow,string fow returns nothing
local integer Row
set Dd[Ad]=fow
set Ad=Ad+1
set Row=now
call Mcw(Wcu(EOu(ht[Row],Ft[Row],kt[Row]),Ef,58.),FR,kR,EOu(wvu(dow,"when calling getPos in FlamethrowerTower, line 21"),sf,tf),Ef,Tcw(ji[now]),Et[now],ji[now],"when calling new_FlameMissile in FlamethrowerTower, line 21")
set Ad=Ad-1
endfunction
function wiu takes unit Btu,string Ntu,widget Mtu returns boolean
return IssueTargetOrder(Btu,Ntu,Mtu)
endfunction
function Y9u takes integer n9u,integer d9u,string f9u returns nothing
local integer R9u
local integer T9u
set Dd[Ad]=f9u
set Ad=Ad+1
set R9u=lgw(Xy[n9u],"when calling iterator in TrooperTower, line 55")
loop
exitwhen not nGw(R9u)
set T9u=qGw(R9u)
call wiu(Nt[T9u],"smart",Nt[d9u])
endloop
call RGw(R9u,"when calling close in TrooperTower, line 55")
set Ad=Ad-1
endfunction
function IWu takes string ZWu returns integer
local integer UWu
set Dd[Ad]=ZWu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set UWu=Cq
set Vq[UWu]=752
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set UWu=0
endif
else
set Xq=Xq-1
set UWu=Lq[Xq]
set Vq[UWu]=752
endif
set Ad=Ad-1
return UWu
endfunction
function W3u takes integer x3u,integer v3u returns integer
local integer m3u=JS
local integer Q3u
if x3u>m3u then
set Q3u=x3u
else
set Q3u=m3u
endif
set m3u=Q3u
if v3u>m3u then
set Q3u=v3u
else
set Q3u=m3u
endif
set m3u=Q3u
return m3u
endfunction
function Fsw takes nothing returns boolean
return ii[ci]
endfunction
function Gsw takes integer Ysw returns nothing
set Si[ci]=Ysw
set ii[ci]=false
set ci=ci+1
endfunction
function How takes force Aow,code Dow returns nothing
call ForForce(Aow,Dow)
endfunction
function qvu takes integer pvu,string evu returns nothing
set Dd[Ad]=evu
set Ad=Ad+1
if Vq[pvu]==0 then
call tsw("Double free: object of type ForForceCallback","when calling error in ")
else
set Lq[Xq]=pvu
set Xq=Xq+1
set Vq[pvu]=0
endif
set Ad=Ad-1
endfunction
function Vsw takes integer Xsw,string Csw returns nothing
set Dd[Ad]=Csw
set Ad=Ad+1
call qvu(Xsw,"when calling ForForceCallback in Execute, line 8")
set Ad=Ad-1
endfunction
function Ovu takes integer cvu,string ovu returns nothing
set Dd[Ad]=ovu
set Ad=Ad+1
if Vq[cvu]==0 then
if cvu==0 then
call tsw("Nullpointer exception when calling ForForceCallback.destroyForForceCallback","when calling error in ")
else
call tsw("Called ForForceCallback.destroyForForceCallback on invalid object.","when calling error in ")
endif
endif
call Vsw(cvu,"when calling destroyForForceCallback in Execute, line 10")
set Ad=Ad-1
endfunction
function hsw takes string gsw returns nothing
set Dd[Ad]=gsw
set Ad=Ad+1
set ci=ci-1
call Ovu(Si[ci],"when calling ForForceCallback in Execute, line 34")
set Ad=Ad-1
endfunction
function Esw takes integer vsw,string msw returns boolean
local boolean Qsw
local boolean Wsw
set Dd[Ad]=msw
set Ad=Ad+1
call Gsw(vsw)
set Qsw=si
set si=true
call How(ti,NG)
set si=Qsw
call hsw("when calling popCallback in Execute, line 102")
set Wsw=Fsw()
set Ad=Ad-1
return Wsw
endfunction
function xsw takes integer ksw,string jsw returns nothing
set Dd[Ad]=jsw
set Ad=Ad+1
if not Esw(ksw,"when calling try in Execute, line 79") then
call tsw("execute: thread has crashed. caused by:\n| - "+ri,"when calling error in Execute, line 80")
endif
set Ad=Ad-1
endfunction
function tpw takes integer Cyw,string Vyw returns nothing
local integer Byw
local integer Nyw
local integer Myw
local integer wpw
local integer upw
local integer rpw
local integer spw
set Dd[Ad]=Vyw
set Ad=Ad+1
set Byw=256
set Nyw=W3u(8191,Mi)
set Myw=iS+Cyw
set wpw=W3u(0,Myw-Nyw)
set upw=W3u(0,Myw-wpw)
loop
exitwhen not(upw>0)
set rpw=P3u(upw,Byw)
set upw=upw-rpw
set spw=IWu("when calling alloc_Closure in GroupUtils, line 90")
set cS[spw]=rpw
call xsw(spw,"when calling execute in GroupUtils, line 90")
endloop
if iS>=Mi and(not SS) then
call UEw("Maximum number of GroupUtils groups ("+bfw(Mi)+") created. "+"All newly created groups will be non-recyclable.")
set SS=true
endif
set Ad=Ad-1
endfunction
function V2u takes integer K2u,string L2u returns nothing
local group X2u
local group C2u
if K2u==0 then
set Dd[Ad]=L2u
set Ad=Ad+1
if tS>0 then
call V2u(1,"when calling pop in GroupUtils, line 43")
set X2u=mg
elseif tS<=0 and iS<Mi then
call tpw(wS,"when calling createGroups in GroupUtils, line 45")
call V2u(1,"when calling pop in GroupUtils, line 46")
set X2u=mg
else
set X2u=CreateGroup()
endif
set Ad=Ad-1
set mg=X2u
set X2u=null
set C2u=null
return
elseif K2u==1 then
set Dd[Ad]=L2u
set Ad=Ad+1
set tS=tS-1
set C2u=sS[tS]
if sS[tS]!=null then
call YEu(rS,M0u(sS[tS]),S_u(true),"when calling put in GroupUtils, line 128")
else
if not oS then
call UEw("Groups on the GroupUtils stack shouldn't be destroyed! Use .release() instead.")
set oS=true
endif
call V2u(0,"when calling getGroup in GroupUtils, line 133")
set C2u=mg
endif
set Ad=Ad-1
set mg=C2u
set X2u=null
set C2u=null
return
endif
set X2u=null
set C2u=null
endfunction
function Byu takes integer Uyu,real Iyu,real Pyu,real Ayu,real Dyu,real Hyu,real Jyu,player Kyu,integer Lyu,unit Xyu,string Cyu returns nothing
local integer Vyu
set Dd[Ad]=Cyu
set Ad=Ad+1
call wUw(Uyu,Iyu,Pyu,Ayu,xp,Kyu,qlu(Iyu,Pyu,Ayu,Dyu,Hyu),k,"when calling construct_Projectile in WaveTower, line 40")
set Vyu=Uyu
call V2u(0,"when calling getGroup in WaveTower, line 36")
set mp[Vyu]=mg
call aHu(Uyu,0.,"when calling setZAngle in WaveTower, line 42")
call VDu(Uyu,Jyu,"when calling setSpeed in WaveTower, line 44")
call wHu(Uyu,0.975,"when calling setAcc in WaveTower, line 45")
set Qp[Uyu]=Lyu
set Ad=Ad-1
endfunction
function gNu takes string YNu returns integer
local integer GNu
set Dd[Ad]=YNu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set GNu=oe
set Oe[GNu]=837
else
call tsw("Out of memory: Could not create WaveMissile.","when calling error in ")
set GNu=0
endif
else
set ce=ce-1
set GNu=Se[ce]
set Oe[GNu]=837
endif
set Ad=Ad-1
return GNu
endfunction
function eyu takes real syu,real tyu,real iyu,real Syu,real cyu,real oyu,player Oyu,integer lyu,unit byu,string yyu returns integer
local integer pyu
set Dd[Ad]=yyu
set Ad=Ad+1
set pyu=gNu("when calling WaveMissile in WaveTower, line 40")
call Byu(pyu,syu,tyu,iyu,Syu,cyu,oyu,Oyu,lyu,byu,"when calling construct_WaveMissile in WaveTower, line 40")
set Ad=Ad-1
return pyu
endfunction
function cpu takes integer tpu,integer ipu,string Spu returns nothing
set Dd[Ad]=Spu
set Ad=Ad+1
call eyu(Wcu(EOu(wvu(tpu,"when calling getPos in WaveTower, line 18"),sf,tf),Ef,38.),FR,kR,EOu(wvu(ipu,"when calling getPos in WaveTower, line 18"),sf,tf),Ef,22.,Et[tpu],Wp[tpu],Nt[tpu],"when calling new_WaveMissile in WaveTower, line 18")
set Ad=Ad-1
endfunction
function j6w takes integer F6w,integer k6w returns nothing
endfunction
function eVu takes integer bVu,integer yVu,string pVu returns nothing
set Dd[Ad]=pVu
set Ad=Ad+1
if Oe[bVu]==0 then
if bVu==0 then
call tsw("Nullpointer exception when calling Tower.Tower_Tower_onAttack","when calling error in ")
else
call tsw("Called Tower.Tower_Tower_onAttack on invalid object.","when calling error in ")
endif
endif
if Oe[bVu]<=864 then
if Oe[bVu]<=863 then
if Oe[bVu]<=862 then
call j6w(bVu,yVu)
else
call Tow(bVu,yVu,"when calling onAttack in Tower, line 30")
endif
else
call Enw(bVu,yVu,"when calling onAttack in Tower, line 30")
endif
elseif Oe[bVu]<=866 then
if Oe[bVu]<=865 then
call P4w(bVu,yVu,"when calling onAttack in Tower, line 30")
else
call Y9u(bVu,yVu,"when calling onAttack in Tower, line 30")
endif
else
call cpu(bVu,yVu,"when calling onAttack in Tower, line 30")
endif
set Ad=Ad-1
endfunction
function Y6w takes integer q6w,string a6w returns nothing
local unit n6w
local unit d6w
local integer f6w
local integer R6w
local integer T6w
set Dd[Ad]=a6w
set Ad=Ad+1
set n6w=GetEventDamageSource()
set d6w=GetTriggerUnit()
if n6w!=d6w and sww(n6w)!=0 and xtu(d6w) then
set f6w=sww(n6w)
set T6w=Oe[f6w]
if T6w>=861 and T6w<=867 then
set R6w=f6w
if sww(d6w)!=0 then
call eVu(R6w,sww(d6w),"when calling onAttack in Tower, line 92")
else
call Etu(Nt[R6w],"stop")
endif
endif
endif
set Ad=Ad-1
set n6w=null
set d6w=null
endfunction
function Jsu takes unit Hsu returns integer
return GetUnitTypeId(Hsu)
endfunction
function N5w takes unit B5w returns nothing
if Jsu(B5w)==1747988563 or Jsu(B5w)==1747988564 then
call SetPlayerTechMaxAllowed(utu(B5w),1747989048,-1)
endif
endfunction
function cVu takes string iVu returns integer
local integer SVu
set Dd[Ad]=iVu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set SVu=ae
set ne[SVu]=690
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set SVu=0
endif
else
set qe=qe-1
set SVu=ee[qe]
set ne[SVu]=690
endif
set Ad=Ad-1
return SVu
endfunction
function b6w takes integer t6w,string i6w returns nothing
local unit S6w
local integer c6w
local integer o6w
local integer O6w
local boolean l6w
set Dd[Ad]=i6w
set Ad=Ad+1
set S6w=GetTriggerUnit()
call N5w(S6w)
set c6w=sww(S6w)
if c6w!=0 then
set O6w=Oe[c6w]
set l6w=O6w>=861 and O6w<=867
else
set l6w=false
endif
if l6w then
set o6w=cVu("when calling alloc_Closure in Tower, line 81")
call VC(o6w)
set my[o6w]=c6w
call gX(0.01,o6w,"when calling doAfter in Tower, line 81")
endif
set Ad=Ad-1
set S6w=null
endfunction
function Psu takes unit Isu returns real
return vh(GetUnitFacing(Isu))
endfunction
function Siu takes unit iiu returns nothing
call PauseUnit(iiu,true)
endfunction
function ktu takes unit Ftu returns nothing
call ShowUnit(Ftu,false)
endfunction
function jbu takes integer fbu returns nothing
local unit Rbu
local unit Tbu
local unit Ybu
local unit Gbu
local unit gbu
local unit hbu
local unit Fbu
local player kbu
if not Fp[fbu]then
set Fp[fbu]=true
set Tbu=Iru(kp[fbu],Jsu(Nt[uu[fbu]]),stu(Nt[uu[fbu]]),cf,Psu(Nt[uu[fbu]]))
call kSu(Tbu,stu(Nt[uu[fbu]]),cf)
set Rbu=Tbu
set Ybu=Rbu
call Hiu(Ybu,cw,false)
set Gbu=Ybu
call Osu(Gbu,1098282348)
set gbu=Gbu
call Siu(gbu)
set hbu=gbu
call ktu(hbu)
set Fbu=hbu
call ySu(Fbu,0.0001)
set kbu=Et[uu[fbu]]
set tO[wO[kQw(kbu)]]=false
set iO[wO[kQw(kbu)]]=iO[wO[kQw(kbu)]]+1
call vEw("|cffFFCC00>>|r "+ZV(kbu)+"  |cffCE2119has been killed!",20.)
endif
set Rbu=null
set Tbu=null
set Ybu=null
set Gbu=null
set gbu=null
set hbu=null
set Fbu=null
set kbu=null
endfunction
function qNu takes integer pNu,string eNu returns nothing
set Dd[Ad]=eNu
set Ad=Ad+1
if Ie[pNu]==0 then
if pNu==0 then
call tsw("Nullpointer exception when calling WarningBuff.WarningBuff_WarningBuff_onDeath","when calling error in ")
else
call tsw("Called WarningBuff.WarningBuff_WarningBuff_onDeath on invalid object.","when calling error in ")
endif
endif
call jbu(pNu)
set Ad=Ad-1
endfunction
function dbu takes integer abu,string nbu returns nothing
set Dd[Ad]=nbu
set Ad=Ad+1
if not iu[Yp[abu]]then
call qNu(Yp[abu],"when calling onDeath in WarningBuff, line 33")
endif
set Ad=Ad-1
endfunction
function AQw takes player IQw,player PQw returns boolean
return IsPlayerEnemy(IQw,PQw)
endfunction
function EQ takes integer mQ,string QQ returns nothing
local unit WQ
set Dd[Ad]=QQ
set Ad=Ad+1
set WQ=GetEventDamageSource()
if Dsu(Nt[uu[mQ]])<=1. and AQw(utu(WQ),Et[uu[mQ]]) and slu(Otu(WQ),wf,uf,wvu(uu[mQ],"when calling getPos in BossFour, line 25"),sf,tf)<jw and slu(Otu(WQ),wf,uf,wvu(uu[mQ],"when calling getPos in BossFour, line 26"),sf,tf)>42. and xw[mQ]+4.<Hyw() then
call Hju(uu[mQ],Otu(GetEventDamageSource()),wf,uf,8.,"when calling setTarget in BossFour, line 27")
call p5(G5(H,wvu(uu[mQ],"when calling getPos in BossFour, line 28"),sf,tf))
set xw[mQ]=Hyw()
endif
set Ad=Ad-1
set WQ=null
endfunction
function GE takes integer YE returns nothing
endfunction
function Ysu takes unit Rsu,unitstate Tsu returns real
return GetUnitState(Rsu,Tsu)
endfunction
function Bsu takes unit Vsu returns real
return Ysu(Vsu,UNIT_STATE_MAX_LIFE)
endfunction
function Lsu takes unit Ksu returns real
return Ysu(Ksu,UNIT_STATE_LIFE)
endfunction
function Qou takes real Fou,real kou,real jou,real xou,real vou,real mou returns real
set ZR=Fou-xou
set UR=kou-vou
set IR=jou-mou
return ZR
endfunction
function kgu takes string hgu returns integer
local integer Fgu
set Dd[Ad]=hgu
set Ad=Ad+1
if fq==0 then
if Rq<32768 then
set Rq=Rq+1
set Fgu=Rq
set Tq[Fgu]=627
else
call tsw("Out of memory: Could not create Active.","when calling error in ")
set Fgu=0
endif
else
set fq=fq-1
set Fgu=dq[fq]
set Tq[Fgu]=627
endif
set Ad=Ad-1
return Fgu
endfunction
function F4 takes integer h4 returns nothing
set ts=ts+1
if ts==1 then
set rs=h4
set is[h4]=0
else
set is[h4]=ss
set Ss[ss]=h4
set is[rs]=h4
endif
set Ss[h4]=0
set ss=h4
endfunction
function l4 takes integer O4 returns nothing
call F4(O4)
if O4==rs then
call j2w(Kr,0.,AG)
endif
endfunction
function o4 takes string S4 returns integer
local integer c4
set Dd[Ad]=S4
set Ad=Ad+1
set c4=kgu("when calling Active in DmgMod, line 71")
call l4(c4)
set Ad=Ad-1
return c4
endfunction
function r4 takes real V1,string B1 returns nothing
local unit N1
local real M1
local real w4
local integer u4
set Dd[Ad]=B1
set Ad=Ad+1
set N1=GetTriggerUnit()
set M1=Lsu(N1)
set w4=GetEventDamage()
if ss!=0 and GetEventDamageSource()==Cr[ss] and N1==Xr[ss] and w4==Nr[ss]then
set Mr[ss]=V1
else
set u4=o4("when calling new_Active in DmgMod, line 32")
set Xr[u4]=N1
set Lr[u4]=GetTriggeringTrigger()
set Cr[u4]=GetEventDamageSource()
set Vr[u4]=M1
set Nr[u4]=w4
set Mr[u4]=V1
set us[u4]=not htu(N1,Hr)
if us[u4]then
call Osu(N1,Hr)
set M1=Lsu(N1)
endif
set ws[u4]=M1-0.405<w4
if ws[u4]then
set M1=M1+w4
call SetWidgetLife(N1,M1)
endif
set Br[u4]=M1
endif
set Ad=Ad-1
set N1=null
endfunction
function Mlu takes integer Elu,string Zlu returns nothing
local real Ulu
local real Ilu
local real Plu
local unit Alu
local unit Dlu
local unit Hlu
local unit Jlu
local unit Klu
local unit Llu
local unit Xlu
local unit Clu
local player Vlu
local real Blu
local real Nlu
set Dd[Ad]=Zlu
set Ad=Ad+1
set Ulu=C1()
set Blu=wvu(uu[Elu],"when calling getPos in WarningBuff, line 37")
set Nlu=sf
set Ilu=Blu
set Plu=Nlu
if Gp[Elu]+15.>Ni then
call f1w(Qou(wvu(uu[Elu],"when calling getPos in WarningBuff, line 39"),sf,tf,-75.,0.,0.),UR,IR,GetRandomReal(-2.5,2.5),0.,GetRandomReal(8.,10.),"Spawn-Protection",10.,1.,155,185,55,255,"when calling new_TextTagEntity in WarningBuff, line 39")
call p5(G5(J,wvu(uu[Elu],"when calling getPos in WarningBuff, line 40"),sf,tf))
call r4(0.,"when calling modifyDamage in WarningBuff, line 41")
endif
if gp[Elu]+1.<Ni and Lsu(Nt[uu[Elu]])-Ulu<Bsu(Nt[uu[Elu]])/1.5 then
call f1w(Qou(wvu(uu[Elu],"when calling getPos in WarningBuff, line 43"),sf,tf,20.,0.,0.),UR,IR,GetRandomReal(-1.,1.),GetRandomReal(-1.,1.),GetRandomReal(7.,12.),"ATTENTION!!",15.,1.,255,25,25,255,"when calling new_TextTagEntity in WarningBuff, line 43")
call AKu(fp,Et[uu[Elu]],"when calling playForPlayer in WarningBuff, line 44")
set gp[Elu]=Ni
endif
if hp[Elu]+5.<Ni and Lsu(Nt[uu[Elu]])-Ulu<Bsu(Nt[uu[Elu]])/2. then
call PanCameraToTimedForPlayer(Et[uu[Elu]],Ilu,Plu,0.25)
call NQw(Et[uu[Elu]],Nt[uu[Elu]])
set hp[Elu]=Ni
endif
if Ulu>=Lsu(Nt[uu[Elu]])-1.0 then
call r4(0.,"when calling modifyDamage in WarningBuff, line 52")
if not Fp[Elu]then
set Fp[Elu]=true
set Alu=Nt[uu[Elu]]
set Dlu=Alu
call Wiu(Dlu,9999.)
set Hlu=Dlu
call Hiu(Hlu,cw,false)
set Jlu=Hlu
call Osu(Jlu,1098282348)
set Klu=Jlu
call Siu(Klu)
set Llu=Klu
call ktu(Llu)
set Xlu=Llu
call ySu(Xlu,0.0001)
set Clu=Iru(kp[Elu],Jsu(Nt[uu[Elu]]),stu(Alu),cf,Psu(Alu))
call kSu(Clu,stu(Alu),cf)
call Wsu(Clu)
set Vlu=Et[uu[Elu]]
set tO[wO[kQw(Vlu)]]=false
set iO[wO[kQw(Vlu)]]=iO[wO[kQw(Vlu)]]+1
call vEw("|cffFFCC00>>|r "+ZV(Vlu)+"  |cffCE2119has been killed!",20.)
endif
endif
set Ad=Ad-1
set Alu=null
set Dlu=null
set Hlu=null
set Jlu=null
set Klu=null
set Llu=null
set Xlu=null
set Clu=null
set Vlu=null
endfunction
function i4 takes real s4,string t4 returns nothing
set Dd[Ad]=t4
set Ad=Ad+1
call r4(C1()+s4,"when calling modifyDamage in DmgMod, line 54")
set Ad=Ad-1
endfunction
function wEw takes integer BWw,string NWw returns nothing
local real MWw
set Dd[Ad]=NWw
set Ad=Ad+1
set MWw=C1()
if MWw>=fO[BWw]then
call i4(-fO[BWw],"when calling modifyDamageBy in PresetBuffs, line 92")
set fO[BWw]=0.
call J4u(2,BWw,"when calling terminate in PresetBuffs, line 94",0,null)
else
call r4(0.,"when calling modifyDamage in PresetBuffs, line 96")
set fO[BWw]=fO[BWw]-MWw
endif
set Ad=Ad-1
endfunction
function NHw takes integer CHw,string VHw returns nothing
local integer BHw
set Dd[Ad]=VHw
set Ad=Ad+1
call wEw(CHw,"when calling defenseModifier in ShieldKit, line 22")
if fO[CHw]>0. then
set BHw=CHw
call f1w(fl[BHw],Rl[BHw],Tl[BHw],GetRandomReal(-2.,2.),0.,GetRandomReal(8.,12.),bfw(bUw(fO[CHw])),10.,1.,255,204,12,255,"when calling new_TextTagEntity in ShieldKit, line 24")
endif
set Ad=Ad-1
endfunction
function SP takes integer iP returns nothing
endfunction
function Ifu takes string Zfu returns integer
local integer Ufu
set Dd[Ad]=Zfu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set Ufu=oe
set Oe[Ufu]=858
else
call tsw("Out of memory: Could not create Tentacle.","when calling error in ")
set Ufu=0
endif
else
set ce=ce-1
set Ufu=Se[ce]
set Oe[Ufu]=858
endif
set Ad=Ad-1
return Ufu
endfunction
function Eh takes real Wh returns real
return Wh
endfunction
function Qh takes real mh returns real
return mh*X
endfunction
function jh takes real kh returns real
return kh
endfunction
function SSu takes unit tSu,real iSu returns nothing
call SetUnitPropWindow(tSu,jh(iSu))
endfunction
function sU takes integer NZ,real MZ,real wU,real uU,string rU returns nothing
set Dd[Ad]=rU
set Ad=Ad+1
call J2u(0,0,0,0,7,NZ,0,null,MZ,wU,uU,Ew,6,Up,Ip,Eh(GetRandomReal(0.,Qo)),"when calling construct_Creep in BossTwo, line 33",null,0.,0.,0.,0.,null,null,null)
call SSu(Nt[NZ],Qh(0))
set Ad=Ad-1
endfunction
function BZ takes real KZ,real LZ,real XZ,string CZ returns integer
local integer VZ
set Dd[Ad]=CZ
set Ad=Ad+1
set VZ=Ifu("when calling Tentacle in BossTwo, line 33")
call sU(VZ,KZ,LZ,XZ,"when calling construct_Tentacle in BossTwo, line 33")
set Ad=Ad-1
return VZ
endfunction
function Kh takes real Hh,real Jh returns real
return Hh+Jh
endfunction
function hou takes real Rou,real Tou,real You,real Gou,real gou returns real
set Zf=Rou+Gou
set Uf=Tou+gou
set If=You
return Zf
endfunction
function Olu takes real tlu,real ilu,real Slu,real clu,real olu returns real
set nf=hou(tlu,ilu,Slu,sou(clu,olu),Mf)
set df=Uf
set ff=If
return nf
endfunction
function nZ takes integer eZ,string qZ returns nothing
local integer aZ
set Dd[Ad]=qZ
set Ad=Ad+1
set Hw[eZ]=Hw[eZ]+C1()
if Hw[eZ]>500. then
set Hw[eZ]=Hw[eZ]-500.
set aZ=eZ
set Pw[aZ]=GetRandomInt(25,255)
set Aw[aZ]=GetRandomInt(25,255)
set Dw[aZ]=GetRandomInt(25,255)
call Etu(Nt[BZ(Olu(wvu(uu[eZ],"when calling getPos in BossTwo, line 29"),sf,tf,Kh(Psu(Nt[uu[eZ]]),GetRandomReal(-0.75,0.75)),GetRandomReal(64.,188.)),df,ff,"when calling new_Tentacle in BossTwo, line 29")],"stop")
endif
set Ad=Ad-1
endfunction
function GRu takes integer TRu,string YRu returns nothing
set Dd[Ad]=YRu
set Ad=Ad+1
if Ie[TRu]==0 then
if TRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_defenseModifier","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_defenseModifier on invalid object.","when calling error in ")
endif
endif
if Ie[TRu]<=643 then
if Ie[TRu]<=641 then
if Ie[TRu]<=640 then
call SP(TRu)
else
call GE(TRu)
endif
elseif Ie[TRu]<=642 then
call wEw(TRu,"when calling defenseModifier in Buff, line 89")
else
call EQ(TRu,"when calling defenseModifier in Buff, line 89")
endif
elseif Ie[TRu]<=645 then
if Ie[TRu]<=644 then
call NHw(TRu,"when calling defenseModifier in Buff, line 89")
else
call nZ(TRu,"when calling defenseModifier in Buff, line 89")
endif
elseif Ie[TRu]<=646 then
call Mlu(TRu,"when calling defenseModifier in Buff, line 89")
else
call SP(TRu)
endif
set Ad=Ad-1
endfunction
function HNw takes nothing returns string
return Db[GetRandomInt(0,20)]
endfunction
function fiw takes real tiw,real iiw,real Siw,string ciw,real oiw,real Oiw,real liw,real biw,integer yiw,integer piw,integer eiw,integer qiw,player aiw,string niw returns integer
local integer diw
set Dd[Ad]=niw
set Ad=Ad+1
set diw=ftw(tiw,iiw,Siw,ciw,oiw,Oiw,liw,biw,yiw,piw,eiw,qiw,"when calling createFText in FText, line 29")
call F4w(pi[diw],GetLocalPlayer()==aiw)
set Ad=Ad-1
return diw
endfunction
function siw takes real Atw,real Dtw,real Htw,real Jtw,real Ktw,string Ltw,real Xtw,real Ctw,integer Vtw,integer Btw,integer Ntw,integer Mtw,player wiw,string uiw returns integer
local integer riw
set Dd[Ad]=uiw
set Ad=Ad+1
set riw=fiw(Atw,Dtw,Htw,Ltw,Xtw,Ctw,Jtw,Ktw,Vtw,Btw,Ntw,Mtw,wiw,"when calling createFText in FText, line 25")
set Ad=Ad-1
return riw
endfunction
function TE takes integer dE,string fE returns nothing
local unit RE
set Dd[Ad]=fE
set Ad=Ad+1
set RE=GetTriggerUnit()
if utu(RE)!=OO[8]then
call k5(Po,stu(RE),cf)
call k5(Uo,stu(RE),cf)
if not(Oe[sww(RE)]==841) then
call i4(Bsu(RE)*0.30,"when calling modifyDamageBy in BossThree, line 25")
call siw(ntu(RE),qf,af,0.,.015,"-30% !!!",11.5,2.,255,0,0,255,lO,"when calling createFText in BossThree, line 26")
endif
endif
set Ad=Ad-1
set RE=null
endfunction
function pZ takes integer yZ returns nothing
endfunction
function tP takes integer sP returns nothing
endfunction
function vQ takes integer xQ returns nothing
endfunction
function RRu takes integer dRu,string fRu returns nothing
set Dd[Ad]=fRu
set Ad=Ad+1
if Ie[dRu]==0 then
if dRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_attackModifier","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_attackModifier on invalid object.","when calling error in ")
endif
endif
if Ie[dRu]<=643 then
if Ie[dRu]<=641 then
if Ie[dRu]<=640 then
call tP(dRu)
else
call TE(dRu,"when calling attackModifier in Buff, line 87")
endif
elseif Ie[dRu]<=642 then
call tP(dRu)
else
call vQ(dRu)
endif
elseif Ie[dRu]<=645 then
if Ie[dRu]<=644 then
call tP(dRu)
else
call pZ(dRu)
endif
else
call tP(dRu)
endif
set Ad=Ad-1
endfunction
function UQw takes player EQw,player ZQw returns boolean
return IsPlayerAlly(EQw,ZQw)
endfunction
function jI takes integer aI,string nI returns nothing
local unit dI
local unit fI
local integer RI
local integer TI
local integer YI
local integer GI
local integer gI
local integer hI
local integer FI
local integer kI
set Dd[Ad]=nI
set Ad=Ad+1
set dI=GetTriggerUnit()
set fI=GetEventDamageSource()
if sww(fI)!=0 and xtu(fI) then
set TI=sww(fI)
else
set TI=0
endif
set RI=TI
if sww(dI)!=0 and xtu(dI) then
set GI=sww(dI)
else
set GI=0
endif
set YI=GI
if mi and YI!=0 and RI!=0 and UQw(Et[YI],Et[RI]) or Et[YI]==Et[RI]then
if C1()>0.5 then
call r4(0.,"when calling modifyDamage in Buff, line 130")
if Qi then
call f1w(wvu(YI,"when calling getPos in Buff, line 132"),sf,tf,GetRandomReal(-2.,2.),GetRandomReal(-2.,2.),GetRandomReal(8.,10.),HNw(),10.,.8,GetRandomInt(150,250),GetRandomInt(125,150),GetRandomInt(125,150),255,"when calling new_TextTagEntity in Buff, line 132")
endif
endif
else
if KU(RI) then
set hI=cPu(iI(RI),"when calling staticItr in Buff, line 136")
loop
exitwhen not nGw(hI)
set gI=qGw(hI)
if not iu[gI]then
call RRu(gI,"when calling attackModifier in Buff, line 138")
endif
endloop
endif
if KU(YI) then
set kI=cPu(iI(YI),"when calling staticItr in Buff, line 141")
loop
exitwhen not nGw(kI)
set FI=qGw(kI)
if not iu[FI]then
call GRu(FI,"when calling defenseModifier in Buff, line 143")
endif
endloop
endif
endif
set Ad=Ad-1
set dI=null
set fI=null
endfunction
function Lgw takes integer Dgw,integer Hgw,string Jgw returns nothing
local integer Kgw
set Dd[Ad]=Jgw
set Ad=Ad+1
set Kgw=Mc[co[Dgw]]
loop
exitwhen not(Kgw!=co[Dgw])
if Bc[Kgw]==Hgw then
call sAu(Dgw,Kgw,"when calling removeEntry in LinkedList, line 117")
set Ad=Ad-1
return
endif
set Kgw=Mc[Kgw]
endloop
set Ad=Ad-1
endfunction
function MIu takes integer VIu,integer BIu,string NIu returns nothing
set Dd[Ad]=NIu
set Ad=Ad+1
if yn[VIu]==0 then
if VIu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_remove","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_remove on invalid object.","when calling error in ")
endif
endif
call Lgw(VIu,BIu,"when calling remove in LinkedList, line 113")
set Ad=Ad-1
endfunction
function hQw takes player gQw returns integer
return TQw(gQw,PLAYER_STATE_RESOURCE_GOLD)
endfunction
function iQw takes player rQw,playerstate sQw,integer tQw returns nothing
call SetPlayerState(rQw,sQw,tQw)
endfunction
function qQw takes player pQw,integer eQw returns nothing
call iQw(pQw,PLAYER_STATE_RESOURCE_LUMBER,eQw)
endfunction
function uQw takes player Mmw,integer wQw returns nothing
call iQw(Mmw,PLAYER_STATE_RESOURCE_GOLD,wQw)
endfunction
function xQw takes player jQw returns integer
return TQw(jQw,PLAYER_STATE_RESOURCE_LUMBER)
endfunction
function Cmw takes integer Umw,string Imw returns nothing
local integer Pmw
local integer Amw
local integer Dmw
local integer Hmw
local integer Jmw
local integer Kmw
local player Lmw
local player Xmw
set Dd[Ad]=Imw
set Ad=Ad+1
call MIu(Mo,Umw,"when calling remove in PlayerData, line 33")
if sPu(Mo,"when calling size in PlayerData, line 34")>0 then
set Pmw=OUw(hQw(rO[Umw])*1./sPu(Mo,"when calling size in PlayerData, line 35")*1.15)
set Amw=lgw(Mo,"when calling iterator in PlayerData, line 36")
loop
exitwhen not nGw(Amw)
set Dmw=qGw(Amw)
call oQw(rO[Dmw],Pmw)
endloop
call RGw(Amw,"when calling close in PlayerData, line 36")
set Hmw=OUw(xQw(rO[Umw])*1./sPu(Mo,"when calling size in PlayerData, line 39")*1.15)
set Jmw=lgw(Mo,"when calling iterator in PlayerData, line 40")
loop
exitwhen not nGw(Jmw)
set Kmw=qGw(Jmw)
call oQw(rO[Kmw],Hmw)
endloop
call RGw(Jmw,"when calling close in PlayerData, line 40")
endif
if SO[Umw]!=0 then
call J2u(0,0,0,0,0,0,SO[Umw],"when calling terminate in PlayerData, line 43",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
if cO[Umw]!=0 then
call J2u(0,0,0,0,0,0,cO[Umw],"when calling terminate in PlayerData, line 45",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set wO[kQw(rO[Umw])]=0
set Lmw=rO[Umw]
call uQw(Lmw,0)
set Xmw=Lmw
call qQw(Xmw,0)
if not Tt then
call vEw(ZV(rO[Umw])+" has left! Their resources have been distributed.",10.)
endif
set Ad=Ad-1
set Lmw=null
set Xmw=null
endfunction
function TDu takes integer fDu,string RDu returns nothing
set Dd[Ad]=RDu
set Ad=Ad+1
if fn[fDu]==0 then
call tsw("Double free: object of type PlayerData","when calling error in ")
else
set an[nn]=fDu
set nn=nn+1
set fn[fDu]=0
endif
set Ad=Ad-1
endfunction
function Nmw takes integer Vmw,string Bmw returns nothing
set Dd[Ad]=Bmw
set Ad=Ad+1
call Cmw(Vmw,"when calling PlayerData_onDestroy in PlayerData, line 32")
call TDu(Vmw,"when calling PlayerData in PlayerData, line 32")
set Ad=Ad-1
endfunction
function qDu takes integer pDu,string eDu returns nothing
set Dd[Ad]=eDu
set Ad=Ad+1
if fn[pDu]==0 then
if pDu==0 then
call tsw("Nullpointer exception when calling PlayerData.destroyPlayerData","when calling error in ")
else
call tsw("Called PlayerData.destroyPlayerData on invalid object.","when calling error in ")
endif
endif
call Nmw(pDu,"when calling destroyPlayerData in PlayerData, line 17")
set Ad=Ad-1
endfunction
function kmw takes integer hmw,string Fmw returns nothing
set Dd[Ad]=Fmw
set Ad=Ad+1
call qDu(wO[kQw(GetTriggerPlayer())],"when calling PlayerData in PlayerData, line 53")
set Ad=Ad-1
endfunction
function Dfw takes integer Ufw,real Ifw,real Pfw,real Afw returns item
return CreateItem(Ufw,Ifw,Pfw)
endfunction
function WU takes integer xU,unit vU,player mU,string QU returns nothing
set Dd[Ad]=QU
set Ad=Ad+1
if xU>0 then
call fiw(GetUnitX(vU)-20.,GetUnitY(vU),-30.,"+"+bfw(xU),Lw,Cw,0.,Xw,255,220,0,255,mU,"when calling createFText in Bounty, line 13")
endif
set Ad=Ad-1
endfunction
function eGu takes string yGu returns integer
local integer pGu
set Dd[Ad]=yGu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set pGu=ae
set ne[pGu]=667
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set pGu=0
endif
else
set qe=qe-1
set pGu=ee[qe]
set ne[pGu]=667
endif
set Ad=Ad-1
return pGu
endfunction
function pRw takes item bRw,integer yRw returns nothing
call SetItemUserData(bRw,yRw)
endfunction
function lM takes integer BN,string NN returns nothing
local unit MN
local item wM
local integer uM
local integer rM
local integer sM
local integer tM
local integer iM
local integer SM
local integer cM
local integer oM
local integer OM
set Dd[Ad]=NN
set Ad=Ad+1
set MN=GetKillingUnit()
if ir[BN]then
set wM=Dfw(yo,wvu(BN,"when calling getPos in Creep, line 57"),sf,tf)
call pRw(wM,OUw(Hyw()/17.))
set uM=eGu("when calling alloc_Closure in Creep, line 59")
call VC(uM)
set sr[uM]=wM
call gX(45.,uM,"when calling doAfter in Creep, line 59")
endif
if MN!=null and utu(MN)!=Et[BN]then
set rM=sPu(Mo,"when calling size in Creep, line 64")
if wO[kQw(utu(MN))]==0 then
set sM=tr[BN]/rM
if sM<=0 then
set sM=1
endif
set tM=lgw(Mo,"when calling iterator in Creep, line 69")
loop
exitwhen not nGw(tM)
set iM=qGw(tM)
if rO[iM]!=utu(MN) then
call oQw(rO[iM],sM)
call WU(sM,Nt[BN],rO[iM],"when calling showBountyTextTag in Creep, line 72")
endif
endloop
call RGw(tM,"when calling close in Creep, line 69")
elseif rM>0 and tr[BN]>0 then
set SM=tr[BN]/rM+ModuloInteger(tr[BN],rM)
if SM<1 then
set SM=1
endif
set cM=0
if rM>1 and tr[BN]-SM>0 then
set cM=OUw((tr[BN]-SM)/(rM-1.))
endif
call oQw(utu(MN),SM)
call WU(SM,Nt[BN],utu(MN),"when calling showBountyTextTag in Creep, line 82")
if cM>0 then
set oM=lgw(Mo,"when calling iterator in Creep, line 84")
loop
exitwhen not nGw(oM)
set OM=qGw(oM)
if rO[OM]!=utu(MN) then
call oQw(rO[OM],cM)
call WU(cM,Nt[BN],rO[OM],"when calling showBountyTextTag in Creep, line 87")
endif
endloop
call RGw(oM,"when calling close in Creep, line 84")
endif
endif
endif
set Ad=Ad-1
set MN=null
set wM=null
endfunction
function eU takes integer lU,string bU returns nothing
local integer yU
local integer pU
set Dd[Ad]=bU
set Ad=Ad+1
set yU=lgw(Mo,"when calling iterator in Boss, line 18")
loop
exitwhen not nGw(yU)
set pU=qGw(yU)
call dQw(rO[pU],1)
endloop
call RGw(yU,"when calling close in Boss, line 18")
if Kw[lU]!=null then
call p5(Kw[lU])
endif
call lM(lU,"when calling onDeath in Boss, line 22")
set Ad=Ad-1
endfunction
function mku takes integer xku,string vku returns nothing
set Dd[Ad]=vku
set Ad=Ad+1
if ta[xku]==0 then
call tsw("Double free: object of type EndBossFight","when calling error in ")
else
set ua[ra]=xku
set ra=ra+1
set ta[xku]=0
endif
set Ad=Ad-1
endfunction
function jqw takes hashtable hqw,integer Fqw,integer kqw returns boolean
return HaveSavedString(hqw,Fqw,kqw)
endfunction
function s3w takes integer u3w,integer r3w returns boolean
return jqw(Bb,u3w,r3w)
endfunction
function jXu takes integer gXu,integer hXu,string FXu returns boolean
local boolean kXu
set Dd[Ad]=FXu
set Ad=Ad+1
if Za[gXu]==0 then
if gXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_hasString","when calling error in ")
else
call tsw("Called Table.Table_Table_hasString on invalid object.","when calling error in ")
endif
endif
set kXu=s3w(gXu,hXu)
set Ad=Ad-1
return kXu
endfunction
function paw takes hashtable Oaw,integer law,integer baw,string yaw returns nothing
call SaveStr(Oaw,law,baw,yaw)
endfunction
function R3w takes integer n3w,integer d3w,string f3w returns nothing
call paw(Bb,n3w,d3w,f3w)
endfunction
function uCu takes integer BXu,integer NXu,string MXu,string wCu returns nothing
set Dd[Ad]=wCu
set Ad=Ad+1
if Za[BXu]==0 then
if BXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_saveString","when calling error in ")
else
call tsw("Called Table.Table_Table_saveString on invalid object.","when calling error in ")
endif
endif
call R3w(BXu,NXu,MXu)
set Ad=Ad-1
endfunction
function J0u takes string A0u,string D0u returns integer
local integer H0u
set Dd[Ad]=D0u
set Ad=Ad+1
set H0u=ZMw(A0u)
if not jXu(By,H0u,"when calling hasString in TypeCasting, line 24") then
call uCu(By,H0u,A0u,"when calling saveString in TypeCasting, line 25")
endif
set Ad=Ad-1
return H0u
endfunction
function cbw takes integer Mlw,real wbw,real ubw,real rbw,real sbw,string tbw,string ibw returns nothing
local integer Sbw
set Dd[Ad]=ibw
set Ad=Ad+1
set Zi[Mlw]=null
set Ui[Mlw]=null
set Sbw=Mlw
set Ii[Sbw]=255
set Pi[Sbw]=255
set Ai[Sbw]=255
set Di[Sbw]=255
set Zi[Mlw]=V2(EOu(wbw,ubw,rbw),Ef,sbw,"when calling get in Fx, line 52")
call XQu(Mlw,rbw,"when calling setZ in Fx, line 53")
call NQu(Mlw,tbw,"when calling setFx in Fx, line 54")
set Ad=Ad-1
endfunction
function Nlw takes real Jlw,real Klw,real Llw,real Xlw,string Clw,string Vlw returns integer
local integer Blw
set Dd[Ad]=Vlw
set Ad=Ad+1
set Blw=tWu("when calling Fx in Fx, line 51")
call cbw(Blw,Jlw,Klw,Llw,Xlw,Clw,"when calling construct_Fx7 in Fx, line 51")
set Ad=Ad-1
return Blw
endfunction
function DYu takes integer PYu,string AYu returns nothing
set Dd[Ad]=AYu
set Ad=Ad+1
if pq[PYu]==0 then
call tsw("Double free: object of type CallbackPeriodic","when calling error in ")
else
set lq[bq]=PYu
set bq=bq+1
set pq[PYu]=0
endif
set Ad=Ad-1
endfunction
function FC takes integer gC,string hC returns nothing
set Dd[Ad]=hC
set Ad=Ad+1
call e2w(Iu[gC],"when calling release in ClosureTimers, line 98")
set Ad=Ad-1
endfunction
function xC takes integer kC,string jC returns nothing
set Dd[Ad]=jC
set Ad=Ad+1
call FC(kC,"when calling CallbackPeriodic_onDestroy in ClosureTimers, line 97")
call DYu(kC,"when calling CallbackPeriodic in ClosureTimers, line 97")
set Ad=Ad-1
endfunction
function xYu takes integer kYu,string jYu returns nothing
set Dd[Ad]=jYu
set Ad=Ad+1
if pq[kYu]==0 then
if kYu==0 then
call tsw("Nullpointer exception when calling CallbackPeriodic.destroyCallbackPeriodic","when calling error in ")
else
call tsw("Called CallbackPeriodic.destroyCallbackPeriodic on invalid object.","when calling error in ")
endif
endif
call xC(kYu,"when calling destroyCallbackPeriodic in ClosureTimers, line 83")
set Ad=Ad-1
endfunction
function K1 takes integer P1,string A1 returns nothing
local integer D1
local integer H1
local integer J1
set Dd[Ad]=A1
set Ad=Ad+1
set D1=lgw(Zr[P1],"when calling iterator in DestroyerSummoner, line 100")
loop
exitwhen not nGw(D1)
set H1=qGw(D1)
set J1=H1
call uWu(Nlw(ht[J1],Ft[J1],kt[J1],0.,Y,"when calling new_Fx in DestroyerSummoner, line 101"),"when calling hiddenDestroy in DestroyerSummoner, line 101")
call Wsu(Nt[H1])
endloop
call RGw(D1,"when calling close in DestroyerSummoner, line 100")
call xIu(Zr[P1],"when calling LinkedList in DestroyerSummoner, line 103")
call xYu(Ir[P1],"when calling CallbackPeriodic in DestroyerSummoner, line 104")
call Yvu(Pr[P1],"when calling FText in DestroyerSummoner, line 105")
if Ur[P1]!=0 then
call Bmu(Ur[P1],"when calling Fx in DestroyerSummoner, line 107")
endif
set Ad=Ad-1
endfunction
function ygu takes integer lgu,string bgu returns nothing
set Dd[Ad]=bgu
set Ad=Ad+1
if nq[lgu]==0 then
call tsw("Double free: object of type FinalBossSummoning","when calling error in ")
else
set eq[qq]=lgu
set qq=qq+1
set nq[lgu]=0
endif
set Ad=Ad-1
endfunction
function m3 takes integer x3,string v3 returns nothing
set Dd[Ad]=v3
set Ad=Ad+1
call K1(x3,"when calling FinalBossSummoning_onDestroy in DestroyerSummoner, line 99")
call ygu(x3,"when calling FinalBossSummoning in DestroyerSummoner, line 99")
set Ad=Ad-1
endfunction
function ZGu takes integer WGu,string EGu returns nothing
set Dd[Ad]=EGu
set Ad=Ad+1
if nq[WGu]==0 then
if WGu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.destroyFinalBossSummoning","when calling error in ")
else
call tsw("Called FinalBossSummoning.destroyFinalBossSummoning on invalid object.","when calling error in ")
endif
endif
call m3(WGu,"when calling destroyFinalBossSummoning in DestroyerSummoner, line 16")
set Ad=Ad-1
endfunction
function q8 takes integer b8,string y8 returns nothing
local integer p8
local integer e8
set Dd[Ad]=y8
set Ad=Ad+1
if not pt[b8]then
set pt[b8]=true
set p8=lgw(bt[b8],"when calling iterator in EndBoss, line 130")
loop
exitwhen not nGw(p8)
set e8=qGw(p8)
call MIu(dt[e8],J0u("destroyerSummoner","when calling stringToIndex in EndBoss, line 131"),"when calling remove in EndBoss, line 131")
endloop
call RGw(p8,"when calling close in EndBoss, line 130")
call ZGu(yt[b8],"when calling FinalBossSummoning in EndBoss, line 132")
endif
set Ad=Ad-1
endfunction
function Tku takes integer fku,string Rku returns nothing
set Dd[Ad]=Rku
set Ad=Ad+1
if ta[fku]==0 then
if fku==0 then
call tsw("Nullpointer exception when calling EndBossFight.EndBoss_EndBossFight_endDestroyerSummoning","when calling error in ")
else
call tsw("Called EndBossFight.EndBoss_EndBossFight_endDestroyerSummoning on invalid object.","when calling error in ")
endif
endif
call q8(fku,"when calling endDestroyerSummoning in EndBoss, line 127")
set Ad=Ad-1
endfunction
function KFu takes string HFu returns integer
local integer JFu
set Dd[Ad]=HFu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set JFu=ae
set ne[JFu]=671
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set JFu=0
endif
else
set qe=qe-1
set JFu=ee[qe]
set ne[JFu]=671
endif
set Ad=Ad-1
return JFu
endfunction
function Luw takes integer Kuw returns boolean
return Bt[Kuw]!=0
endfunction
function Uxu takes integer Exu,string Zxu returns nothing
set Dd[Ad]=Zxu
set Ad=Ad+1
if ba[Exu]==0 then
call tsw("Double free: object of type Iterator","when calling error in ")
else
set oa[Oa]=Exu
set Oa=Oa+1
set ba[Exu]=0
endif
set Ad=Ad-1
endfunction
function orw takes integer crw returns nothing
endfunction
function rrw takes integer wrw,string urw returns nothing
set Dd[Ad]=urw
set Ad=Ad+1
call orw(wrw)
call Uxu(wrw,"when calling Iterator in DupletListModule, line 95")
set Ad=Ad-1
endfunction
function kxu takes integer hxu,string Fxu returns nothing
set Dd[Ad]=Fxu
set Ad=Ad+1
if ba[hxu]==0 then
if hxu==0 then
call tsw("Nullpointer exception when calling Iterator.destroyIterator","when calling error in ")
else
call tsw("Called Iterator.destroyIterator on invalid object.","when calling error in ")
endif
endif
call rrw(hxu,"when calling destroyIterator in DupletListModule, line 95")
set Ad=Ad-1
endfunction
function Muw takes integer Buw,string Nuw returns nothing
set Dd[Ad]=Nuw
set Ad=Ad+1
call kxu(Buw,"when calling Iterator in DupletListModule, line 107")
set Ad=Ad-1
endfunction
function Srw takes integer irw returns nothing
set Bt[irw]=At
endfunction
function Wxu takes string mxu returns integer
local integer Qxu
set Dd[Ad]=mxu
set Ad=Ad+1
if Oa==0 then
if la<32768 then
set la=la+1
set Qxu=la
set ba[Qxu]=767
else
call tsw("Out of memory: Could not create Iterator.","when calling error in ")
set Qxu=0
endif
else
set Oa=Oa-1
set Qxu=oa[Oa]
set ba[Qxu]=767
endif
set Ad=Ad-1
return Qxu
endfunction
function Juw takes string Duw returns integer
local integer Huw
set Dd[Ad]=Duw
set Ad=Ad+1
set Huw=Wxu("when calling Iterator in DupletListModule, line 95")
call Srw(Huw)
set Ad=Ad-1
return Huw
endfunction
function Uuw takes string Euw returns integer
local integer Zuw
set Dd[Ad]=Euw
set Ad=Ad+1
set Zuw=Juw("when calling new_Iterator in DupletListModule, line 93")
set Ad=Ad-1
return Zuw
endfunction
function Vuw takes integer Xuw returns integer
local integer Cuw=Bt[Xuw]
set Bt[Xuw]=Ct[Bt[Xuw]]
return Cuw
endfunction
function gEw takes string GEw returns nothing
call DisplayTimedTextToPlayer(lO,0.,0.,RO,GEw)
endfunction
function W0w takes string h0w returns nothing
local integer F0w
local integer k0w
local integer j0w
local integer x0w
local integer v0w
local integer m0w
local integer Q0w
set Dd[Ad]=h0w
set Ad=Ad+1
call gEw("|cff666666Victory!")
set F0w=Ht
loop
exitwhen not(F0w!=0)
set m0w=Oe[F0w]
if m0w>=839 and m0w<=871 then
set k0w=F0w
call ySu(Nt[k0w],0.)
call Siu(Nt[k0w])
endif
set F0w=Ct[F0w]
endloop
set j0w=Uuw("when calling iterator in EndGame, line 31")
loop
exitwhen not Luw(j0w)
set x0w=Vuw(j0w)
set Q0w=Oe[x0w]
if Q0w>=839 and Q0w<=871 then
set v0w=x0w
call ySu(Nt[v0w],0.)
call Siu(Nt[v0w])
endif
endloop
call Muw(j0w,"when calling close in EndGame, line 31")
set Tt=true
set Ad=Ad-1
endfunction
function X7 takes string K7 returns nothing
local integer L7
set Dd[Ad]=K7
set Ad=Ad+1
call vEw("|cffFFCC00>> |cffFFA53ACongratulations, you won!|r\n        |cff7B7B7BThe game will end in 20 seconds.",25.)
call W0w("when calling winGame in EndBoss, line 150")
set L7=KFu("when calling alloc_Closure in EndBoss, line 151")
call VC(L7)
call gX(20.,L7,"when calling doAfter in EndBoss, line 151")
set Ad=Ad-1
endfunction
function x8 takes integer k8,string j8 returns nothing
set Dd[Ad]=j8
set Ad=Ad+1
call Tku(k8,"when calling endDestroyerSummoning in EndBoss, line 140")
call xIu(bt[k8],"when calling LinkedList in EndBoss, line 141")
call X7("when calling onVictory in EndBoss, line 142")
set Ad=Ad-1
endfunction
function d8 takes integer a8,string n8 returns nothing
set Dd[Ad]=n8
set Ad=Ad+1
call x8(a8,"when calling EndBossFight_onDestroy in EndBoss, line 139")
call mku(a8,"when calling EndBossFight in EndBoss, line 139")
set Ad=Ad-1
endfunction
function eku takes integer yku,string pku returns nothing
set Dd[Ad]=pku
set Ad=Ad+1
if ta[yku]==0 then
if yku==0 then
call tsw("Nullpointer exception when calling EndBossFight.destroyEndBossFight","when calling error in ")
else
call tsw("Called EndBossFight.destroyEndBossFight on invalid object.","when calling error in ")
endif
endif
call d8(yku,"when calling destroyEndBossFight in EndBoss, line 108")
set Ad=Ad-1
endfunction
function l8 takes integer c8,integer o8,string O8 returns nothing
set Dd[Ad]=O8
set Ad=Ad+1
call MIu(bt[c8],o8,"when calling remove in EndBoss, line 135")
if sPu(bt[c8],"when calling size in EndBoss, line 136")==0 then
call eku(c8,"when calling EndBossFight in EndBoss, line 137")
endif
set Ad=Ad-1
endfunction
function hku takes integer Yku,integer Gku,string gku returns nothing
set Dd[Ad]=gku
set Ad=Ad+1
if ta[Yku]==0 then
if Yku==0 then
call tsw("Nullpointer exception when calling EndBossFight.EndBoss_EndBossFight_onBossDeath","when calling error in ")
else
call tsw("Called EndBossFight.EndBoss_EndBossFight_onBossDeath on invalid object.","when calling error in ")
endif
endif
call l8(Yku,Gku,"when calling onBossDeath in EndBoss, line 134")
set Ad=Ad-1
endfunction
function A8 takes integer I8,string P8 returns nothing
set Dd[Ad]=P8
set Ad=Ad+1
call eU(I8,"when calling onDeath in EndBoss, line 101")
call hku(ft[I8],I8,"when calling onBossDeath in EndBoss, line 102")
set Ad=Ad-1
endfunction
function XW takes integer KW,string LW returns nothing
set Dd[Ad]=LW
set Ad=Ad+1
call eU(KW,"when calling onDeath in BossThree, line 37")
call d5(Zo,wvu(KW,"when calling getPos in BossThree, line 38"),sf,tf)
set Ad=Ad-1
endfunction
function c3 takes integer i3,string S3 returns nothing
set Dd[Ad]=S3
set Ad=Ad+1
call lM(i3,"when calling onDeath in DestroyerSummoner, line 117")
set xr[i3]=false
set Ad=Ad-1
endfunction
function Ixw takes integer Uxw returns nothing
endfunction
function afu takes string efu returns integer
local integer qfu
set Dd[Ad]=efu
set Ad=Ad+1
if Ae==0 then
if De<32768 then
set De=De+1
set qfu=De
set He[qfu]=803
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set qfu=0
endif
else
set Ae=Ae-1
set qfu=Pe[Ae]
set He[qfu]=803
endif
set Ad=Ad-1
return qfu
endfunction
function SDu takes string tDu returns integer
local integer iDu
set Dd[Ad]=tDu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set iDu=oe
set Oe[iDu]=832
else
call tsw("Out of memory: Could not create PhysicsProjectile.","when calling error in ")
set iDu=0
endif
else
set ce=ce-1
set iDu=Se[ce]
set Oe[iDu]=832
endif
set Ad=Ad-1
return iDu
endfunction
function kvw takes real nvw,real dvw,real fvw,real Rvw,player Tvw,real Yvw,string Gvw,integer gvw,string hvw returns integer
local integer Fvw
set Dd[Ad]=hvw
set Ad=Ad+1
set Fvw=SDu("when calling PhysicsProjectile in PhysicsProjectile, line 12")
call Pvw(Fvw,nvw,dvw,fvw,Rvw,Tvw,Yvw,Gvw,gvw,"when calling construct_PhysicsProjectile in PhysicsProjectile, line 12")
set Ad=Ad-1
return Fvw
endfunction
function pW takes integer BQ,string NQ returns nothing
local integer MQ
local integer wW
local integer uW
local integer rW
local integer sW
local real tW
local real iW
local real SW
local player cW
local real oW
local string OW
local real lW
local real bW
local real yW
set Dd[Ad]=NQ
set Ad=Ad+1
call k5(yp,stu(Nt[BQ]),cf)
set MQ=0
loop
exitwhen MQ>5
set lW=fou(Otu(Nt[BQ]),wf,uf,0.,0.,64.)
set bW=Of
set yW=lf
set tW=lW
set iW=bW
set SW=yW
set cW=Et[BQ]
set oW=Uh(GetRandomReal(0.,1.))
set OW=W
set uW=afu("when calling alloc_Closure in BossOne, line 14")
call Ixw(uW)
set rW=kvw(tW,iW,SW,16.,cW,oW,OW,uW,"when calling new_PhysicsProjectile in BossOne, line 13")
call KDu(rW,GetRandomReal(1.25,3.5),"when calling setTimed in BossOne, line 15")
set sW=rW
call vju(sW,GetRandomReal(-6.,6.),GetRandomReal(-6.,6.),GetRandomReal(4.5,9.),"when calling setVel in BossOne, line 16")
set wW=sW
set No[wW]=0.605
set MQ=MQ+1
endloop
call eU(BQ,"when calling onDeath in BossOne, line 19")
set Ad=Ad-1
set cW=null
endfunction
function tNw takes integer rNw,string sNw returns nothing
set Dd[Ad]=sNw
set Ad=Ad+1
if Ib[rNw]!=null then
call p5(Ib[rNw])
endif
call lM(rNw,"when calling onDeath in Special, line 23")
set Ad=Ad-1
endfunction
function SXu takes string tXu returns integer
local integer iXu
set Dd[Ad]=tXu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set iXu=ae
set ne[iXu]=688
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set iXu=0
endif
else
set qe=qe-1
set iXu=ee[qe]
set ne[iXu]=688
endif
set Ad=Ad-1
return iXu
endfunction
function sXu takes string uXu returns integer
local integer rXu
set Dd[Ad]=uXu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set rXu=ae
set ne[rXu]=687
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set rXu=0
endif
else
set qe=qe-1
set rXu=ee[qe]
set ne[rXu]=687
endif
set Ad=Ad-1
return rXu
endfunction
function wXu takes string NLu returns integer
local integer MLu
set Dd[Ad]=NLu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set MLu=ae
set ne[MLu]=686
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set MLu=0
endif
else
set qe=qe-1
set MLu=ee[qe]
set ne[MLu]=686
endif
set Ad=Ad-1
return MLu
endfunction
function yBw takes integer NVw,string MVw returns nothing
local real wBw
local real uBw
local real rBw
local integer sBw
local integer tBw
local integer iBw
local real SBw
local real cBw
local real oBw
local integer OBw
local integer lBw
local integer bBw
set Dd[Ad]=MVw
set Ad=Ad+1
set SBw=wvu(NVw,"when calling getPos in SpecialTwo, line 18")
set cBw=sf
set oBw=tf
set wBw=SBw
set uBw=cBw
set rBw=oBw
if Jsu(Nt[NVw])==Qb then
set sBw=wXu("when calling alloc_Closure in SpecialTwo, line 20")
call VC(sBw)
set OBw=sBw
set Gb[OBw]=wBw
set gb[OBw]=uBw
set hb[OBw]=rBw
call gX(0.75,sBw,"when calling doAfter in SpecialTwo, line 20")
elseif Jsu(Nt[NVw])==Wb then
set tBw=sXu("when calling alloc_Closure in SpecialTwo, line 25")
call VC(tBw)
set lBw=tBw
set Fb[lBw]=wBw
set kb[lBw]=uBw
set jb[lBw]=rBw
call gX(0.75,tBw,"when calling doAfter in SpecialTwo, line 25")
elseif Jsu(Nt[NVw])==Eb then
set iBw=SXu("when calling alloc_Closure in SpecialTwo, line 29")
call VC(iBw)
set bBw=iBw
set xb[bBw]=wBw
set vb[bBw]=uBw
set mb[bBw]=rBw
call gX(0.75,iBw,"when calling doAfter in SpecialTwo, line 29")
endif
set Ad=Ad-1
endfunction
function iGu takes integer sGu,string tGu returns nothing
set Dd[Ad]=tGu
set Ad=Ad+1
if Oe[sGu]==0 then
if sGu==0 then
call tsw("Nullpointer exception when calling Creep.Creep_Creep_onDeath","when calling error in ")
else
call tsw("Called Creep.Creep_Creep_onDeath on invalid object.","when calling error in ")
endif
endif
if Oe[sGu]<=848 then
if Oe[sGu]<=846 then
if Oe[sGu]<=845 then
if Oe[sGu]<=842 then
call lM(sGu,"when calling onDeath in Creep, line 54")
else
call eU(sGu,"when calling onDeath in Creep, line 54")
endif
else
call pW(sGu,"when calling onDeath in Creep, line 54")
endif
elseif Oe[sGu]<=847 then
call XW(sGu,"when calling onDeath in Creep, line 54")
else
call eU(sGu,"when calling onDeath in Creep, line 54")
endif
elseif Oe[sGu]<=856 then
if Oe[sGu]<=850 then
if Oe[sGu]<=849 then
call A8(sGu,"when calling onDeath in Creep, line 54")
else
call c3(sGu,"when calling onDeath in Creep, line 54")
endif
else
call tNw(sGu,"when calling onDeath in Creep, line 54")
endif
elseif Oe[sGu]<=857 then
call yBw(sGu,"when calling onDeath in Creep, line 54")
else
call lM(sGu,"when calling onDeath in Creep, line 54")
endif
set Ad=Ad-1
endfunction
function qM takes integer pM,string eM returns nothing
set Dd[Ad]=eM
set Ad=Ad+1
call iGu(Sr[pM],"when calling onDeath in Creep, line 50")
set Ad=Ad-1
endfunction
function FVu takes string gVu returns integer
local integer hVu
set Dd[Ad]=gVu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set hVu=oe
set Oe[hVu]=861
else
call tsw("Out of memory: Could not create Tower.","when calling error in ")
set hVu=0
endif
else
set ce=ce-1
set hVu=Se[ce]
set Oe[hVu]=861
endif
set Ad=Ad-1
return hVu
endfunction
function Jrw takes integer Urw,unit Irw,real Prw,real Arw,real Drw,string Hrw returns nothing
set Dd[Ad]=Hrw
set Ad=Ad+1
call puw(Urw,utu(Irw),Prw,Arw,Drw,0.,"when calling construct_Entity5 in Entity, line 202")
set Nt[Urw]=null
call J2u(0,0,0,0,9,Urw,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Irw,0.,0.,0.,0.,"when calling setupUnitEntity in Entity, line 204",null,null)
set Ad=Ad-1
endfunction
function L6w takes integer H6w,unit J6w,string K6w returns nothing
set Dd[Ad]=K6w
set Ad=Ad+1
call Jrw(H6w,J6w,Otu(J6w),wf,uf,"when calling construct_UnitEntity2 in Tower, line 22")
set Ad=Ad-1
endfunction
function D6w takes unit I6w,string P6w returns integer
local integer A6w
set Dd[Ad]=P6w
set Ad=Ad+1
set A6w=FVu("when calling Tower in Tower, line 22")
call L6w(A6w,I6w,"when calling construct_Tower in Tower, line 22")
set Ad=Ad-1
return A6w
endfunction
function QVu takes string vVu returns integer
local integer mVu
set Dd[Ad]=vVu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set mVu=oe
set Oe[mVu]=871
else
call tsw("Out of memory: Could not create Wall.","when calling error in ")
set mVu=0
endif
else
set ce=ce-1
set mVu=Se[ce]
set Oe[mVu]=871
endif
set Ad=Ad-1
return mVu
endfunction
function b7w takes integer o7w,unit O7w,string l7w returns nothing
set Dd[Ad]=l7w
set Ad=Ad+1
call J2u(0,0,3,o7w,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,O7w,0.,0.,0.,0.,"when calling construct_UnitEntity in Tower, line 17",null,null)
set Ad=Ad-1
endfunction
function c7w takes unit t7w,string i7w returns integer
local integer S7w
set Dd[Ad]=i7w
set Ad=Ad+1
set S7w=QVu("when calling Wall in Tower, line 17")
call b7w(S7w,t7w,"when calling construct_Wall in Tower, line 17")
set Ad=Ad-1
return S7w
endfunction
function s6w takes integer M5w,string w6w returns nothing
local unit u6w
local integer r6w
set Dd[Ad]=w6w
set Ad=Ad+1
set u6w=GetConstructingStructure()
set r6w=Jsu(u6w)
if r6w==jy then
call D6w(u6w,"when calling new_Tower in Tower, line 72")
elseif r6w==xy or r6w==vy then
call c7w(u6w,"when calling new_Wall in Tower, line 74")
endif
set Ad=Ad-1
set u6w=null
endfunction
function B1w takes texttag K1w,integer L1w,integer X1w,integer C1w,integer V1w returns nothing
call SetTextTagColor(K1w,L1w,X1w,C1w,V1w)
endfunction
function Pou takes real Wou,real Eou,real Zou,real Uou,real Iou returns real
set QR=Wou-Uou
set WR=Eou-Iou
set ER=Zou
return QR
endfunction
function vtw takes real Rtw,real Ttw,real Ytw,string Gtw,real gtw,real htw,real Ftw,real ktw,string jtw returns integer
local integer xtw
set Dd[Ad]=jtw
set Ad=Ad+1
set xtw=ftw(Rtw,Ttw,Ytw,Gtw,gtw,htw,Ftw,ktw,Au,Du,Hu,Ju,"when calling createFText in FText, line 21")
set Ad=Ad-1
return xtw
endfunction
function Ptw takes real mtw,real Qtw,real Wtw,string Etw,real Ztw,string Utw returns integer
local integer Itw
set Dd[Ad]=Utw
set Ad=Ad+1
set Itw=vtw(mtw,Qtw,Wtw,Etw,Ztw,0.,pp,ep,"when calling createFText in FText, line 17")
set Ad=Ad-1
return Itw
endfunction
function lRw takes item ORw returns integer
return GetItemUserData(ORw)
endfunction
function KFw takes string FFw returns nothing
local item kFw
local integer jFw
local integer xFw
local integer vFw
local integer mFw
local texttag QFw
local texttag WFw
local integer EFw
local integer ZFw
local integer UFw
local texttag IFw
local texttag PFw
local integer AFw
local integer DFw
local integer HFw
local integer JFw
set Dd[Ad]=FFw
set Ad=Ad+1
set kFw=GetManipulatedItem()
if Lfw(kFw)==yo then
set jFw=lRw(kFw)
call k5(My,stu(GetManipulatingUnit()),cf)
call vEw("|cffFFCC00>> "+ZV(utu(GetManipulatingUnit()))+" picked up a coin!",10.)
set xFw=lgw(Mo,"when calling iterator in LumberAndCoinSystem, line 62")
loop
exitwhen not nGw(xFw)
set vFw=qGw(xFw)
call oQw(rO[vFw],jFw)
if Nt[SO[vFw]]!=null and xtu(Nt[SO[vFw]]) then
set mFw=Ptw(Pou(wvu(SO[vFw],"when calling getPos in LumberAndCoinSystem, line 65"),sf,tf,16.,0.),WR,ER,"+"+bfw(jFw),0.024/0.0023,"when calling createFText in LumberAndCoinSystem, line 65")
call Jvu(mFw,0.,.03,3.,"when calling setDynamic in LumberAndCoinSystem, line 66")
set QFw=pi[mFw]
call a4w(QFw,2.)
set WFw=QFw
call B1w(WFw,255,220,0,255)
call d5(P,wvu(SO[vFw],"when calling getPos in LumberAndCoinSystem, line 69"),sf,tf)
endif
endloop
call RGw(xFw,"when calling close in LumberAndCoinSystem, line 62")
endif
if Lfw(kFw)==po then
call k5(Io,stu(GetManipulatingUnit()),cf)
call vEw("|cffFFCC00>> "+ZV(utu(GetManipulatingUnit()))+" picked up a lumber bundle!",10.)
set EFw=lgw(Mo,"when calling iterator in LumberAndCoinSystem, line 73")
loop
exitwhen not nGw(EFw)
set ZFw=qGw(EFw)
call dQw(rO[ZFw],bo)
if Nt[SO[ZFw]]!=null and xtu(Nt[SO[ZFw]]) then
set UFw=Ptw(Pou(wvu(SO[ZFw],"when calling getPos in LumberAndCoinSystem, line 76"),sf,tf,16.,0.),WR,ER,"+"+bfw(bo),0.024/0.0023,"when calling createFText in LumberAndCoinSystem, line 76")
call Jvu(UFw,0.,.03,3.,"when calling setDynamic in LumberAndCoinSystem, line 77")
set IFw=pi[UFw]
call a4w(IFw,2.)
set PFw=IFw
call B1w(PFw,0,200,80,255)
endif
if xQw(rO[ZFw])>20 and sPu(Mo,"when calling size in LumberAndCoinSystem, line 80")>1 then
set AFw=bUw(xQw(rO[ZFw])*1./sPu(Mo,"when calling size in LumberAndCoinSystem, line 81"))
set DFw=ModuloInteger(xQw(rO[ZFw]),sPu(Mo,"when calling size in LumberAndCoinSystem, line 82"))
call qQw(rO[ZFw],DFw)
set HFw=lgw(Mo,"when calling iterator in LumberAndCoinSystem, line 84")
loop
exitwhen not nGw(HFw)
set JFw=qGw(HFw)
call dQw(rO[JFw],AFw)
endloop
call RGw(HFw,"when calling close in LumberAndCoinSystem, line 84")
call EEw("Due to inactivity your lumber has been dispersed among teammates!",10.,rO[ZFw])
endif
endloop
call RGw(EFw,"when calling close in LumberAndCoinSystem, line 73")
endif
set Ad=Ad-1
set kFw=null
set QFw=null
set WFw=null
set IFw=null
set PFw=null
endfunction
function tkw takes integer rkw,string skw returns nothing
set Dd[Ad]=skw
set Ad=Ad+1
call KFw("when calling grantCoinsAndLumber in LumberAndCoinSystem, line 96")
set Ad=Ad-1
endfunction
function Zfw takes integer Qfw,real Wfw,real Efw returns item
return Dfw(Qfw,Ycu(Wfw,Efw),jf,xf)
endfunction
function qAu takes string pAu returns integer
local integer eAu
set Dd[Ad]=pAu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set eAu=ae
set ne[eAu]=679
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set eAu=0
endif
else
set qe=qe-1
set eAu=ee[qe]
set ne[eAu]=679
endif
set Ad=Ad-1
return eAu
endfunction
function GFw takes string yFw returns nothing
local player pFw
local player eFw
local item qFw
local integer aFw
local integer nFw
local integer dFw
local integer fFw
local integer RFw
local integer TFw
local integer YFw
set Dd[Ad]=yFw
set Ad=Ad+1
set pFw=utu(GetDyingUnit())
set eFw=utu(GetKillingUnit())
if pFw==rr and eFw!=rr then
set sO[wO[kQw(eFw)]]=sO[wO[kQw(eFw)]]+1
set eo=eo+1
if eo>=qo then
set qo=qo+1.
if uO then
set qo=qo+3.
set qo=qo*1.015
endif
set eo=0
set qFw=Zfw(po,stu(GetDyingUnit()),cf)
set aFw=qAu("when calling alloc_Closure in LumberAndCoinSystem, line 43")
call VC(aFw)
set fo[aFw]=qFw
call gX(45.,aFw,"when calling doAfter in LumberAndCoinSystem, line 43")
set nFw=lgw(Mo,"when calling iterator in LumberAndCoinSystem, line 47")
loop
exitwhen not nGw(nFw)
set dFw=qGw(nFw)
if xQw(rO[dFw])>20 and sPu(Mo,"when calling size in LumberAndCoinSystem, line 48")>1 then
set fFw=bUw(xQw(rO[dFw])*1./sPu(Mo,"when calling size in LumberAndCoinSystem, line 49"))
set RFw=ModuloInteger(xQw(rO[dFw]),sPu(Mo,"when calling size in LumberAndCoinSystem, line 50"))
call qQw(rO[dFw],RFw)
set TFw=lgw(Mo,"when calling iterator in LumberAndCoinSystem, line 52")
loop
exitwhen not nGw(TFw)
set YFw=qGw(TFw)
call dQw(rO[YFw],fFw)
endloop
call RGw(TFw,"when calling close in LumberAndCoinSystem, line 52")
call EEw("Due to inactivity your lumber has been dispersed among teammates!",10.,rO[dFw])
endif
endloop
call RGw(nFw,"when calling close in LumberAndCoinSystem, line 47")
endif
endif
set Ad=Ad-1
set pFw=null
set eFw=null
set qFw=null
endfunction
function ukw takes integer MFw,string wkw returns nothing
set Dd[Ad]=wkw
set Ad=Ad+1
call GFw("when calling getExtraBounty in LumberAndCoinSystem, line 95")
set Ad=Ad-1
endfunction
function w5w takes integer N2w,string M2w returns nothing
set Dd[Ad]=M2w
set Ad=Ad+1
call J4u(3,4,null,hy[N2w],"when calling terminate in TowerBlockade, line 82")
set Ad=Ad-1
endfunction
function kCu takes integer hCu,string FCu returns nothing
set Dd[Ad]=FCu
set Ad=Ad+1
if Oe[hCu]==0 then
if hCu==0 then
call tsw("Nullpointer exception when calling BlockadeShip.TowerBlockade_BlockadeShip_terminateBuff","when calling error in ")
else
call tsw("Called BlockadeShip.TowerBlockade_BlockadeShip_terminateBuff on invalid object.","when calling error in ")
endif
endif
call w5w(hCu,"when calling terminateBuff in TowerBlockade, line 81")
set Ad=Ad-1
endfunction
function y5w takes integer O5w,string l5w returns nothing
local integer b5w
set Dd[Ad]=l5w
set Ad=Ad+1
set b5w=sww(GetTriggerUnit())
if b5w!=0 then
call kCu(b5w,"when calling terminateBuff in TowerBlockade, line 79")
endif
set Ad=Ad-1
endfunction
function TTu takes integer fTu,string RTu returns nothing
set Dd[Ad]=RTu
set Ad=Ad+1
if Xe[fTu]==0 then
if fTu==0 then
call tsw("Nullpointer exception when calling EventListener.ClosureEvents_EventListener_onEvent","when calling error in ")
else
call tsw("Called EventListener.ClosureEvents_EventListener_onEvent on invalid object.","when calling error in ")
endif
endif
if Xe[fTu]<=728 then
if Xe[fTu]<=724 then
if Xe[fTu]<=722 then
if Xe[fTu]<=721 then
if Xe[fTu]<=720 then
call jI(fTu,"when calling Buff_closure_impl in ClosureEvents, line 107")
else
call EI(fTu,"when calling Buff_closure_impl in ClosureEvents, line 107")
endif
else
call XI(fTu,"when calling Buff_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=723 then
call qM(fTu,"when calling Creep_closure_impl in ClosureEvents, line 107")
else
call LM(fTu)
endif
elseif Xe[fTu]<=726 then
if Xe[fTu]<=725 then
call ukw(fTu,"when calling LumberAndCoinSystem_closure_impl in ClosureEvents, line 107")
else
call tkw(fTu,"when calling LumberAndCoinSystem_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=727 then
call kmw(fTu,"when calling PlayerData_closure_impl in ClosureEvents, line 107")
else
call TIw(fTu,"when calling Reinforcements_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=732 then
if Xe[fTu]<=730 then
if Xe[fTu]<=729 then
call OPw(fTu,"when calling RevivalSystem_closure_impl in ClosureEvents, line 107")
else
call s6w(fTu,"when calling Tower_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=731 then
call b6w(fTu,"when calling Tower_closure_impl in ClosureEvents, line 107")
else
call Y6w(fTu,"when calling Tower_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=734 then
if Xe[fTu]<=733 then
call y5w(fTu,"when calling BlockadeShip_closure_impl in ClosureEvents, line 107")
else
call M7w(fTu,"when calling TownBell_closure_impl in ClosureEvents, line 107")
endif
elseif Xe[fTu]<=735 then
call Q0u(fTu,"when calling TrooperTower_closure_impl in ClosureEvents, line 107")
else
call dbu(fTu,"when calling WarningBuff_closure_impl in ClosureEvents, line 107")
endif
set Ad=Ad-1
endfunction
function pJ takes unit yJ returns boolean
return true
endfunction
function MK takes string XK returns nothing
local unit CK
local integer VK
local integer BK
local integer NK
set Dd[Ad]=XK
set Ad=Ad+1
set CK=GetTriggerUnit()
set VK=nJ(GetTriggerEventId(),"when calling toIntId in ClosureEvents, line 168")
if CK!=null and pJ(CK) and e_u(CK)>0 then
if Yu[e_u(CK)]!=0 then
set BK=Yu[e_u(CK)]
loop
exitwhen not(BK!=0)
if Gu[BK]==VK then
call TTu(BK,"when calling onEvent in ClosureEvents, line 175")
endif
set BK=gu[BK]
endloop
endif
endif
if Tu[VK]!=0 then
set NK=Tu[VK]
loop
exitwhen not(NK!=0)
call TTu(NK,"when calling onEvent in ClosureEvents, line 181")
set NK=gu[NK]
endloop
endif
set Ad=Ad-1
set CK=null
endfunction
function H1u takes nothing returns nothing
set Ad=0
call MK("ClosureEvents, line 239")
endfunction
function H4 takes nothing returns boolean
return true
endfunction
function HLw takes nothing returns boolean
set cb="Units\\Undead\\Abomination\\AbominationAlternateDeath1.wav"
set ob="Units\\Undead\\Abomination\\AbominationPissed5.wav"
set Ob="Units\\Undead\\UndeadAirBarge\\AirBargeDeath1.wav"
set lb="Units\\Critters\\DuneWorm\\DuneWormDeath1.wav"
set bb="Sound\\Dialogue\\GenericWarnings\\GenericWarningUnitAttack1.mp3"
set yb="Sound\\Dialogue\\HumanCampaign\\Human01\\H01Uther03.mp3"
set pb="Abilities\\Spells\\Human\\CallToArms\\HumanCallToArmsWhat1.wav"
set eb="Units\\Creeps\\Hydra\\HydraDeath1.wav"
set qb="Units\\Undead\\Skeleton\\SkeletonWhat2.wav"
return true
endfunction
function Hk takes nothing returns boolean
set yw=0
return true
endfunction
function YHu takes string RHu returns integer
local integer THu
set Dd[Ad]=RHu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set THu=Le
set Xe[THu]=728
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set THu=0
endif
else
set Ke=Ke-1
set THu=Je[Ke]
set Xe[THu]=728
endif
set Ad=Ad-1
return THu
endfunction
function pK takes eventid lK,integer bK,string yK returns integer
set Dd[Ad]=yK
set Ad=Ad+1
set Gu[bK]=nJ(lK,"when calling toIntId in ClosureEvents, line 110")
if Tu[Gu[bK]]!=0 then
set hu[Tu[Gu[bK]]]=bK
set gu[bK]=Tu[Gu[bK]]
endif
set Tu[Gu[bK]]=bK
set Ad=Ad-1
return bK
endfunction
function SIw takes string sIw returns boolean
local integer tIw
local playerunitevent iIw
set Dd[Ad]=sIw
set Ad=Ad+1
set UO=1227894838
set IO=1848651853
set PO=1848651854
set iIw=EVENT_PLAYER_UNIT_PICKUP_ITEM
set tIw=YHu("when calling alloc_Closure in Reinforcements, line 32")
call cL(tIw)
call pK(iIw,tIw,"when calling add in Reinforcements, line 32")
set Ad=Ad-1
set iIw=null
return true
endfunction
function I1u takes nothing returns boolean
set Ad=0
return SIw("Reinforcements, line 1")
endfunction
function Iqu takes nothing returns boolean
return true
endfunction
function R_u takes nothing returns unit
return sp
endfunction
function PEw takes string IEw returns nothing
call YEw(lO,0,IEw)
endfunction
function gTu takes integer YTu,string GTu returns nothing
set Dd[Ad]=GTu
set Ad=Ad+1
if Xe[YTu]==0 then
call tsw("Double free: object of type EventListener","when calling error in ")
else
set Je[Ke]=YTu
set Ke=Ke+1
set Xe[YTu]=0
endif
set Ad=Ad-1
endfunction
function lL takes integer oL returns nothing
local integer OL=Tu[Gu[oL]]
if OL==oL then
set Tu[Gu[oL]]=gu[oL]
elseif hu[oL]!=0 then
set gu[hu[oL]]=gu[oL]
endif
set hu[gu[oL]]=hu[oL]
set OL=Yu[Gu[oL]]
if OL==oL then
set Yu[Gu[oL]]=gu[oL]
elseif hu[oL]!=0 then
set gu[hu[oL]]=gu[oL]
endif
set hu[gu[oL]]=hu[oL]
set gu[oL]=0
set hu[oL]=0
endfunction
function pL takes integer bL,string yL returns nothing
set Dd[Ad]=yL
set Ad=Ad+1
call lL(bL)
call gTu(bL,"when calling EventListener in ClosureEvents, line 200")
set Ad=Ad-1
endfunction
function dTu takes integer aTu,string nTu returns nothing
set Dd[Ad]=nTu
set Ad=Ad+1
if Xe[aTu]==0 then
if aTu==0 then
call tsw("Nullpointer exception when calling EventListener.destroyEventListener","when calling error in ")
else
call tsw("Called EventListener.destroyEventListener on invalid object.","when calling error in ")
endif
endif
call pL(aTu,"when calling destroyEventListener in ClosureEvents, line 97")
set Ad=Ad-1
endfunction
function ZJ takes integer mJ,string QJ returns nothing
local integer WJ
local integer EJ
set Dd[Ad]=QJ
set Ad=Ad+1
if mJ>0 then
if Yu[mJ]!=0 then
call PEw("unregister unit has listeners. startid: "+bfw(mJ))
set WJ=Yu[mJ]
set Yu[mJ]=0
loop
exitwhen not(WJ!=0)
set EJ=WJ
set WJ=gu[WJ]
call dTu(EJ,"when calling EventListener in ClosureEvents, line 274")
endloop
endif
endif
set Ad=Ad-1
endfunction
function S3w takes integer t3w,integer i3w returns nothing
call RemoveSavedInteger(Bb,t3w,i3w)
endfunction
function QXu takes integer xXu,integer vXu,string mXu returns nothing
set Dd[Ad]=mXu
set Ad=Ad+1
if Za[xXu]==0 then
if xXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_removeInt","when calling error in ")
else
call tsw("Called Table.Table_Table_removeInt on invalid object.","when calling error in ")
endif
endif
call S3w(xXu,vXu)
set Ad=Ad-1
endfunction
function Bew takes integer Xew,integer Cew,string Vew returns nothing
set Dd[Ad]=Vew
set Ad=Ad+1
call QXu(Xew,Cew,"when calling removeInt in HashMap, line 24")
set Ad=Ad-1
endfunction
function bew takes integer oew,integer Oew,string lew returns nothing
set Dd[Ad]=lew
set Ad=Ad+1
call oaw(yS,oew,Oew,JWu(oew,Oew,"when calling count in HashList, line 17")-1)
set Ad=Ad-1
endfunction
function MWu takes integer VWu,integer BWu,string NWu returns nothing
set Dd[Ad]=NWu
set Ad=Ad+1
if ma[VWu]==0 then
if VWu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_decrOccurences","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_decrOccurences on invalid object.","when calling error in ")
endif
endif
call bew(VWu,BWu,"when calling decrOccurences in HashList, line 16")
set Ad=Ad-1
endfunction
function dew takes integer yew,integer pew,string eew returns nothing
local integer qew
local integer aew
set Dd[Ad]=eew
set Ad=Ad+1
call MWu(yew,Uqw(bS,yew,pew),"when calling decrOccurences in HashList, line 49")
set qew=pew
set aew=pS[yew]
loop
exitwhen qew>aew
call oaw(bS,yew,qew,Uqw(bS,yew,qew+1))
set qew=qew+1
endloop
set pS[yew]=pS[yew]-1
set Ad=Ad-1
endfunction
function sEu takes integer wEu,integer uEu,string rEu returns nothing
set Dd[Ad]=rEu
set Ad=Ad+1
if ma[wEu]==0 then
if wEu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_removeAt","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_removeAt on invalid object.","when calling error in ")
endif
endif
call dew(wEu,uEu,"when calling removeAt in HashList, line 48")
set Ad=Ad-1
endfunction
function gew takes integer few,integer Rew,string Tew returns nothing
local integer Yew
local integer Gew
set Dd[Ad]=Tew
set Ad=Ad+1
set Yew=0
set Gew=pS[few]-1
loop
exitwhen Yew>Gew
if Rew==Uqw(bS,few,Yew) then
call sEu(few,Yew,"when calling removeAt in HashList, line 58")
exitwhen true
endif
set Yew=Yew+1
endloop
set Ad=Ad-1
endfunction
function cEu takes integer tEu,integer iEu,string SEu returns nothing
set Dd[Ad]=SEu
set Ad=Ad+1
if ma[tEu]==0 then
if tEu==0 then
call tsw("Nullpointer exception when calling HashList.HashList_HashList_remove","when calling error in ")
else
call tsw("Called HashList.HashList_HashList_remove on invalid object.","when calling error in ")
endif
endif
call gew(tEu,iEu,"when calling remove in HashList, line 55")
set Ad=Ad-1
endfunction
function bqw takes integer oqw,integer Oqw,string lqw returns nothing
set Dd[Ad]=lqw
set Ad=Ad+1
call Bew(oqw,Oqw,"when calling remove in HashMap, line 48")
if AEu(oqw,Oqw,"when calling hasKey in HashMap, line 49") then
call cEu(eS[oqw],Oqw,"when calling remove in HashMap, line 50")
endif
set Ad=Ad-1
endfunction
function mEu takes integer jEu,integer xEu,string vEu returns nothing
set Dd[Ad]=vEu
set Ad=Ad+1
if Za[jEu]==0 then
if jEu==0 then
call tsw("Nullpointer exception when calling HashMap.HashMap_HashMap_remove","when calling error in ")
else
call tsw("Called HashMap.HashMap_HashMap_remove on invalid object.","when calling error in ")
endif
endif
if Za[jEu]<=887 then
call Bew(jEu,xEu,"when calling remove in HashMap, line 23")
else
call bqw(jEu,xEu,"when calling remove in HashMap, line 23")
endif
set Ad=Ad-1
endfunction
function PTu takes integer UTu,string ITu returns nothing
set Dd[Ad]=ITu
set Ad=Ad+1
if pe[UTu]==0 then
call tsw("Double free: object of type OnCastListener","when calling error in ")
else
set le[be]=UTu
set be=be+1
set pe[UTu]=0
endif
set Ad=Ad-1
endfunction
function RL takes integer aL,string nL returns nothing
local integer dL
local integer fL
set Dd[Ad]=nL
set Ad=Ad+1
if xu[aL]!=null then
set dL=kEu(Ru,B0u(xu[aL]),"when calling get in ClosureEvents, line 60")
if dL==aL then
call YEu(Ru,B0u(xu[aL]),Fu[aL],"when calling put in ClosureEvents, line 62")
elseif ku[aL]!=0 then
set Fu[ku[aL]]=Fu[aL]
endif
else
set fL=kEu(fu,ju[aL],"when calling get in ClosureEvents, line 66")
if fL==aL then
call YEu(fu,ju[aL],Fu[aL],"when calling put in ClosureEvents, line 68")
elseif ku[aL]!=0 then
set Fu[ku[aL]]=Fu[aL]
endif
endif
set ku[Fu[aL]]=ku[aL]
set Fu[aL]=0
set ku[aL]=0
set Ad=Ad-1
endfunction
function GL takes integer TL,string YL returns nothing
set Dd[Ad]=YL
set Ad=Ad+1
call RL(TL,"when calling OnCastListener_onDestroy in ClosureEvents, line 58")
call PTu(TL,"when calling OnCastListener in ClosureEvents, line 58")
set Ad=Ad-1
endfunction
function mTu takes integer xTu,string vTu returns nothing
set Dd[Ad]=vTu
set Ad=Ad+1
if pe[xTu]==0 then
if xTu==0 then
call tsw("Nullpointer exception when calling OnCastListener.destroyOnCastListener","when calling error in ")
else
call tsw("Called OnCastListener.destroyOnCastListener on invalid object.","when calling error in ")
endif
endif
call GL(xTu,"when calling destroyOnCastListener in ClosureEvents, line 50")
set Ad=Ad-1
endfunction
function vJ takes unit gJ,string hJ returns nothing
local integer FJ
local integer kJ
local integer jJ
local integer xJ
set Dd[Ad]=hJ
set Ad=Ad+1
if pJ(gJ) then
call ZJ(e_u(gJ),"when calling unregisterEvents in ClosureEvents, line 250")
if nEu(Ru,B0u(gJ),"when calling has in ClosureEvents, line 251") then
set FJ=kEu(Ru,B0u(gJ),"when calling get in ClosureEvents, line 252")
call mEu(Ru,B0u(gJ),"when calling remove in ClosureEvents, line 253")
loop
exitwhen not(FJ!=0)
set kJ=FJ
set FJ=Fu[FJ]
call mTu(kJ,"when calling OnCastListener in ClosureEvents, line 257")
endloop
endif
if nEu(Ru,B0u(gJ),"when calling has in ClosureEvents, line 258") then
set jJ=kEu(Ru,B0u(gJ),"when calling get in ClosureEvents, line 259")
loop
exitwhen not(jJ!=0)
set xJ=jJ
set jJ=Fu[jJ]
call mTu(xJ,"when calling OnCastListener in ClosureEvents, line 263")
endloop
endif
endif
set Ad=Ad-1
endfunction
function uK takes string wK returns nothing
set Dd[Ad]=wK
set Ad=Ad+1
call vJ(R_u(),"when calling unregisterEventsForUnit in ClosureEvents, line 282")
set Ad=Ad-1
endfunction
function J1u takes nothing returns nothing
set Ad=0
call uK("ClosureEvents, line 282")
endfunction
function JLw takes nothing returns boolean
return true
endfunction
function JNw takes nothing returns boolean
return true
endfunction
function Jow takes nothing returns boolean
return true
endfunction
function Jyw takes nothing returns nothing
set Ni=Ni+sw
endfunction
function sK takes string rK returns nothing
set Dd[Ad]=rK
set Ad=Ad+1
call MK("when calling generalEventCallback in ClosureEvents, line 285")
set Ad=Ad-1
endfunction
function K1u takes nothing returns nothing
set Ad=0
call sK("ClosureEvents, line 285")
endfunction
function K2w takes nothing returns boolean
local integer H2w=1095577654
local integer J2w=1112354869
set Ry=H2w
set Ty=J2w
set Yy=120.
set Gy=5.
set gy=1966092599
return true
endfunction
function KLw takes nothing returns boolean
set Ub=2016423985
return true
endfunction
function KNw takes nothing returns boolean
set Kb="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
set Lb="0123456789"
call uMw(Lb)
call uMw(Kb)
return true
endfunction
function Kow takes nothing returns boolean
set xi=true
set vi=true
set mi=true
set Qi=true
return true
endfunction
function Krw takes nothing returns boolean
set Mt=60
set wi=-1
set ui=InitHashtable()
set ri=""
set si=false
return true
endfunction
function Kyw takes nothing returns boolean
set OS=CreateGroup()
return true
endfunction
function iK takes string tK returns nothing
set Dd[Ad]=tK
set Ad=Ad+1
call MK("when calling generalEventCallback in ClosureEvents, line 286")
set Ad=Ad-1
endfunction
function L1u takes nothing returns nothing
set Ad=0
call iK("ClosureEvents, line 286")
endfunction
function LL takes nothing returns boolean
local real JL
local real KL
set vu=CreateGroup()
set Qu=0
set Wu=Filter(WG)
set JL=pp
set KL=ep
return true
endfunction
function LLw takes nothing returns boolean
set fb=35
set Rb=2
set Tb=1966092597
return true
endfunction
function Lh takes nothing returns boolean
set V=1000.*sw
set B=1747988815
set N=1093677396
return true
endfunction
function Low takes nothing returns boolean
return true
endfunction
function AI takes integer ZI,string UI returns nothing
local integer II
local integer PI
set Dd[Ad]=UI
set Ad=Ad+1
if sww(Nw[ZI])==Mw[ZI] and KU(Mw[ZI]) then
set PI=cPu(iI(Mw[ZI]),"when calling staticItr in Buff, line 153")
loop
exitwhen not nGw(PI)
set II=qGw(PI)
call URu(II,true,"when calling refresh in Buff, line 154")
endloop
endif
set Ad=Ad-1
endfunction
function Ayw takes integer Uyw,string Iyw returns integer
local integer Pyw
set Dd[Ad]=Iyw
set Ad=Ad+1
set Pyw=xKu(Ci[Uyw],"when calling play in GameInit, line 57")
set Ad=Ad-1
return Pyw
endfunction
function BI takes integer CI,string VI returns nothing
set Dd[Ad]=VI
set Ad=Ad+1
call J4u(1,wu[CI],"when calling clearBuffs in Buff, line 162",0,null)
set Ad=Ad-1
endfunction
function NSu takes unit BSu returns real
return Qh(GetUnitDefaultPropWindow(BSu))
endfunction
function DXw takes integer AXw returns nothing
call SSu(Nt[ab[AXw]],NSu(Nt[ab[AXw]]))
endfunction
function GUw takes rect YUw returns real
return GetRectMaxX(YUw)
endfunction
function TUw takes rect RUw returns real
return GetRectMinX(RUw)
endfunction
function hUw takes rect gUw returns real
return GetRectMinY(gUw)
endfunction
function kUw takes rect FUw returns real
return GetRectMaxY(FUw)
endfunction
function fUw takes rect dUw returns real
set eR=GetRandomReal(TUw(dUw),GUw(dUw))
set qR=GetRandomReal(hUw(dUw),kUw(dUw))
return eR
endfunction
function Deu takes integer veu,string meu returns nothing
local integer Qeu
local integer Weu
local real Eeu
local real Zeu
local real Ueu
local real Ieu
local real Peu
local real Aeu
set Dd[Ad]=meu
set Ad=Ad+1
set Qeu=0
set Weu=Zp
loop
exitwhen Qeu>Weu
set Ieu=Ycu(fUw(Ep[Qeu]),qR)
set Peu=jf
set Aeu=xf
set Eeu=Ieu
set Zeu=Peu
set Ueu=Aeu
call J2u(0,0,0,0,6,0,0,null,Eeu,Zeu,Ueu,Kp[veu],Np[Lp[veu]],Up,Ip,qlu(Eeu,Zeu,Ueu,Up,Ip),"when calling new_Creep in Wave, line 59",null,0.,0.,0.,0.,null,null,null)
set Qeu=Qeu+1
endloop
set Ad=Ad-1
endfunction
function F1 takes integer g1,string h1 returns nothing
set Dd[Ad]=h1
set Ad=Ad+1
call Bmu(vr[g1],"when calling Fx in DestroyerSummoner, line 94")
call Bmu(mr[g1],"when calling Fx in DestroyerSummoner, line 95")
set Ad=Ad-1
endfunction
function K7w takes integer U7w,unit I7w returns nothing
local real P7w
local real A7w
local real D7w
local real H7w
local real J7w
if Jsu(I7w)==Wy then
set H7w=stu(I7w)
set J7w=cf
set P7w=H7w
set A7w=J7w
set D7w=Psu(I7w)
call p5(m5(My,P7w,A7w))
call biu(I7w)
call Iru(OO[8],Ey,P7w,A7w,D7w)
endif
endfunction
function RWw takes integer dWw,unit fWw returns nothing
call biu(fWw)
endfunction
function XEu takes string KEu returns integer
local integer LEu
set Dd[Ad]=KEu
set Ad=Ad+1
if Ia==0 then
if Pa<32768 then
set Pa=Pa+1
set LEu=Pa
set Aa[LEu]=718
else
call tsw("Out of memory: Could not create EntityWithDist.","when calling error in ")
set LEu=0
endif
else
set Ia=Ia-1
set LEu=Ua[Ia]
set Aa[LEu]=718
endif
set Ad=Ad-1
return LEu
endfunction
function vaw takes integer kaw,integer jaw,real xaw returns nothing
set YS[kaw]=jaw
set GS[kaw]=bUw(xaw)
endfunction
function Gaw takes integer faw,real Raw,string Taw returns integer
local integer Yaw
set Dd[Ad]=Taw
set Ad=Ad+1
set Yaw=XEu("when calling EntityWithDist in HealbackTower, line 89")
call vaw(Yaw,faw,Raw)
set Ad=Ad-1
return Yaw
endfunction
function you takes real oou,real Oou,real lou,real bou returns real
return SUw(lou-oou)+SUw(bou-Oou)
endfunction
function Rdw takes integer pdw,unit edw,string qdw returns nothing
local boolean adw
local integer ndw
local integer ddw
local boolean fdw
set Dd[Ad]=qdw
set Ad=Ad+1
set adw=true
if (not IsUnitType(edw,UNIT_TYPE_STRUCTURE))or(not xtu(edw)) then
set adw=false
endif
if adw and wO[kQw(utu(edw))]==0 then
set adw=false
endif
if adw then
set ndw=sww(edw)
if Oe[ndw]==871 then
set fdw=true
else
set ddw=Oe[ndw]
set fdw=ddw>=861 and ddw<=867
endif
if not fdw then
set adw=false
endif
if Lsu(edw)==Bsu(edw) then
set adw=false
endif
endif
if adw then
call j3u(WS,Gaw(sww(edw),you(ES,ZS,stu(edw),cf),"when calling new_EntityWithDist in HealbackTower, line 56"),"when calling add in HealbackTower, line 56")
endif
set Ad=Ad-1
endfunction
function Dbu takes integer Abu returns real
return 4.85+Abu*Abu
endfunction
function Dpw takes group Ppw,unit Apw returns boolean
return IsUnitInGroup(Apw,Ppw)
endfunction
function Fsu takes unit Gsu,unit gsu,real hsu returns nothing
call UnitDamageTarget(Gsu,gsu,hsu,false,false,ATTACK_TYPE_CHAOS,DAMAGE_TYPE_UNIVERSAL,WEAPON_TYPE_WHOKNOWS)
endfunction
function H3u takes group A3u,unit D3u returns nothing
call GroupAddUnit(A3u,D3u)
endfunction
function Msu takes unit Nsu returns real
return GetUnitMoveSpeed(Nsu)
endfunction
function Pbu takes integer Ibu returns real
return 4.5*Ibu
endfunction
function Ubu takes integer Zbu returns real
return 75.*Zbu+125.
endfunction
function mru takes unit xru,unittype vru returns boolean
return IsUnitType(xru,vru)
endfunction
function mtu takes unit vtu returns boolean
return Lsu(vtu)>.405
endfunction
function s1u takes real M3u,real w1u returns real
local real u1u=WO
local real r1u
if M3u<u1u then
set r1u=M3u
else
set r1u=u1u
endif
set u1u=r1u
if w1u<u1u then
set r1u=w1u
else
set r1u=u1u
endif
set u1u=r1u
return u1u
endfunction
function Zyu takes integer qyu,unit ayu,string nyu returns nothing
local integer dyu
local integer fyu
local real Ryu
local real Tyu
local real Yyu
local real Gyu
local real gyu
local real hyu
local integer Fyu
local integer kyu
local boolean jyu
local real xyu
local real vyu
local real myu
local integer Qyu
local integer Wyu
local real Eyu
set Dd[Ad]=nyu
set Ad=Ad+1
if mtu(ayu) and(not mru(ayu,UNIT_TYPE_FLYING)) then
set dyu=sww(ayu)
if Dpw(mp[vp[qyu]],ayu) then
call msu(Jmu(vp[qyu],"when calling getDummy in WaveTower, line 59"),ayu,Pbu(Qp[vp[qyu]]),ATTACK_TYPE_PIERCE)
else
if dyu!=0 then
set Fyu=Oe[dyu]
set jyu=Fyu>=842 and Fyu<=858
else
set jyu=false
endif
if jyu and(not Ut[dyu]) then
set fyu=dyu
call H3u(mp[vp[qyu]],ayu)
call Fsu(Jmu(vp[qyu],"when calling getDummy in WaveTower, line 63"),ayu,Ubu(Qp[vp[qyu]]))
set xyu=wvu(dyu,"when calling getPos in WaveTower, line 64")
set vyu=sf
set myu=tf
set Ryu=xyu
set Tyu=vyu
set Yyu=myu
set Qyu=vp[qyu]
set Gyu=Ylu(ht[Qyu],Ft[Qyu],kt[Qyu],Ryu,Tyu,Yyu)
set Eyu=Dbu(Qp[vp[qyu]])
set Wyu=vp[qyu]
set gyu=Eyu*s1u(0.35,YOu(jt[Wyu],xt[Wyu],vt[Wyu])/(16.*16.))
set kyu=Oe[dyu]
if kyu>=843 and kyu<=849 then
set hyu=0.25+Msu(Nt[fyu])/522.*0.75
call vju(dyu,Dh(Gyu)*gyu*hyu,Ph(Gyu)*gyu*hyu,0.,"when calling setVel in WaveTower, line 69")
else
call vju(dyu,Dh(Gyu)*gyu,Ph(Gyu)*gyu,0.,"when calling setVel in WaveTower, line 71")
endif
call p5(m5(m,stu(ayu),cf))
endif
endif
endif
set Ad=Ad-1
endfunction
function asu takes unit psu,unitstate esu,real qsu returns nothing
call SetUnitState(psu,esu,Ysu(psu,esu)+qsu)
endfunction
function ysu takes unit lsu,real bsu returns nothing
call asu(lsu,UNIT_STATE_LIFE,bsu)
endfunction
function lcw takes integer ocw,unit Ocw returns nothing
call ysu(Ocw,100.)
endfunction
function v7w takes integer G7w,unit g7w returns nothing
local real h7w
local real F7w
local real k7w
local real j7w
local real x7w
if Jsu(g7w)==Ey then
set j7w=stu(g7w)
set x7w=cf
set h7w=j7w
set F7w=x7w
set k7w=Psu(g7w)
call p5(m5(G,h7w,F7w))
call biu(g7w)
call Iru(Iy,Wy,h7w,F7w,k7w)
endif
endfunction
function iYu takes integer rYu,unit sYu,string tYu returns nothing
set Dd[Ad]=tYu
set Ad=Ad+1
if iq[rYu]==0 then
if rYu==0 then
call tsw("Nullpointer exception when calling ForGroupCallback.ClosureForGroups_ForGroupCallback_callback","when calling error in ")
else
call tsw("Called ForGroupCallback.ClosureForGroups_ForGroupCallback_callback on invalid object.","when calling error in ")
endif
endif
if iq[rYu]<=756 then
if iq[rYu]<=755 then
if iq[rYu]<=754 then
call lcw(rYu,sYu)
else
call Rdw(rYu,sYu,"when calling HealbackTower_closure_impl in ClosureForGroups, line 4")
endif
else
call RWw(rYu,sYu)
endif
elseif iq[rYu]<=758 then
if iq[rYu]<=757 then
call v7w(rYu,sYu)
else
call K7w(rYu,sYu)
endif
else
call Zyu(rYu,sYu,"when calling WaveMissile_closure_impl in ClosureForGroups, line 4")
endif
set Ad=Ad-1
endfunction
function SX takes group uX,integer rX,string sX returns nothing
local unit tX
local group iX
set Dd[Ad]=sX
set Ad=Ad+1
set iX=uX
loop
exitwhen not Jpw(iX)
set tX=Bpw(iX)
call iYu(rX,tX,"when calling callback in ClosureForGroups, line 31")
endloop
set Ad=Ad-1
set tX=null
set iX=null
endfunction
function gDu takes string YDu returns integer
local integer GDu
set Dd[Ad]=YDu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set GDu=tq
set iq[GDu]=756
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set GDu=0
endif
else
set sq=sq-1
set GDu=rq[sq]
set iq[GDu]=756
endif
set Ad=Ad-1
return GDu
endfunction
function nWw takes string eWw returns nothing
local integer qWw
local group aWw
set Dd[Ad]=eWw
set Ad=Ad+1
call biu(dO)
set aWw=nO
set qWw=gDu("when calling alloc_Closure in Preloader, line 41")
call SX(aWw,qWw,"when calling forEachFrom in Preloader, line 41")
call Ipw(nO)
set nO=null
set Ad=Ad-1
set aWw=null
endfunction
function GWw takes integer TWw,string YWw returns nothing
set Dd[Ad]=YWw
set Ad=Ad+1
call nWw("when calling finishPreload in Preloader, line 50")
set Ad=Ad-1
endfunction
function GMu takes integer TMu,string YMu returns nothing
set Dd[Ad]=YMu
set Ad=Ad+1
if Cn[TMu]==0 then
call tsw("Double free: object of type CreateSpecial","when calling error in ")
else
set Kn[Ln]=TMu
set Ln=Ln+1
set Cn[TMu]=0
endif
set Ad=Ad-1
endfunction
function Oeu takes integer oeu returns nothing
endfunction
function yeu takes integer leu,string beu returns nothing
set Dd[Ad]=beu
set Ad=Ad+1
call Oeu(leu)
call GMu(leu,"when calling CreateSpecial in Wave, line 89")
set Ad=Ad-1
endfunction
function lMu takes integer oMu,string OMu returns nothing
set Dd[Ad]=OMu
set Ad=Ad+1
if Cn[oMu]==0 then
if oMu==0 then
call tsw("Nullpointer exception when calling CreateSpecial.destroyCreateSpecial","when calling error in ")
else
call tsw("Called CreateSpecial.destroyCreateSpecial on invalid object.","when calling error in ")
endif
endif
call yeu(oMu,"when calling destroyCreateSpecial in Wave, line 89")
set Ad=Ad-1
endfunction
function Gqu takes integer Tqu,string Yqu returns nothing
set Dd[Ad]=Yqu
set Ad=Ad+1
call lMu(ie[ue[Tqu]],"when calling CreateSpecial in Wave, line 110")
set Ad=Ad-1
endfunction
function HDw takes integer DDw returns nothing
call p5(bl[DDw])
endfunction
function Vtu takes unit Ktu,integer Ltu,real Xtu,real Ctu returns boolean
return IssuePointOrderById(Ktu,Ltu,Xtu,Ctu)
endfunction
function Jm takes integer Im returns boolean
local unit Am=Nt[Gw[Im]]
local integer Dm=Lo
local integer Pm=Im
local boolean Hm=Vtu(Am,Dm,gw[Pm],hw[Pm])
set Am=null
return Hm
endfunction
function FHw takes integer hHw returns nothing
set ql[hHw]=false
set al[hHw]=null
endfunction
function MDw takes integer XDw,string CDw returns nothing
local timer VDw
local timer BDw
local integer NDw
set Dd[Ad]=CDw
set Ad=Ad+1
set NDw=XDw
set VDw=b2w("when calling getTimer in SeqWorker, line 12")
call s2w(VDw,XDw,"when calling setData in SeqWorker, line 12")
set al[NDw]=VDw
set BDw=al[XDw]
call j2w(BDw,0.001,pg)
set Ad=Ad-1
set VDw=null
set BDw=null
endfunction
function SUu takes string tUu returns integer
local integer iUu
set Dd[Ad]=tUu
set Ad=Ad+1
if Hq==0 then
if Jq<32768 then
set Jq=Jq+1
set iUu=Jq
set Kq[iUu]=820
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set iUu=0
endif
else
set Hq=Hq-1
set iUu=Dq[Hq]
set Kq[iUu]=820
endif
set Ad=Ad-1
return iUu
endfunction
function ux takes integer Cj,integer Vj,integer Bj returns integer
local integer Nj=0
local integer Mj
local integer wx
if bw[Cj]!=0 then
set Nj=ux(bw[Cj],Vj,Bj)
endif
set Mj=lw[Cj]+Nj*Vj
set wx=Mj/Bj
set Nj=Mj-wx*Bj
set lw[Cj]=wx
return Nj
endfunction
function Onu takes integer tnu,integer inu,integer Snu,string cnu returns integer
local integer onu
set Dd[Ad]=cnu
set Ad=Ad+1
if he[tnu]==0 then
if tnu==0 then
call tsw("Nullpointer exception when calling BigNum_l.BigNum_BigNum_l_divSmall","when calling error in ")
else
call tsw("Called BigNum_l.BigNum_BigNum_l_divSmall on invalid object.","when calling error in ")
endif
endif
set onu=ux(tnu,inu,Snu)
set Ad=Ad-1
return onu
endfunction
function gj takes integer Rj,integer Tj,string Yj returns integer
local integer Gj
set Dd[Ad]=Yj
set Ad=Ad+1
set Gj=Onu(ow[Rj],Ow[Rj],Tj,"when calling divSmall in BigNum, line 133")
set Ad=Ad-1
return Gj
endfunction
function Hau takes integer Iau,integer Pau,string Aau returns integer
local integer Dau
set Dd[Ad]=Aau
set Ad=Ad+1
if Te[Iau]==0 then
if Iau==0 then
call tsw("Nullpointer exception when calling BigNum.BigNum_BigNum_divSmall","when calling error in ")
else
call tsw("Called BigNum.BigNum_BigNum_divSmall on invalid object.","when calling error in ")
endif
endif
set Dau=gj(Iau,Pau,"when calling divSmall in BigNum, line 132")
set Ad=Ad-1
return Dau
endfunction
function J5 takes integer P5,integer A5,string D5 returns integer
local integer H5
set Dd[Ad]=D5
set Ad=Ad+1
set H5=Hau(Ms[P5],A5+1,"when calling divSmall in Encoder, line 32")
set Ad=Ad-1
return H5
endfunction
function dhu takes integer ehu,integer qhu,string ahu returns integer
local integer nhu
set Dd[Ad]=ahu
set Ad=Ad+1
if Aq[ehu]==0 then
if ehu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_decode","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_decode on invalid object.","when calling error in ")
endif
endif
set nhu=J5(ehu,qhu,"when calling decode in Encoder, line 31")
set Ad=Ad-1
return nhu
endfunction
function KTw takes integer PTw,string ATw returns nothing
local integer DTw
local integer HTw
local integer JTw
set Dd[Ad]=ATw
set Ad=Ad+1
call DEw("file valid2")
set DTw=dhu(vc[PTw],qc,"when calling decode in LZW, line 68")
call DEw("dictSize: "+bfw(DTw))
set HTw=Ngw("when calling new_LinkedList in LZW, line 70")
call DEw("start decoding pos")
set JTw=SUu("when calling alloc_Closure in LZW, line 72")
call FHw(JTw)
set Fc[JTw]=vc[PTw]
set kc[JTw]=DTw
set jc[JTw]=HTw
set xc[JTw]=mc[PTw]
call MDw(JTw,"when calling doSeq in LZW, line 72")
set Ad=Ad-1
endfunction
function KX takes integer JX returns nothing
set Eu=Eu+50
endfunction
function NA takes integer BA returns nothing
call p5(yu[BA])
endfunction
function Y_u takes code T_u returns nothing
call i8w(up,Condition(T_u))
endfunction
function g8w takes trigger R8w,player T8w,string Y8w,boolean G8w returns nothing
call TriggerRegisterPlayerChatEvent(R8w,T8w,Y8w,G8w)
endfunction
function g_u takes code G_u returns nothing
call i8w(wp,Condition(G_u))
endfunction
function j8w takes trigger h8w,player F8w,playerevent k8w returns nothing
call TriggerRegisterPlayerEvent(h8w,F8w,k8w)
endfunction
function NJ takes integer UJ returns nothing
local integer IJ
local integer PJ
local trigger AJ
local trigger DJ
local trigger HJ
local trigger JJ
local trigger KJ
local trigger LJ
local trigger XJ
local trigger CJ
local trigger VJ
local trigger BJ
call g_u(kG)
call Y_u(jG)
call r8w(eu,xG)
call r8w(qu,vG)
call r8w(au,mG)
set IJ=0
set PJ=bj_MAX_PLAYERS-1
loop
exitwhen IJ>PJ
call j8w(qu,OO[IJ],EVENT_PLAYER_LEAVE)
set AJ=au
call j8w(AJ,OO[IJ],EVENT_PLAYER_ARROW_DOWN_DOWN)
set DJ=AJ
call j8w(DJ,OO[IJ],EVENT_PLAYER_ARROW_DOWN_UP)
set HJ=DJ
call j8w(HJ,OO[IJ],EVENT_PLAYER_ARROW_UP_DOWN)
set JJ=HJ
call j8w(JJ,OO[IJ],EVENT_PLAYER_ARROW_UP_UP)
set KJ=JJ
call j8w(KJ,OO[IJ],EVENT_PLAYER_ARROW_LEFT_DOWN)
set LJ=KJ
call j8w(LJ,OO[IJ],EVENT_PLAYER_ARROW_LEFT_UP)
set XJ=LJ
call j8w(XJ,OO[IJ],EVENT_PLAYER_ARROW_RIGHT_DOWN)
set CJ=XJ
call j8w(CJ,OO[IJ],EVENT_PLAYER_ARROW_RIGHT_UP)
set VJ=CJ
call j8w(VJ,OO[IJ],EVENT_PLAYER_END_CINEMATIC)
set BJ=VJ
call g8w(BJ,OO[IJ],"",false)
set IJ=IJ+1
endloop
call MUw(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,QG,null)
set AJ=null
set DJ=null
set HJ=null
set JJ=null
set KJ=null
set LJ=null
set XJ=null
set CJ=null
set VJ=null
set BJ=null
endfunction
function Pbw takes integer Ubw returns nothing
local timerdialog Ibw=CreateTimerDialog(Hi)
call TimerDialogSetTitle(Ibw,"Until Finale: ")
call TimerDialogDisplay(Ibw,true)
set Ibw=null
endfunction
function eNw takes integer iNw,real SNw,real cNw,real oNw,integer ONw,integer lNw,real bNw,real yNw,string pNw returns nothing
set Dd[Ad]=pNw
set Ad=Ad+1
call J2u(0,0,0,0,7,iNw,0,null,SNw,cNw,oNw,ONw,lNw,bNw,yNw,qlu(SNw,cNw,oNw,bNw,yNw),"when calling construct_Creep in Special, line 16",null,0.,0.,0.,0.,null,null,null)
set Ib[iNw]=Kqu(Nt[iNw],"war3mapImported\\GeneralHeroGlow.mdx","origin")
set Ad=Ad-1
endfunction
function CBw takes integer IBw,real PBw,real ABw,real DBw,integer HBw,integer JBw,real KBw,real LBw,string XBw returns nothing
set Dd[Ad]=XBw
set Ad=Ad+1
call eNw(IBw,PBw,ABw,DBw,HBw,JBw,KBw,LBw,"when calling construct_Special in SpecialTwo, line 13")
set Ad=Ad-1
endfunction
function XLu takes string KLu returns integer
local integer LLu
set Dd[Ad]=KLu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set LLu=oe
set Oe[LLu]=857
else
call tsw("Out of memory: Could not create SpecialTwo.","when calling error in ")
set LLu=0
endif
else
set ce=ce-1
set LLu=Se[ce]
set Oe[LLu]=857
endif
set Ad=Ad-1
return LLu
endfunction
function kBw takes real dBw,real fBw,real RBw,integer TBw,integer YBw,real GBw,real gBw,string hBw returns integer
local integer FBw
set Dd[Ad]=hBw
set Ad=Ad+1
set FBw=XLu("when calling SpecialTwo in SpecialTwo, line 13")
call CBw(FBw,dBw,fBw,RBw,TBw,YBw,GBw,gBw,"when calling construct_SpecialTwo in SpecialTwo, line 13")
set Ad=Ad-1
return FBw
endfunction
function QBw takes integer jBw,string xBw returns nothing
local integer vBw
local integer mBw
set Dd[Ad]=xBw
set Ad=Ad+1
set vBw=0
loop
exitwhen vBw>2
set mBw=jBw
call kBw(hou(Fb[mBw],kb[mBw],jb[mBw],GetRandomReal(-16.,16.),GetRandomReal(-16.,16.)),Uf,If,Eb,7,Up,Ip,"when calling new_SpecialTwo in SpecialTwo, line 27")
set vBw=vBw+1
endloop
set Ad=Ad-1
endfunction
function uC takes integer BX,real NX,integer MX,string wC returns nothing
set Dd[Ad]=wC
set Ad=Ad+1
set Uu[BX]=b2w("when calling getTimer in ClosureTimers, line 107")
call s2w(Uu[BX],BX,"when calling setData in ClosureTimers, line 108")
set Zu[BX]=MX
call Q2w(Uu[BX],NX,EG)
set Ad=Ad-1
endfunction
function RYu takes integer aYu,real nYu,integer dYu,string fYu returns nothing
set Dd[Ad]=fYu
set Ad=Ad+1
if Oq[aYu]==0 then
if aYu==0 then
call tsw("Nullpointer exception when calling CallbackCounted.ClosureTimers_CallbackCounted_start","when calling error in ")
else
call tsw("Called CallbackCounted.ClosureTimers_CallbackCounted_start on invalid object.","when calling error in ")
endif
endif
call uC(aYu,nYu,dYu,"when calling start in ClosureTimers, line 106")
set Ad=Ad-1
endfunction
function UX takes real QX,integer WX,integer EX,string ZX returns integer
set Dd[Ad]=ZX
set Ad=Ad+1
call RYu(EX,QX,WX,"when calling start in ClosureTimers, line 48")
set Ad=Ad-1
return EX
endfunction
function HX takes real IX,real PX,integer AX,string DX returns integer
set Dd[Ad]=DX
set Ad=Ad+1
call UX(IX,bUw(PX/IX+0.5),AX,"when calling doPeriodicallyCounted in ClosureTimers, line 59")
set Ad=Ad-1
return AX
endfunction
function bC takes integer lC returns nothing
set Zu[lC]=0
endfunction
function mWu takes string xWu returns integer
local integer vWu
set Dd[Ad]=xWu
set Ad=Ad+1
if cq==0 then
if oq<32768 then
set oq=oq+1
set vWu=oq
set Oq[vWu]=653
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set vWu=0
endif
else
set cq=cq-1
set vWu=Sq[cq]
set Oq[vWu]=653
endif
set Ad=Ad-1
return vWu
endfunction
function Qyw takes integer jyw,string xyw returns nothing
local integer vyw
local integer myw
set Dd[Ad]=xyw
set Ad=Ad+1
set vyw=xKu(Ki,"when calling play in GameInit, line 54")
set myw=mWu("when calling alloc_Closure in GameInit, line 55")
call bC(myw)
set Xi[myw]=vyw
call HX(0.3,10.,myw,"when calling doPeriodicallyTimed in GameInit, line 55")
set Ad=Ad-1
endfunction
function Kuu takes integer Euu,real Zuu,real Uuu,real Iuu,integer Puu,integer Auu,real Duu,real Huu,string Juu returns nothing
set Dd[Ad]=Juu
set Ad=Ad+1
call kBw(Zuu,Uuu,Iuu,Puu,Auu,Duu,Huu,"when calling new_SpecialTwo in UnitSpawnSystem, line 126")
set Ad=Ad-1
endfunction
function WLu takes string mLu returns integer
local integer QLu
set Dd[Ad]=mLu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set QLu=oe
set Oe[QLu]=855
else
call tsw("Out of memory: Could not create SpecialOne.","when calling error in ")
set QLu=0
endif
else
set ce=ce-1
set QLu=Se[ce]
set Oe[QLu]=855
endif
set Ad=Ad-1
return QLu
endfunction
function qVw takes integer SVw,real cVw,real oVw,real OVw,integer lVw,integer bVw,real yVw,real pVw,string eVw returns nothing
set Dd[Ad]=eVw
set Ad=Ad+1
call eNw(SVw,cVw,oVw,OVw,lVw,bVw,yVw,pVw,"when calling construct_Special in SpecialOne, line 7")
set Ad=Ad-1
endfunction
function iVw takes real VCw,real BCw,real NCw,integer MCw,integer wVw,real uVw,real rVw,string sVw returns integer
local integer tVw
set Dd[Ad]=sVw
set Ad=Ad+1
set tVw=WLu("when calling SpecialOne in SpecialOne, line 7")
call qVw(tVw,VCw,BCw,NCw,MCw,wVw,uVw,rVw,"when calling construct_SpecialOne in SpecialOne, line 7")
set Ad=Ad-1
return tVw
endfunction
function Wuu takes integer guu,real huu,real Fuu,real kuu,integer juu,integer xuu,real vuu,real muu,string Quu returns nothing
set Dd[Ad]=Quu
set Ad=Ad+1
call iVw(huu,Fuu,kuu,juu,xuu,vuu,muu,"when calling new_SpecialOne in UnitSpawnSystem, line 123")
set Ad=Ad-1
endfunction
function eCw takes integer iCw,real SCw,real cCw,real oCw,integer OCw,integer lCw,real bCw,real yCw,string pCw returns nothing
set Dd[Ad]=pCw
set Ad=Ad+1
call eNw(iCw,SCw,cCw,oCw,OCw,lCw,bCw,yCw,"when calling construct_Special in SpecialFive, line 17")
set Yb[iCw]=5+GetRandomInt(-4,4)
set Ad=Ad-1
endfunction
function qLu takes string pLu returns integer
local integer eLu
set Dd[Ad]=pLu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set eLu=oe
set Oe[eLu]=853
else
call tsw("Out of memory: Could not create SpecialFive.","when calling error in ")
set eLu=0
endif
else
set ce=ce-1
set eLu=Se[ce]
set Oe[eLu]=853
endif
set Ad=Ad-1
return eLu
endfunction
function tCw takes real CXw,real VXw,real BXw,integer NXw,integer MXw,real wCw,real uCw,string rCw returns integer
local integer sCw
set Dd[Ad]=rCw
set Ad=Ad+1
set sCw=qLu("when calling SpecialFive in SpecialFive, line 17")
call eCw(sCw,CXw,VXw,BXw,NXw,MXw,wCw,uCw,"when calling construct_SpecialFive in SpecialFive, line 17")
set Ad=Ad-1
return sCw
endfunction
function Yru takes integer pru,real eru,real qru,real aru,integer nru,integer dru,real fru,real Rru,string Tru returns nothing
set Dd[Ad]=Tru
set Ad=Ad+1
call tCw(eru,qru,aru,nru,dru,fru,Rru,"when calling new_SpecialFive in UnitSpawnSystem, line 135")
set Ad=Ad-1
endfunction
function ALu takes string ILu returns integer
local integer PLu
set Dd[Ad]=ILu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set PLu=oe
set Oe[PLu]=856
else
call tsw("Out of memory: Could not create SpecialThree.","when calling error in ")
set PLu=0
endif
else
set ce=ce-1
set PLu=Se[ce]
set Oe[PLu]=856
endif
set Ad=Ad-1
return PLu
endfunction
function HVw takes integer QVw,real WVw,real EVw,real ZVw,integer UVw,integer IVw,real PVw,real AVw,string DVw returns nothing
set Dd[Ad]=DVw
set Ad=Ad+1
call eNw(QVw,WVw,EVw,ZVw,UVw,IVw,PVw,AVw,"when calling construct_Special in SpecialThree, line 7")
set Ad=Ad-1
endfunction
function mVw takes real YVw,real GVw,real gVw,integer hVw,integer FVw,real kVw,real jVw,string xVw returns integer
local integer vVw
set Dd[Ad]=xVw
set Ad=Ad+1
set vVw=ALu("when calling SpecialThree in SpecialThree, line 7")
call HVw(vVw,YVw,GVw,gVw,hVw,FVw,kVw,jVw,"when calling construct_SpecialThree in SpecialThree, line 7")
set Ad=Ad-1
return vVw
endfunction
function rru takes integer Luu,real Xuu,real Cuu,real Vuu,integer Buu,integer Nuu,real Muu,real wru,string uru returns nothing
set Dd[Ad]=uru
set Ad=Ad+1
call mVw(Xuu,Cuu,Vuu,Buu,Nuu,Muu,wru,"when calling new_SpecialThree in UnitSpawnSystem, line 129")
set Ad=Ad-1
endfunction
function DCw takes integer mCw,real QCw,real WCw,real ECw,integer ZCw,integer UCw,real ICw,real PCw,string ACw returns nothing
set Dd[Ad]=ACw
set Ad=Ad+1
call eNw(mCw,QCw,WCw,ECw,ZCw,UCw,ICw,PCw,"when calling construct_Special in SpecialFour, line 7")
set Ad=Ad-1
endfunction
function kLu takes string hLu returns integer
local integer FLu
set Dd[Ad]=hLu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set FLu=oe
set Oe[FLu]=854
else
call tsw("Out of memory: Could not create SpecialFour.","when calling error in ")
set FLu=0
endif
else
set ce=ce-1
set FLu=Se[ce]
set Oe[FLu]=854
endif
set Ad=Ad-1
return FLu
endfunction
function vCw takes real TCw,real YCw,real GCw,integer gCw,integer hCw,real FCw,real kCw,string jCw returns integer
local integer xCw
set Dd[Ad]=jCw
set Ad=Ad+1
set xCw=kLu("when calling SpecialFour in SpecialFour, line 7")
call DCw(xCw,TCw,YCw,GCw,gCw,hCw,FCw,kCw,"when calling construct_SpecialFour in SpecialFour, line 7")
set Ad=Ad-1
return xCw
endfunction
function yru takes integer sru,real tru,real iru,real Sru,integer cru,integer oru,real Oru,real lru,string bru returns nothing
set Dd[Ad]=bru
set Ad=Ad+1
call vCw(tru,iru,Sru,cru,oru,Oru,lru,"when calling new_SpecialFour in UnitSpawnSystem, line 132")
set Ad=Ad-1
endfunction
function RMu takes integer bMu,real yMu,real pMu,real eMu,integer qMu,integer aMu,real nMu,real dMu,string fMu returns nothing
set Dd[Ad]=fMu
set Ad=Ad+1
if Cn[bMu]==0 then
if bMu==0 then
call tsw("Nullpointer exception when calling CreateSpecial.Wave_CreateSpecial_create","when calling error in ")
else
call tsw("Called CreateSpecial.Wave_CreateSpecial_create on invalid object.","when calling error in ")
endif
endif
if Cn[bMu]<=708 then
if Cn[bMu]<=707 then
if Cn[bMu]<=706 then
call Wuu(bMu,yMu,pMu,eMu,qMu,aMu,nMu,dMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 90")
else
call Kuu(bMu,yMu,pMu,eMu,qMu,aMu,nMu,dMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 90")
endif
else
call rru(bMu,yMu,pMu,eMu,qMu,aMu,nMu,dMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 90")
endif
elseif Cn[bMu]<=709 then
call yru(bMu,yMu,pMu,eMu,qMu,aMu,nMu,dMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 90")
else
call Yru(bMu,yMu,pMu,eMu,qMu,aMu,nMu,dMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 90")
endif
set Ad=Ad-1
endfunction
function Rqu takes integer aqu,string nqu returns nothing
local integer dqu
local integer fqu
set Dd[Ad]=nqu
set Ad=Ad+1
set dqu=0
set fqu=Zp
loop
exitwhen dqu>fqu
call RMu(ie[we[aqu]],Ycu(fUw(Ep[dqu]),qR),jf,xf,re[we[aqu]],te[we[aqu]],Up,Ip,"when calling create in Wave, line 109")
set dqu=dqu+1
endloop
set Ad=Ad-1
endfunction
function UBw takes integer WBw,string EBw returns nothing
local integer ZBw
set Dd[Ad]=EBw
set Ad=Ad+1
set ZBw=WBw
call kBw(hou(xb[ZBw],vb[ZBw],mb[ZBw],GetRandomReal(-16.,16.),GetRandomReal(-16.,16.)),Uf,If,Zb,6,Up,Ip,"when calling new_SpecialTwo in SpecialTwo, line 30")
set Ad=Ad-1
endfunction
function Itu takes unit Ztu,integer Utu returns boolean
return IssueImmediateOrderById(Ztu,Utu)
endfunction
function Um takes integer Zm returns boolean
return Itu(Nt[Yw[Zm]],Xo)
endfunction
function VMw takes integer CMw returns nothing
call diu(Vb[CMw],Cb,1)
endfunction
function Xqu takes string Lqu returns nothing
endfunction
function Bqu takes integer Cqu,integer Vqu returns nothing
if Cqu!=Vqu then
call Xqu("Expected <"+bfw(Vqu)+">, Actual <"+bfw(Cqu)+">")
endif
endfunction
function VX takes integer CX returns nothing
set Eu=Eu/2
call Bqu(Eu,250)
endfunction
function XX takes integer LX returns nothing
set Eu=Eu*2
endfunction
function OLu takes string cLu returns integer
local integer oLu
set Dd[Ad]=cLu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set oLu=oe
set Oe[oLu]=852
else
call tsw("Out of memory: Could not create Spawn.","when calling error in ")
set oLu=0
endif
else
set ce=ce-1
set oLu=Se[ce]
set Oe[oLu]=852
endif
set Ad=Ad-1
return oLu
endfunction
function aXw takes integer cXw,real oXw,real OXw,real lXw,integer bXw,integer yXw,real pXw,real eXw,string qXw returns nothing
set Dd[Ad]=qXw
set Ad=Ad+1
call eNw(cXw,oXw,OXw,lXw,bXw,yXw,pXw,eXw,"when calling construct_Special in SpecialFive, line 6")
set Ad=Ad-1
endfunction
function SXw takes real BLw,real NLw,real MLw,integer wXw,integer uXw,real rXw,real sXw,string tXw returns integer
local integer iXw
set Dd[Ad]=tXw
set Ad=Ad+1
set iXw=OLu("when calling Spawn in SpecialFive, line 6")
call aXw(iXw,BLw,NLw,MLw,wXw,uXw,rXw,sXw,"when calling construct_Spawn in SpecialFive, line 6")
set Ad=Ad-1
return iXw
endfunction
function XXw takes integer HXw,string JXw returns nothing
local integer KXw
local integer LXw
set Dd[Ad]=JXw
set Ad=Ad+1
set LXw=HXw
set KXw=SXw(Ycu(nb[LXw],db[LXw]),jf,xf,Tb,0,Up,Ip,"when calling new_Spawn in SpecialFive, line 35")
call d5("Abilities\\Spells\\Undead\\AnimateDead\\AnimateDeadTarget.mdl",wvu(KXw,"when calling getPos in SpecialFive, line 36"),sf,tf)
set Ad=Ad-1
endfunction
function LVu takes string JVu returns integer
local integer KVu
set Dd[Ad]=JVu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set KVu=tq
set iq[KVu]=758
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set KVu=0
endif
else
set sq=sq-1
set KVu=rq[sq]
set iq[KVu]=758
endif
set Ad=Ad-1
return KVu
endfunction
function Z7w takes integer m7w,string Q7w returns nothing
local integer W7w
local player E7w
set Dd[Ad]=Q7w
set Ad=Ad+1
set E7w=Iy
set W7w=LVu("when calling alloc_Closure in TownBell, line 30")
call lX(E7w,W7w,"when calling forUnitsOfPlayer in TownBell, line 30")
set Ad=Ad-1
set E7w=null
endfunction
function iSw takes integer wSw,string uSw returns nothing
local texttag rSw
local texttag sSw
local texttag tSw
set Dd[Ad]=uSw
set Ad=Ad+1
set ai[wSw]=0
set qi[wSw]=0.
if ei[wSw]then
call Yvu(wSw,"when calling FText in FText, line 83")
else
set rSw=pi[wSw]
call F4w(rSw,false)
set sSw=rSw
call s4w(sSw,Ku,Lu,Xu,Cu)
set tSw=sSw
call c4w(tSw,"",0.)
call j3u(bi,wSw,"when calling add in FText, line 88")
endif
set Ad=Ad-1
set rSw=null
set sSw=null
set tSw=null
endfunction
function hvu takes integer Gvu,string gvu returns nothing
set Dd[Ad]=gvu
set Ad=Ad+1
if qa[Gvu]==0 then
if Gvu==0 then
call tsw("Nullpointer exception when calling FText.FText_FText_recycle","when calling error in ")
else
call tsw("Called FText.FText_FText_recycle on invalid object.","when calling error in ")
endif
endif
call iSw(Gvu,"when calling recycle in FText, line 79")
set Ad=Ad-1
endfunction
function bSw takes integer OSw,string lSw returns nothing
set Dd[Ad]=lSw
set Ad=Ad+1
call hvu(yi[OSw],"when calling recycle in FText, line 111")
set Ad=Ad-1
endfunction
function D4w takes integer A4w returns nothing
set py[A4w]=py[A4w]+1
endfunction
function Dnw takes integer Anw returns nothing
set QS[Anw]=QS[Anw]+1
endfunction
function eBu takes string yBu returns integer
local integer pBu
set Dd[Ad]=yBu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set pBu=oe
set Oe[pBu]=866
else
call tsw("Out of memory: Could not create TrooperTower.","when calling error in ")
set pBu=0
endif
else
set ce=ce-1
set pBu=Se[ce]
set Oe[pBu]=866
endif
set Ad=Ad-1
return pBu
endfunction
function UCu takes string ECu returns integer
local integer ZCu
set Dd[Ad]=ECu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set ZCu=Le
set Xe[ZCu]=733
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set ZCu=0
endif
else
set Ke=Ke-1
set ZCu=Je[Ke]
set Xe[ZCu]=733
endif
set Ad=Ad-1
return ZCu
endfunction
function o5w takes integer u5w,unit r5w,integer s5w,string t5w returns nothing
local integer i5w
local unit S5w
local playerunitevent c5w
set Dd[Ad]=t5w
set Ad=Ad+1
call J2u(0,0,3,u5w,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,r5w,0.,0.,0.,0.,"when calling construct_UnitEntity in TowerBlockade, line 72",null,null)
set hy[u5w]=s5w
set S5w=r5w
set c5w=EVENT_PLAYER_UNIT_DEATH
set i5w=UCu("when calling alloc_Closure in TowerBlockade, line 76")
call cL(i5w)
call fK(S5w,c5w,i5w,"when calling add in TowerBlockade, line 76")
set Ad=Ad-1
set S5w=null
set c5w=null
endfunction
function vCu takes string jCu returns integer
local integer xCu
set Dd[Ad]=jCu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set xCu=oe
set Oe[xCu]=840
else
call tsw("Out of memory: Could not create BlockadeShip.","when calling error in ")
set xCu=0
endif
else
set ce=ce-1
set xCu=Se[ce]
set Oe[xCu]=840
endif
set Ad=Ad-1
return xCu
endfunction
function B2w takes unit L2w,integer X2w,string C2w returns integer
local integer V2w
set Dd[Ad]=C2w
set Ad=Ad+1
set V2w=vCu("when calling BlockadeShip in TowerBlockade, line 72")
call o5w(V2w,L2w,X2w,"when calling construct_BlockadeShip in TowerBlockade, line 72")
set Ad=Ad-1
return V2w
endfunction
function E6w takes integer W6w returns nothing
call Siu(Nt[W6w])
endfunction
function E9u takes integer v9u,string m9u returns nothing
local integer Q9u
local integer W9u
set Dd[Ad]=m9u
set Ad=Ad+1
call E6w(v9u)
set Q9u=lgw(Xy[v9u],"when calling iterator in TrooperTower, line 87")
loop
exitwhen not nGw(Q9u)
set W9u=qGw(Q9u)
call Siu(Nt[W9u])
endloop
call RGw(Q9u,"when calling close in TrooperTower, line 87")
set Ad=Ad-1
endfunction
function RVu takes integer dVu,string fVu returns nothing
set Dd[Ad]=fVu
set Ad=Ad+1
if Oe[dVu]==0 then
if dVu==0 then
call tsw("Nullpointer exception when calling Tower.Tower_Tower_pause","when calling error in ")
else
call tsw("Called Tower.Tower_Tower_pause on invalid object.","when calling error in ")
endif
endif
if Oe[dVu]<=866 then
if Oe[dVu]<=865 then
call E6w(dVu)
else
call E9u(dVu,"when calling pause in Tower, line 56")
endif
else
call E6w(dVu)
endif
set Ad=Ad-1
endfunction
function g5w takes integer p5w,integer e5w,string q5w returns nothing
local integer a5w
local integer n5w
local real d5w
local real f5w
local real R5w
local real T5w
local real Y5w
local real G5w
set Dd[Ad]=q5w
set Ad=Ad+1
set uu[p5w]=e5w
if not KU(e5w) then
call qI(e5w,"when calling newBuffs in TowerBlockade, line 41")
endif
set a5w=lgw(iI(e5w),"when calling iterator in TowerBlockade, line 42")
loop
exitwhen not nGw(a5w)
set n5w=qGw(a5w)
if Ie[n5w]==Ie[p5w]then
set ru[n5w]=ru[p5w]
set uu[p5w]=0
call J4u(3,4,null,p5w,"when calling terminate in TowerBlockade, line 46")
call RGw(a5w,"when calling close in TowerBlockade, line 42")
set Ad=Ad-1
return
endif
endloop
call RGw(a5w,"when calling close in TowerBlockade, line 42")
set T5w=wvu(e5w,"when calling getPos in TowerBlockade, line 48")
set Y5w=sf
set G5w=tf
set d5w=T5w
set f5w=Y5w
set R5w=G5w
set Fy[p5w]=B2w(Xru(rr,gy,d5w,f5w,R5w,0.),p5w,"when calling new_BlockadeShip in TowerBlockade, line 49")
set ky[p5w]=G5(Q,d5w,f5w,R5w)
call VU(e5w,p5w,"when calling addBuff in TowerBlockade, line 51")
call Etu(Nt[e5w],"stop")
call RVu(e5w,"when calling pause in TowerBlockade, line 53")
call QRu(p5w,"when calling refresh in TowerBlockade, line 54")
set Ad=Ad-1
endfunction
function pEw takes integer lEw,integer bEw,string yEw returns nothing
set Dd[Ad]=yEw
set Ad=Ad+1
set uu[lEw]=bEw
if not KU(bEw) then
call qI(bEw,"when calling newBuffs in PresetBuffs, line 34")
endif
call VU(bEw,lEw,"when calling addBuff in PresetBuffs, line 35")
call QRu(lEw,"when calling refresh in PresetBuffs, line 36")
call nRu(lEw,"when calling onApply in PresetBuffs, line 37")
set Ad=Ad-1
endfunction
function xWw takes integer gWw,integer hWw,string FWw returns nothing
local integer kWw
local integer jWw
set Dd[Ad]=FWw
set Ad=Ad+1
set uu[gWw]=hWw
if not KU(hWw) then
call qI(hWw,"when calling newBuffs in PresetBuffs, line 48")
endif
set kWw=lgw(iI(hWw),"when calling iterator in PresetBuffs, line 49")
loop
exitwhen not nGw(kWw)
set jWw=qGw(kWw)
if Ie[jWw]==Ie[gWw]then
set uu[gWw]=0
call J4u(2,gWw,"when calling terminate in PresetBuffs, line 52",0,null)
call RGw(kWw,"when calling close in PresetBuffs, line 49")
set Ad=Ad-1
return
endif
endloop
call RGw(kWw,"when calling close in PresetBuffs, line 49")
call VU(hWw,gWw,"when calling addBuff in PresetBuffs, line 54")
call QRu(gWw,"when calling refresh in PresetBuffs, line 55")
call nRu(gWw,"when calling onApply in PresetBuffs, line 56")
set Ad=Ad-1
endfunction
function eRu takes integer bRu,integer yRu,string pRu returns nothing
set Dd[Ad]=pRu
set Ad=Ad+1
if Ie[bRu]==0 then
if bRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_apply","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_apply on invalid object.","when calling error in ")
endif
endif
if Ie[bRu]<=644 then
if Ie[bRu]<=641 then
if Ie[bRu]<=639 then
call xWw(bRu,yRu,"when calling apply in Buff, line 83")
else
call ZWw(bRu,yRu,"when calling apply in Buff, line 83")
endif
elseif Ie[bRu]<=643 then
call VWw(bRu,yRu,"when calling apply in Buff, line 83")
else
call XHw(bRu,yRu,"when calling apply in Buff, line 83")
endif
elseif Ie[bRu]<=646 then
if Ie[bRu]<=645 then
call VWw(bRu,yRu,"when calling apply in Buff, line 83")
else
call Wlu(bRu,yRu,"when calling apply in Buff, line 83")
endif
elseif Ie[bRu]<=647 then
call pEw(bRu,yRu,"when calling apply in Buff, line 83")
else
call g5w(bRu,yRu,"when calling apply in Buff, line 83")
endif
set Ad=Ad-1
endfunction
function yI takes integer SI,integer cI,string oI returns nothing
local integer OI
local integer lI
local integer bI
set Dd[Ad]=oI
set Ad=Ad+1
if cI==0 then
call tsw("Target Entity may not be null","when calling error in Buff, line 51")
endif
if SI==0 then
call tsw("Origin Entity may not be null","when calling error in Buff, line 53")
endif
set OI=Bw[SI]
if OI==0 or sPu(OI,"when calling size in Buff, line 56")==0 then
set Ad=Ad-1
return
endif
if OI!=0 then
set bI=cPu(OI,"when calling staticItr in Buff, line 60")
loop
exitwhen not nGw(bI)
set lI=qGw(bI)
if not iu[lI]then
call DEw("Apply Buff")
call eRu(lI,cI,"when calling apply in Buff, line 63")
endif
endloop
call xIu(OI,"when calling LinkedList in Buff, line 64")
set Bw[SI]=0
endif
set Ad=Ad-1
endfunction
function B6w takes integer X6w,integer C6w,string V6w returns nothing
set Dd[Ad]=V6w
set Ad=Ad+1
call J2u(0,0,3,X6w,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Nt[C6w],0.,0.,0.,0.,"when calling construct_UnitEntity in Tower, line 25",null,null)
call yI(C6w,X6w,"when calling transferBuffs in Tower, line 27")
call J2u(0,0,0,0,0,0,C6w,"when calling terminate in Tower, line 28",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
endfunction
function I8w takes trigger E8w,unit Z8w,unitevent U8w returns nothing
call TriggerRegisterUnitEvent(E8w,Z8w,U8w)
endfunction
function RBu takes string dBu returns integer
local integer fBu
set Dd[Ad]=dBu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set fBu=Le
set Xe[fBu]=735
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set fBu=0
endif
else
set Ke=Ke-1
set fBu=Je[Ke]
set Xe[fBu]=735
endif
set Ad=Ad-1
return fBu
endfunction
function MVu takes string BVu returns integer
local integer NVu
set Dd[Ad]=BVu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set NVu=oe
set Oe[NVu]=869
else
call tsw("Out of memory: Could not create Troop.","when calling error in ")
set NVu=0
endif
else
set ce=ce-1
set NVu=Se[ce]
set Oe[NVu]=869
endif
set Ad=Ad-1
return NVu
endfunction
function p9u takes integer c9u,real o9u,real O9u,real l9u,player b9u,string y9u returns nothing
set Dd[Ad]=y9u
set Ad=Ad+1
call J2u(0,0,3,c9u,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Ssu(b9u,Hy,o9u,O9u,l9u,0.),0.,0.,0.,0.,"when calling construct_UnitEntity in TrooperTower, line 22",null,null)
call sxu(c9u,"when calling deactivate in TrooperTower, line 24")
call Osu(Nt[c9u],iw)
call SSu(Nt[c9u],Qh(0))
set Ad=Ad-1
endfunction
function S9u takes real w9u,real u9u,real r9u,player s9u,string t9u returns integer
local integer i9u
set Dd[Ad]=t9u
set Ad=Ad+1
set i9u=MVu("when calling Troop in TrooperTower, line 22")
call p9u(i9u,w9u,u9u,r9u,s9u,"when calling construct_Troop in TrooperTower, line 22")
set Ad=Ad-1
return i9u
endfunction
function l0u takes integer D9u,string H9u returns nothing
local real J9u
local real K9u
local integer L9u
local integer X9u
local real C9u
local real V9u
local real B9u
local unit N9u
local unit M9u
local unit w0u
local unit u0u
local integer r0u
local integer s0u
local real t0u
local real i0u
local real S0u
local integer c0u
local real o0u
local real O0u
set Dd[Ad]=H9u
set Ad=Ad+1
set c0u=Xy[D9u]
set r0u=D9u
call j3u(c0u,S9u(ht[r0u],Ft[r0u],kt[r0u],Et[D9u],"when calling new_Troop in TrooperTower, line 72"),"when calling add in TrooperTower, line 72")
set J9u=360./sPu(Xy[D9u],"when calling size in TrooperTower, line 74")
set K9u=0.
set L9u=lgw(Xy[D9u],"when calling iterator in TrooperTower, line 76")
loop
exitwhen not nGw(L9u)
set X9u=qGw(L9u)
set o0u=wou(EOu(wvu(D9u,"when calling getPos in TrooperTower, line 77"),sf,tf),Ef,vh(K9u),Ay)
set O0u=Cd
set s0u=D9u
set t0u=cou(o0u,O0u,xcu(ht[s0u],Ft[s0u],kt[s0u])+160.)
set i0u=Bd
set S0u=Nd
set C9u=t0u
set V9u=i0u
set B9u=S0u
set N9u=Nt[X9u]
call gB(N9u,Au,Du,Hu,Ju)
set M9u=N9u
call VSu(M9u)
set w0u=M9u
call viu(w0u,vh(K9u))
set u0u=w0u
call Osu(u0u,iw)
call J2u(0,1,X9u,0,0,0,0,null,C9u,V9u,B9u,0,0,0.,0.,0.,"when calling setXY in TrooperTower, line 82",null,0.,0.,0.,0.,null,null,null)
set K9u=K9u+J9u
endloop
call RGw(L9u,"when calling close in TrooperTower, line 76")
set Ad=Ad-1
set N9u=null
set M9u=null
set w0u=null
set u0u=null
endfunction
function bBu takes integer OBu,string lBu returns nothing
set Dd[Ad]=lBu
set Ad=Ad+1
if Oe[OBu]==0 then
if OBu==0 then
call tsw("Nullpointer exception when calling TrooperTower.TrooperTower_TrooperTower_addTrooper","when calling error in ")
else
call tsw("Called TrooperTower.TrooperTower_TrooperTower_addTrooper on invalid object.","when calling error in ")
endif
endif
call l0u(OBu,"when calling addTrooper in TrooperTower, line 71")
set Ad=Ad-1
endfunction
function x0u takes integer G0u,integer g0u,string h0u returns nothing
local integer F0u
local unit k0u
local playerunitevent j0u
set Dd[Ad]=h0u
set Ad=Ad+1
call B6w(G0u,g0u,"when calling construct_Tower2 in TrooperTower, line 39")
set Xy[G0u]=Ngw("when calling new_LinkedList in TrooperTower, line 36")
set Cy[G0u]=0
call bBu(G0u,"when calling addTrooper in TrooperTower, line 41")
call bBu(G0u,"when calling addTrooper in TrooperTower, line 42")
call bBu(G0u,"when calling addTrooper in TrooperTower, line 43")
call I8w(Ky,Nt[G0u],EVENT_UNIT_UPGRADE_START)
call I8w(Ly,Nt[G0u],EVENT_UNIT_UPGRADE_CANCEL)
set k0u=Nt[G0u]
set j0u=EVENT_PLAYER_UNIT_DEATH
set F0u=RBu("when calling alloc_Closure in TrooperTower, line 46")
call cL(F0u)
set Vy[F0u]=G0u
call fK(k0u,j0u,F0u,"when calling add in TrooperTower, line 46")
set Ad=Ad-1
set k0u=null
set j0u=null
endfunction
function F9u takes integer G9u,string g9u returns integer
local integer h9u
set Dd[Ad]=g9u
set Ad=Ad+1
set h9u=eBu("when calling TrooperTower in TrooperTower, line 39")
call x0u(h9u,G9u,"when calling construct_TrooperTower in TrooperTower, line 39")
set Ad=Ad-1
return h9u
endfunction
function EK takes unit vK,integer mK,string QK returns integer
local integer WK
set Dd[Ad]=QK
set Ad=Ad+1
set WK=gK(vK,-1,mK,"when calling addSpellInternal in ClosureEvents, line 142")
set Ad=Ad-1
return WK
endfunction
function qau takes string pau returns integer
local integer eau
set Dd[Ad]=pau
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set eau=ye
set pe[eau]=795
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set eau=0
endif
else
set be=be-1
set eau=le[be]
set pe[eau]=795
endif
set Ad=Ad-1
return eau
endfunction
function xL takes integer jL returns nothing
call qL(jL)
endfunction
function Ok takes integer ik,string Sk returns nothing
local integer ck
local unit ok
set Dd[Ad]=Sk
set Ad=Ad+1
set ok=Nt[ik]
set ck=qau("when calling alloc_Closure in ArtilleryTower, line 22")
call xL(ck)
set uw[ck]=ik
call EK(ok,ck,"when calling onCast in ArtilleryTower, line 22")
set Ad=Ad-1
set ok=null
endfunction
function Sau takes integer tau,string iau returns nothing
set Dd[Ad]=iau
set Ad=Ad+1
if Oe[tau]==0 then
if tau==0 then
call tsw("Nullpointer exception when calling ArtilleryTower.ArtilleryTower_ArtilleryTower_registerSpell","when calling error in ")
else
call tsw("Called ArtilleryTower.ArtilleryTower_ArtilleryTower_registerSpell on invalid object.","when calling error in ")
endif
endif
call Ok(tau,"when calling registerSpell in ArtilleryTower, line 21")
set Ad=Ad-1
endfunction
function Ek takes integer xk,integer vk,string mk returns nothing
local unit Qk
local unit Wk
set Dd[Ad]=mk
set Ad=Ad+1
call B6w(xk,vk,"when calling construct_Tower2 in ArtilleryTower, line 14")
set rw[xk]=1
set Qk=Nt[xk]
call SSu(Qk,Qh(0))
set Wk=Qk
call Osu(Wk,N)
call Sau(xk,"when calling registerSpell in ArtilleryTower, line 19")
set Ad=Ad-1
set Qk=null
set Wk=null
endfunction
function Oau takes string cau returns integer
local integer oau
set Dd[Ad]=cau
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set oau=oe
set Oe[oau]=862
else
call tsw("Out of memory: Could not create ArtilleryTower.","when calling error in ")
set oau=0
endif
else
set ce=ce-1
set oau=Se[ce]
set Oe[oau]=862
endif
set Ad=Ad-1
return oau
endfunction
function NF takes integer CF,string VF returns integer
local integer BF
set Dd[Ad]=VF
set Ad=Ad+1
set BF=Oau("when calling ArtilleryTower in ArtilleryTower, line 14")
call Ek(BF,CF,"when calling construct_ArtilleryTower in ArtilleryTower, line 14")
set Ad=Ad-1
return BF
endfunction
function Cdw takes integer Kdw,integer Ldw,string Xdw returns nothing
set Dd[Ad]=Xdw
set Ad=Ad+1
call B6w(Kdw,Ldw,"when calling construct_Tower2 in HealbackTower, line 19")
set QS[Kdw]=1
set Ad=Ad-1
endfunction
function eZu takes string yZu returns integer
local integer pZu
set Dd[Ad]=yZu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set pZu=oe
set Oe[pZu]=864
else
call tsw("Out of memory: Could not create HealbackTower.","when calling error in ")
set pZu=0
endif
else
set ce=ce-1
set pZu=Se[ce]
set Oe[pZu]=864
endif
set Ad=Ad-1
return pZu
endfunction
function Pnw takes integer Znw,string Unw returns integer
local integer Inw
set Dd[Ad]=Unw
set Ad=Ad+1
set Inw=eZu("when calling HealbackTower in HealbackTower, line 19")
call Cdw(Inw,Znw,"when calling construct_HealbackTower in HealbackTower, line 19")
set Ad=Ad-1
return Inw
endfunction
function WNu takes string mNu returns integer
local integer QNu
set Dd[Ad]=mNu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set QNu=oe
set Oe[QNu]=867
else
call tsw("Out of memory: Could not create WaveTower.","when calling error in ")
set QNu=0
endif
else
set ce=ce-1
set QNu=Se[ce]
set Oe[QNu]=867
endif
set Ad=Ad-1
return QNu
endfunction
function npu takes integer epu,integer qpu,string apu returns nothing
set Dd[Ad]=apu
set Ad=Ad+1
call B6w(epu,qpu,"when calling construct_Tower2 in WaveTower, line 14")
set Wp[epu]=1
set Ad=Ad-1
endfunction
function bpu takes integer opu,string Opu returns integer
local integer lpu
set Dd[Ad]=Opu
set Ad=Ad+1
set lpu=WNu("when calling WaveTower in WaveTower, line 14")
call npu(lpu,opu,"when calling construct_WaveTower in WaveTower, line 14")
set Ad=Ad-1
return lpu
endfunction
function mow takes integer jow,integer xow,string vow returns nothing
set Dd[Ad]=vow
set Ad=Ad+1
call B6w(jow,xow,"when calling construct_Tower2 in FlamethrowerTower, line 17")
set ji[jow]=1
set Ad=Ad-1
endfunction
function vmu takes string jmu returns integer
local integer xmu
set Dd[Ad]=jmu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set xmu=oe
set Oe[xmu]=863
else
call tsw("Out of memory: Could not create FlamethrowerTower.","when calling error in ")
set xmu=0
endif
else
set ce=ce-1
set xmu=Se[ce]
set Oe[xmu]=863
endif
set Ad=Ad-1
return xmu
endfunction
function how takes integer Yow,string Gow returns integer
local integer gow
set Dd[Ad]=Gow
set Ad=Ad+1
set gow=vmu("when calling FlamethrowerTower in FlamethrowerTower, line 17")
call mow(gow,Yow,"when calling construct_FlamethrowerTower in FlamethrowerTower, line 17")
set Ad=Ad-1
return gow
endfunction
function kEw takes integer hEw,string FEw returns nothing
call YEw(lO,hEw,FEw)
endfunction
function Q6w takes integer x6w,string v6w returns nothing
local integer m6w
set Dd[Ad]=v6w
set Ad=Ad+1
set m6w=Jsu(Nt[x6w])
if m6w==jp then
call Sww(Nt[x6w],0)
call bpu(x6w,"when calling new_WaveTower in Tower, line 39")
elseif m6w==Dy then
call Sww(Nt[x6w],0)
call F9u(x6w,"when calling new_TrooperTower in Tower, line 42")
elseif m6w==Fi then
call Sww(Nt[x6w],0)
call how(x6w,"when calling new_FlamethrowerTower in Tower, line 45")
elseif m6w==B then
call Sww(Nt[x6w],0)
call NF(x6w,"when calling new_ArtilleryTower in Tower, line 48")
elseif m6w==qS then
call Sww(Nt[x6w],0)
call Pnw(x6w,"when calling new_HealbackTower in Tower, line 51")
else
call kEw(0,"upgrade not catched")
endif
call Etu(Nt[x6w],"stop")
set Ad=Ad-1
endfunction
function kow takes integer Fow returns nothing
call Itu(Nt[Fow],OrderId("stop"))
set ji[Fow]=ji[Fow]+1
endfunction
function JEw takes string HEw returns nothing
call YEw(lO,2,HEw)
endfunction
function ppu takes integer ypu returns nothing
call Itu(Nt[ypu],OrderId("stop"))
call JEw("Mori is weeb")
set Wp[ypu]=Wp[ypu]+1
endfunction
function tk takes integer MF returns nothing
local unit wk
local unit uk
local unit rk
local unit sk
set rw[MF]=rw[MF]+1
set wk=Nt[MF]
call Osu(wk,N)
set uk=wk
call diu(uk,N,rw[MF])
set rk=uk
call SSu(rk,Qh(0))
set sk=rk
call Itu(sk,OrderId("stop"))
set wk=null
set uk=null
set rk=null
set sk=null
endfunction
function x9u takes integer k9u,string j9u returns nothing
set Dd[Ad]=j9u
set Ad=Ad+1
set Cy[k9u]=Cy[k9u]+1
call bBu(k9u,"when calling addTrooper in TrooperTower, line 51")
call Etu(Nt[k9u],"stop")
set Ad=Ad-1
endfunction
function nVu takes integer qVu,string aVu returns nothing
set Dd[Ad]=aVu
set Ad=Ad+1
if Oe[qVu]==0 then
if qVu==0 then
call tsw("Nullpointer exception when calling Tower.Tower_Tower_onUpgrade","when calling error in ")
else
call tsw("Called Tower.Tower_Tower_onUpgrade on invalid object.","when calling error in ")
endif
endif
if Oe[qVu]<=864 then
if Oe[qVu]<=862 then
if Oe[qVu]<=861 then
call Q6w(qVu,"when calling onUpgrade in Tower, line 35")
else
call tk(qVu)
endif
elseif Oe[qVu]<=863 then
call kow(qVu)
else
call Dnw(qVu)
endif
elseif Oe[qVu]<=866 then
if Oe[qVu]<=865 then
call D4w(qVu)
else
call x9u(qVu,"when calling onUpgrade in Tower, line 35")
endif
else
call ppu(qVu)
endif
set Ad=Ad-1
endfunction
function e6w takes integer y6w,string p6w returns nothing
set Dd[Ad]=p6w
set Ad=Ad+1
call nVu(my[y6w],"when calling onUpgrade in Tower, line 81")
set Ad=Ad-1
endfunction
function Jtu takes unit Ptu,string Atu,real Dtu,real Htu returns boolean
return IssuePointOrder(Ptu,Atu,Dtu,Htu)
endfunction
function fM takes integer aM returns nothing
local unit dM=Nt[cr[aM]]
local integer nM=aM
call Jtu(dM,"attack",lr[nM],br[nM])
set dM=null
endfunction
function EWu takes string QWu returns integer
local integer WWu
set Dd[Ad]=QWu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set WWu=ae
set ne[WWu]=677
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set WWu=0
endif
else
set qe=qe-1
set WWu=ee[qe]
set ne[WWu]=677
endif
set Ad=Ad-1
return WWu
endfunction
function hWu takes string GWu returns integer
local integer gWu
set Dd[Ad]=GWu
set Ad=Ad+1
if cq==0 then
if oq<32768 then
set oq=oq+1
set gWu=oq
set Oq[gWu]=652
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set gWu=0
endif
else
set cq=cq-1
set gWu=Sq[cq]
set Oq[gWu]=652
endif
set Ad=Ad-1
return gWu
endfunction
function jWu takes string FWu returns integer
local integer kWu
set Dd[Ad]=FWu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set kWu=ae
set ne[kWu]=676
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set kWu=0
endif
else
set qe=qe-1
set kWu=ee[qe]
set ne[kWu]=676
endif
set Ad=Ad-1
return kWu
endfunction
function gyw takes integer dyw,string fyw returns nothing
local integer Ryw
local integer Tyw
local integer Yyw
local integer Gyw
set Dd[Ad]=fyw
set Ad=Ad+1
set Ryw=xKu(Ki,"when calling play in GameInit, line 49")
set Tyw=hWu("when calling alloc_Closure in GameInit, line 50")
call bC(Tyw)
set Li[Tyw]=Ryw
call HX(0.3,10.,Tyw,"when calling doPeriodicallyTimed in GameInit, line 50")
set Yyw=jWu("when calling alloc_Closure in GameInit, line 53")
call VC(Yyw)
call gX(0.55,Yyw,"when calling doAfter in GameInit, line 53")
set Gyw=EWu("when calling alloc_Closure in GameInit, line 57")
call VC(Gyw)
set Ci[Gyw]=Vi[dyw]
call gX(14.25,Gyw,"when calling doAfter in GameInit, line 57")
set Ad=Ad-1
endfunction
function Aqu takes widget Pqu returns real
return GetWidgetLife(Pqu)
endfunction
function hFw takes integer gFw returns nothing
if fo[gFw]!=null and Aqu(fo[gFw])>.405 then
call Jfw(fo[gFw])
endif
endfunction
function YFu takes string RFu returns integer
local integer TFu
set Dd[Ad]=RFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set TFu=Cq
set Vq[TFu]=744
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set TFu=0
endif
else
set Xq=Xq-1
set TFu=Lq[Xq]
set Vq[TFu]=744
endif
set Ad=Ad-1
return TFu
endfunction
function hFu takes string GFu returns integer
local integer gFu
set Dd[Ad]=GFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set gFu=Cq
set Vq[gFu]=745
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set gFu=0
endif
else
set Xq=Xq-1
set gFu=Lq[Xq]
set Vq[gFu]=745
endif
set Ad=Ad-1
return gFu
endfunction
function Jx takes integer Hx returns integer
return qw[Hx]-aw[Hx]
endfunction
function hnu takes integer Ynu,string Gnu returns integer
local integer gnu
set Dd[Ad]=Gnu
set Ad=Ad+1
if xe[Ynu]==0 then
if Ynu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_getLength","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_getLength on invalid object.","when calling error in ")
endif
endif
set gnu=Jx(Ynu)
set Ad=Ad-1
return gnu
endfunction
function jFu takes string FFu returns integer
local integer kFu
set Dd[Ad]=FFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set kFu=Cq
set Vq[kFu]=746
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set kFu=0
endif
else
set Xq=Xq-1
set kFu=Lq[Xq]
set Vq[kFu]=746
endif
set Ad=Ad-1
return kFu
endfunction
function mFu takes string xFu returns integer
local integer vFu
set Dd[Ad]=xFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set vFu=Cq
set Vq[vFu]=747
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set vFu=0
endif
else
set Xq=Xq-1
set vFu=Lq[Xq]
set Vq[vFu]=747
endif
set Ad=Ad-1
return vFu
endfunction
function i7 takes integer M6,string w7 returns nothing
local integer u7
local integer r7
local integer s7
local integer t7
set Dd[Ad]=w7
set Ad=Ad+1
call DEw("hash: "+bfw(wt[As[M6]]))
set u7=YFu("when calling alloc_Closure in Encoder, line 114")
set Ws[u7]=As[M6]
call xsw(u7,"when calling execute in Encoder, line 114")
call DEw("encoded hash")
set r7=hFu("when calling alloc_Closure in Encoder, line 116")
set Es[r7]=As[M6]
call xsw(r7,"when calling execute in Encoder, line 116")
call DEw("clean")
set s7=jFu("when calling alloc_Closure in Encoder, line 118")
set Zs[s7]=As[M6]
call xsw(s7,"when calling execute in Encoder, line 118")
call DEw("before toString bs: "+bfw(hnu(Ds[M6],"when calling getLength in Encoder, line 119")))
set t7=mFu("when calling alloc_Closure in Encoder, line 120")
set Us[t7]=As[M6]
set Is[t7]=Ds[M6]
set Ps[t7]=Hs[M6]
call xsw(t7,"when calling execute in Encoder, line 120")
set Ad=Ad-1
endfunction
function jk takes integer gk returns nothing
local unit hk=Nt[ww[gk]]
local unit Fk
local unit kk
call Itu(hk,OrderId("stop"))
set Fk=hk
call eiu(Fk,N)
set kk=Fk
call Osu(kk,N)
set hk=null
set Fk=null
set kk=null
endfunction
function f8w takes trigger a8w,region n8w,boolexpr d8w returns nothing
call TriggerRegisterEnterRegion(a8w,n8w,d8w)
endfunction
function Wpw takes group vpw,rect mpw,boolexpr Qpw returns nothing
call GroupEnumUnitsInRect(vpw,mpw,Qpw)
endfunction
function xpw takes group kpw,rect jpw returns nothing
call Wpw(kpw,jpw,null)
endfunction
function jxw takes integer gxw returns nothing
local trigger hxw=CreateTrigger()
local group Fxw
local group kxw
call f8w(hxw,Go,Filter(Og))
call AUw(EVENT_PLAYER_UNIT_ISSUED_ORDER,lg)
call xpw(Do,Yo)
call ForGroup(Do,bg)
set Fxw=Do
call Zpw(Fxw)
set kxw=Fxw
call Ipw(kxw)
set hxw=null
set Fxw=null
set kxw=null
endfunction
function KCu takes string HCu returns integer
local integer JCu
set Dd[Ad]=HCu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set JCu=Ue
set Ie[JCu]=648
else
call tsw("Out of memory: Could not create TowerBlockadeBuff.","when calling error in ")
set JCu=0
endif
else
set Ze=Ze-1
set JCu=Ee[Ze]
set Ie[JCu]=648
endif
set Ad=Ad-1
return JCu
endfunction
function DCu takes integer ICu,integer PCu,string ACu returns nothing
set Dd[Ad]=ACu
set Ad=Ad+1
if Ie[ICu]==0 then
if ICu==0 then
call tsw("Nullpointer exception when calling TowerBlockadeBuff.TowerBlockade_TowerBlockadeBuff_apply","when calling error in ")
else
call tsw("Called TowerBlockadeBuff.TowerBlockade_TowerBlockadeBuff_apply on invalid object.","when calling error in ")
endif
endif
call g5w(ICu,PCu,"when calling apply in TowerBlockade, line 38")
set Ad=Ad-1
endfunction
function Z5w takes integer Q5w,integer W5w,string E5w returns nothing
set Dd[Ad]=E5w
set Ad=Ad+1
call EP(Q5w,Yy,Ry,Ty)
call f1w(wvu(W5w,"when calling getPos in TowerBlockade, line 35"),sf,tf,GetRandomReal(-1.,1.),0.,GetRandomReal(6.,8.),"Blockaded!",8.,1.,145,80,12,255,"when calling new_TextTagEntity in TowerBlockade, line 35")
call DCu(Q5w,W5w,"when calling apply in TowerBlockade, line 36")
set Ad=Ad-1
endfunction
function m5w takes integer j5w,string x5w returns integer
local integer v5w
set Dd[Ad]=x5w
set Ad=Ad+1
set v5w=KCu("when calling TowerBlockadeBuff in TowerBlockade, line 33")
call Z5w(v5w,j5w,"when calling construct_TowerBlockadeBuff in TowerBlockade, line 33")
set Ad=Ad-1
return v5w
endfunction
function m9 takes integer x9,string v9 returns nothing
set Dd[Ad]=v9
set Ad=Ad+1
call m5w(et[x9],"when calling new_TowerBlockadeBuff in EndBoss, line 91")
set Ad=Ad-1
endfunction
function Ojw takes multiboard Sjw,integer cjw,integer ojw returns multiboarditem
return MultiboardGetItem(Sjw,cjw,ojw)
endfunction
function Pjw takes multiboarditem Ujw,real Ijw returns nothing
call MultiboardSetItemWidth(Ujw,Ijw)
endfunction
function Qjw takes multiboarditem xjw,boolean vjw,boolean mjw returns nothing
call MultiboardSetItemStyle(xjw,vjw,mjw)
endfunction
function Zjw takes multiboarditem Wjw,string Ejw returns nothing
call MultiboardSetItemValue(Wjw,Ejw)
endfunction
function hjw takes multiboard Gjw,string gjw returns nothing
call MultiboardSetTitleText(Gjw,gjw)
endfunction
function jjw takes multiboarditem Fjw,string kjw returns nothing
call MultiboardSetItemIcon(Fjw,kjw)
endfunction
function qjw takes multiboard pjw,integer ejw returns nothing
call MultiboardSetRowCount(pjw,ejw)
endfunction
function yjw takes multiboard ljw,integer bjw returns nothing
call MultiboardSetColumnCount(ljw,bjw)
endfunction
function Nkw takes string Ekw returns nothing
local integer Zkw
local integer Ukw
local integer Ikw
local multiboarditem Pkw
local multiboarditem Akw
local multiboarditem Dkw
local multiboarditem Hkw
local multiboarditem Jkw
local multiboarditem Kkw
local multiboarditem Lkw
local multiboarditem Xkw
local multiboarditem Ckw
local multiboarditem Vkw
local multiboarditem Bkw
set Dd[Ad]=Ekw
set Ad=Ad+1
call qjw(Wo,sPu(Mo,"when calling size in MultiboardSystem, line 18"))
call yjw(Wo,4)
call hjw(Wo,"Forest Defense")
set Zkw=0
set Ukw=lgw(Mo,"when calling iterator in MultiboardSystem, line 22")
loop
exitwhen not nGw(Ukw)
set Ikw=qGw(Ukw)
set Pkw=Ojw(Wo,Zkw,0)
call Qjw(Pkw,true,false)
set Akw=Pkw
call Pjw(Akw,0.05)
if tO[Ikw]then
call Zjw(Ojw(Wo,Zkw,0),ZV(rO[Ikw]))
else
call Zjw(Ojw(Wo,Zkw,0),"|cff636363†"+mQw(rO[Ikw])+"|r")
endif
set Dkw=Ojw(Wo,Zkw,1)
call Zjw(Dkw,bfw(hQw(rO[Ikw])))
set Hkw=Dkw
call jjw(Hkw,"UI\\Feedback\\Resources\\ResourceGold.blp")
set Jkw=Hkw
call Pjw(Jkw,0.035)
set Kkw=Ojw(Wo,Zkw,2)
call Zjw(Kkw,bfw(xQw(rO[Ikw])))
set Lkw=Kkw
call jjw(Lkw,"UI\\Feedback\\Resources\\ResourceLumber.blp")
set Xkw=Lkw
call Pjw(Xkw,0.025)
set Ckw=Ojw(Wo,Zkw,3)
call Zjw(Ckw,bfw(sO[Ikw]))
set Vkw=Ckw
call jjw(Vkw,"ReplaceableTextures\\CommandButtons\\BTNSacrifice.blp")
set Bkw=Vkw
call Pjw(Bkw,0.035)
set Zkw=Zkw+1
endloop
call RGw(Ukw,"when calling close in MultiboardSystem, line 22")
set Ad=Ad-1
set Pkw=null
set Akw=null
set Dkw=null
set Hkw=null
set Jkw=null
set Kkw=null
set Lkw=null
set Xkw=null
set Ckw=null
set Vkw=null
set Bkw=null
endfunction
function ijw takes multiboard sjw,boolean tjw returns nothing
call MultiboardDisplay(sjw,tjw)
endfunction
function Wkw takes string Qkw returns nothing
set Dd[Ad]=Qkw
set Ad=Ad+1
set Wo=CreateMultiboard()
call Nkw("when calling update in MultiboardSystem, line 12")
call ijw(Wo,true)
call Q2w(CreateTimer(),0.5,og)
set Ad=Ad-1
endfunction
function mkw takes integer xkw,string vkw returns nothing
set Dd[Ad]=vkw
set Ad=Ad+1
call Wkw("when calling initMultiboard in MultiboardSystem, line 7")
set Ad=Ad-1
endfunction
function nBw takes integer pBw,string eBw returns nothing
local integer qBw
local integer aBw
set Dd[Ad]=eBw
set Ad=Ad+1
set qBw=0
loop
exitwhen qBw>3
set aBw=pBw
call kBw(hou(Gb[aBw],gb[aBw],hb[aBw],GetRandomReal(-16.,16.),GetRandomReal(-16.,16.)),Uf,If,Wb,8,Up,Ip,"when calling new_SpecialTwo in SpecialTwo, line 22")
set qBw=qBw+1
endloop
set Ad=Ad-1
endfunction
function u8 takes integer B7,string N7 returns nothing
local integer M7
local integer w8
set Dd[Ad]=N7
set Ad=Ad+1
set M7=lgw(Mo,"when calling iterator in EndBoss, line 152")
loop
exitwhen not nGw(M7)
set w8=qGw(M7)
call CustomVictoryBJ(rO[w8],true,false)
endloop
call RGw(M7,"when calling close in EndBoss, line 152")
set Ad=Ad-1
endfunction
function yM takes integer bM returns nothing
if sr[bM]!=null and GetWidgetLife(sr[bM])>.405 then
call Jfw(sr[bM])
endif
endfunction
function CYu takes integer LYu,string XYu returns nothing
set Dd[Ad]=XYu
set Ad=Ad+1
if ne[LYu]==0 then
if LYu==0 then
call tsw("Nullpointer exception when calling CallbackSingle.ClosureTimers_CallbackSingle_call","when calling error in ")
else
call tsw("Called CallbackSingle.ClosureTimers_CallbackSingle_call on invalid object.","when calling error in ")
endif
endif
if ne[LYu]<=675 then
if ne[LYu]<=666 then
if ne[LYu]<=661 then
if ne[LYu]<=659 then
if ne[LYu]<=658 then
if ne[LYu]<=657 then
call jk(LYu)
else
call Um(LYu)
endif
else
call Jm(LYu)
endif
elseif ne[LYu]<=660 then
call AI(LYu,"when calling Buff_closure_impl in ClosureTimers, line 65")
else
call BI(LYu,"when calling Buff_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=664 then
if ne[LYu]<=663 then
if ne[LYu]<=662 then
call NA(LYu)
else
call NJ(LYu)
endif
else
call KX(LYu)
endif
elseif ne[LYu]<=665 then
call XX(LYu)
else
call VX(LYu)
endif
elseif ne[LYu]<=671 then
if ne[LYu]<=669 then
if ne[LYu]<=668 then
if ne[LYu]<=667 then
call yM(LYu)
else
call fM(LYu)
endif
else
call F1(LYu,"when calling FinalBossSummoning_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=670 then
call i7(LYu,"when calling Encoder_closure_impl in ClosureTimers, line 65")
else
call u8(LYu,"when calling EndBoss_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=673 then
if ne[LYu]<=672 then
call m9(LYu,"when calling EndBoss_closure_impl in ClosureTimers, line 65")
else
call bSw(LYu,"when calling FText_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=674 then
call Pbw(LYu)
else
call gyw(LYu,"when calling GameInit_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=685 then
if ne[LYu]<=680 then
if ne[LYu]<=678 then
if ne[LYu]<=677 then
if ne[LYu]<=676 then
call Qyw(LYu,"when calling GameInit_closure_impl in ClosureTimers, line 65")
else
call Ayw(LYu,"when calling GameInit_closure_impl in ClosureTimers, line 65")
endif
else
call KTw(LYu,"when calling LZW_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=679 then
call hFw(LYu)
else
call mkw(LYu,"when calling MultiboardSystem_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=683 then
if ne[LYu]<=682 then
if ne[LYu]<=681 then
call jxw(LYu)
else
call GWw(LYu,"when calling Preloader_closure_impl in ClosureTimers, line 65")
endif
else
call HDw(LYu)
endif
elseif ne[LYu]<=684 then
call DXw(LYu)
else
call XXw(LYu,"when calling SpecialFive_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=690 then
if ne[LYu]<=688 then
if ne[LYu]<=687 then
if ne[LYu]<=686 then
call nBw(LYu,"when calling SpecialTwo_closure_impl in ClosureTimers, line 65")
else
call QBw(LYu,"when calling SpecialTwo_closure_impl in ClosureTimers, line 65")
endif
else
call UBw(LYu,"when calling SpecialTwo_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=689 then
call VMw(LYu)
else
call e6w(LYu,"when calling Tower_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=692 then
if ne[LYu]<=691 then
call Z7w(LYu,"when calling TownBell_closure_impl in ClosureTimers, line 65")
else
call Deu(LYu,"when calling NormalWave_closure_impl in ClosureTimers, line 65")
endif
elseif ne[LYu]<=693 then
call Rqu(LYu,"when calling SpecialWave_closure_impl in ClosureTimers, line 65")
else
call Gqu(LYu,"when calling SpecialWave_closure_impl in ClosureTimers, line 65")
endif
set Ad=Ad-1
endfunction
function JC takes string AC returns nothing
local timer DC
local integer HC
set Dd[Ad]=AC
set Ad=Ad+1
set DC=GetExpiredTimer()
set HC=c2w(DC,"when calling getData in ClosureTimers, line 75")
call CYu(HC,"when calling call in ClosureTimers, line 76")
call KYu(HC,"when calling CallbackSingle in ClosureTimers, line 77")
set Ad=Ad-1
set DC=null
endfunction
function PC takes string IC returns nothing
set Dd[Ad]=IC
set Ad=Ad+1
call JC("when calling staticCallback in ClosureTimers, line 70")
set Ad=Ad-1
endfunction
function M1u takes nothing returns nothing
set Ad=0
call PC("ClosureTimers, line 68")
endfunction
function GJ takes unit YJ returns nothing
if pJ(YJ) then
call I8w(eu,YJ,EVENT_UNIT_DAMAGED)
endif
endfunction
function f_u takes nothing returns unit
return rp
endfunction
function MJ takes nothing returns nothing
call GJ(f_u())
endfunction
function MSu takes nothing returns boolean
set yp="Units\\Undead\\Abomination\\AbominationExplosion.mdx"
return true
endfunction
function Mdw takes nothing returns boolean
return true
endfunction
function Jww takes integer Uww,real Iww,real Pww,real Aww,string Dww returns nothing
local integer Hww
set Dd[Ad]=Dww
set Ad=Ad+1
set Hww=Uww
set ht[Hww]=Iww
set Ft[Hww]=Pww
set kt[Hww]=Aww
if Aww>xcu(Iww,Pww,Aww) and mt[Uww]!=0. then
call Sxu(Uww,"when calling activate in Entity, line 113")
endif
set Ad=Ad-1
endfunction
function sSu takes unit Miu,real wSu,real uSu,real rSu returns nothing
call Niu(Miu,wSu,uSu)
call Nru(Miu,rSu-xcu(wSu,uSu,rSu),0.)
endfunction
function Grw takes integer erw,real qrw,real arw,real nrw,string drw returns nothing
local integer frw
local integer Rrw
local unit Trw
local unit Yrw
set Dd[Ad]=drw
set Ad=Ad+1
call Jww(erw,qrw,arw,nrw,"when calling setPos in Entity, line 248")
if xi then
set Trw=Nt[erw]
set frw=erw
call sSu(Trw,ht[frw],Ft[frw],kt[frw])
else
set Yrw=Nt[erw]
set Rrw=erw
call Xiu(Yrw,EOu(ht[Rrw],Ft[Rrw],kt[Rrw]),Ef)
endif
set Ad=Ad-1
set Trw=null
set Yrw=null
endfunction
function Jxu takes integer Ixu,real Pxu,real Axu,real Dxu,string Hxu returns nothing
set Dd[Ad]=Hxu
set Ad=Ad+1
if Oe[Ixu]==0 then
if Ixu==0 then
call tsw("Nullpointer exception when calling UnitEntity.Entity_UnitEntity_setPos","when calling error in ")
else
call tsw("Called UnitEntity.Entity_UnitEntity_setPos on invalid object.","when calling error in ")
endif
endif
call Grw(Ixu,Pxu,Axu,Dxu,"when calling setPos in Entity, line 247")
set Ad=Ad-1
endfunction
function G1 takes integer o1,string O1 returns nothing
local integer l1
local integer b1
local integer y1
local integer p1
local texttag e1
local texttag q1
local texttag a1
local integer n1
local integer d1
local integer f1
local integer R1
local integer T1
local unit Y1
set Dd[Ad]=O1
set Ad=Ad+1
set Wr[o1]=ModuloReal(Wr[o1]+kr/jr,1.)
if Er[o1]>0 or Qr[o1]>0. then
set l1=PercentTo255(Qr[o1])
if Ur[o1]==0 then
set R1=o1
set b1=abw(PLAYER_COLOR_LIGHT_GRAY,Ycu(Up,Ip),jf,xf,0.,L,"when calling new_Fx in DestroyerSummoner, line 58")
call kQu(b1,255,255,255,0,"when calling setColor in DestroyerSummoner, line 58")
set Ur[R1]=b1
endif
set y1=Ur[o1]
call iQu(y1,1.2+Qr[o1]/75.,"when calling setScale in DestroyerSummoner, line 59")
set p1=y1
call kQu(p1,63+bUw(l1*3./4.),0,0,l1,"when calling setColor in DestroyerSummoner, line 59")
set e1=pi[Pr[o1]]
call F4w(e1,true)
set q1=e1
call c4w(q1,bfw(bUw(Qr[o1]))+"%",12.)
set a1=q1
call B1w(a1,l1,255-l1,0,255)
else
if Ur[o1]!=0 then
call Bmu(Ur[o1],"when calling Fx in DestroyerSummoner, line 65")
endif
call F4w(pi[Pr[o1]],false)
endif
set n1=0
set d1=lgw(Zr[o1],"when calling iterator in DestroyerSummoner, line 68")
loop
exitwhen not nGw(d1)
set f1=qGw(d1)
if xr[f1]then
call Jxu(f1,Mou(Ycu(wou(Up,Ip,(Wr[o1]+(n1-Er[o1])*1./Er[o1])*6.28,200.),Cd),jf,xf,0.,0.,120.),yR,pR,"when calling setPos in DestroyerSummoner, line 70")
set Y1=Nt[f1]
set T1=f1
call viu(Y1,qlu(ht[T1],Ft[T1],kt[T1],Up,Ip))
set n1=n1+1
endif
endloop
call RGw(d1,"when calling close in DestroyerSummoner, line 68")
set Ad=Ad-1
set e1=null
set q1=null
set a1=null
set Y1=null
endfunction
function HGu takes integer AGu,string DGu returns nothing
set Dd[Ad]=DGu
set Ad=Ad+1
if nq[AGu]==0 then
if AGu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_updateAnimation","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_updateAnimation on invalid object.","when calling error in ")
endif
endif
call G1(AGu,"when calling updateAnimation in DestroyerSummoner, line 53")
set Ad=Ad-1
endfunction
function V3 takes integer X3,integer C3 returns real
if C3<=0 then
return -3.
endif
return C3*1./4+C3*C3*1./4
endfunction
function MGu takes integer CGu,integer VGu,string BGu returns real
local real NGu
set Dd[Ad]=BGu
set Ad=Ad+1
if nq[CGu]==0 then
if CGu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_getSummonSpeed","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_getSummonSpeed on invalid object.","when calling error in ")
endif
endif
set NGu=V3(CGu,VGu)
set Ad=Ad-1
return NGu
endfunction
function Ccu takes real Jcu,real Kcu,real Lcu,real Xcu returns real
return Uh(Atan2(Xcu-Kcu,Lcu-Jcu))
endfunction
function Hlw takes integer Elw,real Zlw,real Ulw,real Ilw,string Plw,string Alw returns nothing
local integer Dlw
set Dd[Ad]=Alw
set Ad=Ad+1
set Zi[Elw]=null
set Ui[Elw]=null
set Dlw=Elw
set Ii[Dlw]=255
set Pi[Dlw]=255
set Ai[Dlw]=255
set Di[Dlw]=255
set Zi[Elw]=V2(Zlw,Ulw,Ilw,"when calling get in Fx, line 39")
call NQu(Elw,Plw,"when calling setFx in Fx, line 40")
set Ad=Ad-1
endfunction
function Wlw takes real klw,real jlw,real xlw,string vlw,string mlw returns integer
local integer Qlw
set Dd[Ad]=mlw
set Ad=Ad+1
set Qlw=tWu("when calling Fx in Fx, line 38")
call Hlw(Qlw,klw,jlw,xlw,vlw,"when calling construct_Fx4 in Fx, line 38")
set Ad=Ad-1
return Qlw
endfunction
function qgu takes string pgu returns integer
local integer egu
set Dd[Ad]=pgu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set egu=ae
set ne[egu]=669
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set egu=0
endif
else
set qe=qe-1
set egu=ee[qe]
set ne[egu]=669
endif
set Ad=Ad-1
return egu
endfunction
function c1 takes integer B3,string N3 returns nothing
local real M3
local real w1
local integer u1
local integer r1
local integer s1
local integer t1
local real i1
local real S1
set Dd[Ad]=N3
set Ad=Ad+1
set i1=wou(Up,Ip,Wr[B3]*6.28,200.)
set S1=Cd
set M3=i1
set w1=S1
set u1=Wlw(M3,w1,0.,Z,"when calling new_Fx in DestroyerSummoner, line 91")
set s1=Wlw(Up,Ip,0.,Z,"when calling new_Fx in DestroyerSummoner, line 92")
call iQu(s1,2.,"when calling setScale in DestroyerSummoner, line 92")
set r1=s1
set t1=qgu("when calling alloc_Closure in DestroyerSummoner, line 93")
call VC(t1)
set vr[t1]=u1
set mr[t1]=r1
call gX(2.,t1,"when calling doAfter in DestroyerSummoner, line 93")
call J2u(0,0,0,0,6,0,0,null,Ycu(M3,w1),jf,xf,Yr,hr,Up,Ip,Ccu(M3,w1,Up,Ip),"when calling new_Creep in DestroyerSummoner, line 96",null,0.,0.,0.,0.,null,null,null)
call Tku(Ar[B3],"when calling endDestroyerSummoning in DestroyerSummoner, line 97")
set Ad=Ad-1
endfunction
function Sgu takes integer tgu,string igu returns nothing
set Dd[Ad]=igu
set Ad=Ad+1
if nq[tgu]==0 then
if tgu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_summonDestroyer","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_summonDestroyer on invalid object.","when calling error in ")
endif
endif
call c1(tgu,"when calling summonDestroyer in DestroyerSummoner, line 89")
set Ad=Ad-1
endfunction
function L3 takes integer J3,integer K3 returns nothing
set It[K3]=true
set xr[K3]=true
call Osu(Nt[K3],Gr)
call Oiu(Nt[K3],"attack spell")
endfunction
function XGu takes integer JGu,integer KGu,string LGu returns nothing
set Dd[Ad]=LGu
set Ad=Ad+1
if nq[JGu]==0 then
if JGu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_startCasting","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_startCasting on invalid object.","when calling error in ")
endif
endif
call L3(JGu,KGu)
set Ad=Ad-1
endfunction
function H3 takes integer U3,string I3 returns nothing
local integer P3
local integer A3
local integer D3
set Dd[Ad]=I3
set Ad=Ad+1
set P3=0
set A3=lgw(Zr[U3],"when calling iterator in DestroyerSummoner, line 33")
loop
exitwhen not nGw(A3)
set D3=qGw(A3)
if xtu(Nt[D3]) then
if not xr[D3]then
if VOu(wvu(D3,"when calling getPos in DestroyerSummoner, line 36"),sf,tf,Up,Ip)<220. then
call XGu(U3,D3,"when calling startCasting in DestroyerSummoner, line 37")
set P3=P3+1
endif
else
set P3=P3+1
endif
else
call MIu(Zr[U3],D3,"when calling remove in DestroyerSummoner, line 42")
endif
endloop
call RGw(A3,"when calling close in DestroyerSummoner, line 33")
set Er[U3]=P3
set Qr[U3]=Qr[U3]+MGu(U3,Er[U3],"when calling getSummonSpeed in DestroyerSummoner, line 44")*(kr*100./Fr)
if Qr[U3]<0. then
set Qr[U3]=0.
endif
if Qr[U3]>=100. then
set Qr[U3]=100.
call Sgu(U3,"when calling summonDestroyer in DestroyerSummoner, line 49")
else
call HGu(U3,"when calling updateAnimation in DestroyerSummoner, line 51")
endif
set Ad=Ad-1
endfunction
function PGu takes integer UGu,string IGu returns nothing
set Dd[Ad]=IGu
set Ad=Ad+1
if nq[UGu]==0 then
if UGu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_update","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_update on invalid object.","when calling error in ")
endif
endif
call H3(UGu,"when calling update in DestroyerSummoner, line 31")
set Ad=Ad-1
endfunction
function I1 takes integer E1,integer Z1,string U1 returns nothing
set Dd[Ad]=U1
set Ad=Ad+1
call PGu(Dr[E1],"when calling update in DestroyerSummoner, line 29")
set Ad=Ad-1
endfunction
function WYu takes integer vYu,integer mYu,string QYu returns nothing
set Dd[Ad]=QYu
set Ad=Ad+1
if pq[vYu]==0 then
if vYu==0 then
call tsw("Nullpointer exception when calling CallbackPeriodic.ClosureTimers_CallbackPeriodic_call","when calling error in ")
else
call tsw("Called CallbackPeriodic.ClosureTimers_CallbackPeriodic_call on invalid object.","when calling error in ")
endif
endif
call I1(vYu,mYu,"when calling FinalBossSummoning_closure_impl in ClosureTimers, line 86")
set Ad=Ad-1
endfunction
function TC takes string fC returns nothing
local integer RC
set Dd[Ad]=fC
set Ad=Ad+1
set RC=c2w(GetExpiredTimer(),"when calling getData in ClosureTimers, line 94")
call WYu(RC,RC,"when calling call in ClosureTimers, line 95")
set Ad=Ad-1
endfunction
function N1u takes nothing returns nothing
set Ad=0
call TC("ClosureTimers, line 91")
endfunction
function e3u takes integer l3u,integer b3u,unit y3u,string p3u returns nothing
set Dd[Ad]=p3u
set Ad=Ad+1
if b3u<0 or b3u>=6 then
call tsw("Index out of Bounds","when calling error in ")
elseif b3u<=2 then
if b3u<=1 then
if b3u<=0 then
set Wd[l3u]=y3u
else
set Ed[l3u]=y3u
endif
else
set Zd[l3u]=y3u
endif
elseif b3u<=4 then
if b3u<=3 then
set Ud[l3u]=y3u
else
set Id[l3u]=y3u
endif
else
set Pd[l3u]=y3u
endif
set Ad=Ad-1
endfunction
function e2 takes integer b2,unit y2,string p2 returns nothing
set Dd[Ad]=p2
set Ad=Ad+1
if ps[b2]<ls then
set ps[b2]=ps[b2]+1
set ys[b2]=ModuloInteger(ys[b2]+1,ls)
call e3u(b2,ys[b2],y2,"when calling units in DummyRecycler, line 58")
else
call tsw("Queue Overflow","when calling error in DummyRecycler, line 60")
endif
set Ad=Ad-1
endfunction
function Dgu takes integer Igu,unit Pgu,string Agu returns nothing
set Dd[Ad]=Agu
set Ad=Ad+1
if mq[Igu]==0 then
if Igu==0 then
call tsw("Nullpointer exception when calling ArrayQueue.DummyRecycler_ArrayQueue_enqueue","when calling error in ")
else
call tsw("Called ArrayQueue.DummyRecycler_ArrayQueue_enqueue on invalid object.","when calling error in ")
endif
endif
call e2(Igu,Pgu,"when calling enqueue in DummyRecycler, line 54")
set Ad=Ad-1
endfunction
function Vgu takes string Xgu returns integer
local integer Cgu
set Dd[Ad]=Xgu
set Ad=Ad+1
if xq==0 then
if vq<32768 then
set vq=vq+1
set Cgu=vq
set mq[Cgu]=628
else
call tsw("Out of memory: Could not create ArrayQueue.","when calling error in ")
set Cgu=0
endif
else
set xq=xq-1
set Cgu=jq[xq]
set mq[Cgu]=628
endif
set Ad=Ad-1
return Cgu
endfunction
function f2 takes integer d2 returns nothing
set bs[d2]=0
set ys[d2]=0
set ps[d2]=0
endfunction
function n2 takes string q2 returns integer
local integer a2
set Dd[Ad]=q2
set Ad=Ad+1
set a2=Vgu("when calling ArrayQueue in DummyRecycler, line 48")
call f2(a2)
set Ad=Ad-1
return a2
endfunction
function V4 takes string J4 returns boolean
local integer K4
local integer L4
local integer X4
local integer C4
set Dd[Ad]=J4
set Ad=Ad+1
set cs=2019849581
set os=8
set Os=360*1./os
set ls=6
set es=CreateTimer()
set ds=0
set fs=0
set K4=0
set L4=os-1
loop
exitwhen K4>L4
set Rs[K4]=n2("when calling new_ArrayQueue in DummyRecycler, line 139")
set X4=0
set C4=ls-1
loop
exitwhen X4>C4
call Dgu(Rs[K4],S2(vo,mo,cw,vh(K4*Os)),"when calling enqueue in DummyRecycler, line 141")
set X4=X4+1
endloop
set K4=K4+1
endloop
set Ad=Ad-1
return true
endfunction
function O1u takes nothing returns boolean
set Ad=0
return V4("DummyRecycler, line 1")
endfunction
function Tsw takes boolean Rsw returns nothing
set ii[ci-1]=Rsw
endfunction
function fsw takes nothing returns integer
return Si[ci-1]
endfunction
function ox takes integer cx returns nothing
set yw=yw-1
endfunction
function qnu takes integer pnu,string enu returns nothing
set Dd[Ad]=enu
set Ad=Ad+1
if he[pnu]==0 then
call tsw("Double free: object of type BigNum_l","when calling error in ")
else
set Ye[Ge]=pnu
set Ge=Ge+1
set he[pnu]=0
endif
set Ad=Ad-1
endfunction
function Xj takes integer Kj,string Lj returns nothing
set Dd[Ad]=Lj
set Ad=Ad+1
call ox(Kj)
call qnu(Kj,"when calling BigNum_l in BigNum, line 36")
set Ad=Ad-1
endfunction
function Mau takes integer Bau,string Nau returns nothing
set Dd[Ad]=Nau
set Ad=Ad+1
if he[Bau]==0 then
if Bau==0 then
call tsw("Nullpointer exception when calling BigNum_l.destroyBigNum_l","when calling error in ")
else
call tsw("Called BigNum_l.destroyBigNum_l on invalid object.","when calling error in ")
endif
endif
call Xj(Bau,"when calling destroyBigNum_l in BigNum, line 28")
set Ad=Ad-1
endfunction
function Jj takes integer Dj,string Hj returns boolean
set Dd[Ad]=Hj
set Ad=Ad+1
if bw[Dj]==0 and lw[Dj]==0 then
set Ad=Ad-1
return true
elseif bw[Dj]!=0 and Jj(bw[Dj],"when calling clean in BigNum, line 43") then
call Mau(bw[Dj],"when calling BigNum_l in BigNum, line 44")
set bw[Dj]=0
set Ad=Ad-1
return lw[Dj]==0
else
set Ad=Ad-1
return false
endif
endfunction
function snu takes integer wnu,string unu returns boolean
local boolean rnu
set Dd[Ad]=unu
set Ad=Ad+1
if he[wnu]==0 then
if wnu==0 then
call tsw("Nullpointer exception when calling BigNum_l.BigNum_BigNum_l_clean","when calling error in ")
else
call tsw("Called BigNum_l.BigNum_BigNum_l_clean on invalid object.","when calling error in ")
endif
endif
set rnu=Jj(wnu,"when calling clean in BigNum, line 40")
set Ad=Ad-1
return rnu
endfunction
function tj takes integer rj,string sj returns nothing
set Dd[Ad]=sj
set Ad=Ad+1
call snu(ow[rj],"when calling clean in BigNum, line 88")
set Ad=Ad-1
endfunction
function jau takes integer Fau,string kau returns nothing
set Dd[Ad]=kau
set Ad=Ad+1
if Te[Fau]==0 then
if Fau==0 then
call tsw("Nullpointer exception when calling BigNum.BigNum_BigNum_clean","when calling error in ")
else
call tsw("Called BigNum.BigNum_BigNum_clean on invalid object.","when calling error in ")
endif
endif
call tj(Fau,"when calling clean in BigNum, line 87")
set Ad=Ad-1
endfunction
function V5 takes integer X5,string C5 returns nothing
set Dd[Ad]=C5
set Ad=Ad+1
call jau(Ms[X5],"when calling clean in Encoder, line 41")
set Ad=Ad-1
endfunction
function hhu takes integer Ghu,string ghu returns nothing
set Dd[Ad]=ghu
set Ad=Ad+1
if Aq[Ghu]==0 then
if Ghu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_clean","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_clean on invalid object.","when calling error in ")
endif
endif
call V5(Ghu,"when calling clean in Encoder, line 40")
set Ad=Ad-1
endfunction
function C6 takes integer L6,string X6 returns nothing
set Dd[Ad]=X6
set Ad=Ad+1
call hhu(ms[L6],"when calling clean in Encoder, line 106")
set Ad=Ad-1
endfunction
function Z6 takes integer m6 returns integer
local integer Q6
local integer W6
local integer E6
call DEw("hash")
set Q6=0
set E6=ow[Ms[m6]]
loop
exitwhen not(E6!=0)
set W6=lw[E6]
set Q6=ModuloInteger(Q6+79*Q6/(W6+1)+293*W6/(1+Q6-Q6/Bs[m6]*Bs[m6])+479,Ts)
set E6=bw[E6]
endloop
call DEw("hashed")
return Q6
endfunction
function Ihu takes integer Ehu,string Zhu returns integer
local integer Uhu
set Dd[Ad]=Zhu
set Ad=Ad+1
if Aq[Ehu]==0 then
if Ehu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_hash","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_hash on invalid object.","when calling error in ")
endif
endif
set Uhu=Z6(Ehu)
set Ad=Ad-1
return Uhu
endfunction
function F7 takes integer g7,string h7 returns nothing
set Dd[Ad]=h7
set Ad=Ad+1
set rt[Ls[g7]]=Ihu(Ls[g7],"when calling hash in Encoder, line 136")
set Ad=Ad-1
endfunction
function G7 takes integer T7,string Y7 returns nothing
set Dd[Ad]=Y7
set Ad=Ad+1
call hhu(Ks[T7],"when calling clean in Encoder, line 133")
set Ad=Ad-1
endfunction
function Gpw takes integer fpw,string Rpw returns nothing
local integer Tpw
local integer Ypw
set Dd[Ad]=Rpw
set Ad=Ad+1
set iS=iS+cS[fpw]
set Tpw=1
set Ypw=cS[fpw]
loop
exitwhen Tpw>Ypw
call Fpw(CreateGroup(),"when calling push in GroupUtils, line 93")
set Tpw=Tpw+1
endloop
set Ad=Ad-1
endfunction
function Svu takes string tvu returns integer
local integer ivu
set Dd[Ad]=tvu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set ivu=Cq
set Vq[ivu]=751
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set ivu=0
endif
else
set Xq=Xq-1
set ivu=Lq[Xq]
set Vq[ivu]=751
endif
set Ad=Ad-1
return ivu
endfunction
function Dsw takes integer Zsw,integer Usw,integer Isw,string Psw returns nothing
local integer Asw
set Dd[Ad]=Psw
set Ad=Ad+1
set Asw=Svu("when calling alloc_Closure in Execute, line 112")
set oi[Asw]=Usw
set Oi[Asw]=Zsw
set li[Asw]=Isw
call xsw(Asw,"when calling execute in Execute, line 112")
set Ad=Ad-1
endfunction
function fvu takes integer dvu returns boolean
return false
endfunction
function nvu takes integer avu returns nothing
endfunction
function Lsw takes integer Hsw,string Jsw returns nothing
local integer Ksw
set Dd[Ad]=Jsw
set Ad=Ad+1
set Ksw=0
loop
exitwhen not(fvu(oi[Hsw]) and Ksw<Oi[Hsw])
call nvu(li[Hsw])
set Ksw=Ksw+1
endloop
if fvu(oi[Hsw]) then
call Dsw(Oi[Hsw],oi[Hsw],li[Hsw],"when calling executeWhileInternal in Execute, line 120")
endif
set Ad=Ad-1
endfunction
function N6 takes integer V6,string B6 returns nothing
set Dd[Ad]=B6
set Ad=Ad+1
set wt[Qs[V6]]=Ihu(Qs[V6],"when calling hash in Encoder, line 110")
set Ad=Ad-1
endfunction
function R7 takes integer d7,string f7 returns nothing
set Dd[Ad]=f7
set Ad=Ad+1
set ut[Js[d7]]=dhu(Js[d7],Ts,"when calling decode in Encoder, line 130")
set Ad=Ad-1
endfunction
function b7 takes integer O7,string l7 returns nothing
set Dd[Ad]=l7
set Ad=Ad+1
call hhu(Es[O7],"when calling clean in Encoder, line 116")
set Ad=Ad-1
endfunction
function L5 takes integer K5 returns real
return Ns[K5]
endfunction
function Yhu takes integer fhu,string Rhu returns real
local real Thu
set Dd[Ad]=Rhu
set Ad=Ad+1
if Aq[fhu]==0 then
if fhu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_length","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_length on invalid object.","when calling error in ")
endif
endif
set Thu=L5(fhu)
set Ad=Ad-1
return Thu
endfunction
function Sx takes integer ix returns nothing
set lw[ix]=0
set bw[ix]=0
set yw=yw+1
endfunction
function ynu takes string lnu returns integer
local integer bnu
set Dd[Ad]=lnu
set Ad=Ad+1
if Ge==0 then
if ge<32768 then
set ge=ge+1
set bnu=ge
set he[bnu]=633
else
call tsw("Out of memory: Could not create BigNum_l.","when calling error in ")
set bnu=0
endif
else
set Ge=Ge-1
set bnu=Ye[Ge]
set he[bnu]=633
endif
set Ad=Ad-1
return bnu
endfunction
function tx takes string rx returns integer
local integer sx
set Dd[Ad]=rx
set Ad=Ad+1
set sx=ynu("when calling BigNum_l in BigNum, line 33")
call Sx(sx)
set Ad=Ad-1
return sx
endfunction
function r6 takes integer B5,string N5 returns nothing
local integer M5
local integer w6
local integer u6
set Dd[Ad]=N5
set Ad=Ad+1
set M5=ow[Ms[B5]]
set w6=0
set u6=R2I(1.0+Yhu(B5,"when calling length in Encoder, line 46"))
loop
exitwhen not(M5!=0)
set w6=M5
set M5=bw[M5]
set u6=u6-1
endloop
loop
exitwhen not(u6>0)
set bw[w6]=tx("when calling new_BigNum_l in Encoder, line 54")
set w6=bw[w6]
set u6=u6-1
endloop
set Ad=Ad-1
endfunction
function jhu takes integer Fhu,string khu returns nothing
set Dd[Ad]=khu
set Ad=Ad+1
if Aq[Fhu]==0 then
if Fhu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_pad","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_pad on invalid object.","when calling error in ")
endif
endif
call r6(Fhu,"when calling pad in Encoder, line 43")
set Ad=Ad-1
endfunction
function e7 takes integer y7,string p7 returns nothing
set Dd[Ad]=p7
set Ad=Ad+1
call jhu(Zs[y7],"when calling pad in Encoder, line 118")
set Ad=Ad-1
endfunction
function lFu takes string oFu returns integer
local integer OFu
set Dd[Ad]=oFu
set Ad=Ad+1
if Hq==0 then
if Jq<32768 then
set Jq=Jq+1
set OFu=Jq
set Kq[OFu]=815
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set OFu=0
endif
else
set Hq=Hq-1
set OFu=Dq[Hq]
set Kq[OFu]=815
endif
set Ad=Ad-1
return OFu
endfunction
function O6 takes integer s6,integer t6,integer i6,string S6 returns nothing
local integer c6
local integer o6
set Dd[Ad]=S6
set Ad=Ad+1
call DEw("toString digits: "+pUw(Ns[s6]))
set c6=ow[Ms[s6]]
set o6=lFu("when calling alloc_Closure in Encoder, line 62")
call FHw(o6)
set Ys[o6]=c6
set Gs[o6]=t6
set gs[o6]=s6
set hs[o6]=i6
call MDw(o6,"when calling doSeq in Encoder, line 62")
set Ad=Ad-1
endfunction
function Whu takes integer xhu,integer vhu,integer mhu,string Qhu returns nothing
set Dd[Ad]=Qhu
set Ad=Ad+1
if Aq[xhu]==0 then
if xhu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_toString","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_toString on invalid object.","when calling error in ")
endif
endif
call O6(xhu,vhu,mhu,"when calling toString in Encoder, line 59")
set Ad=Ad-1
endfunction
function n7 takes integer q7,string a7 returns nothing
set Dd[Ad]=a7
set Ad=Ad+1
call Whu(Us[q7],Is[q7],Ps[q7],"when calling toString in Encoder, line 120")
set Ad=Ad-1
endfunction
function Nk takes real Jk,real Kk returns real
local real Lk=Jk
local real Xk=Kk
local real Ck=1.0
local real Vk=0.0
local real Bk=1.0
if Lk<0. then
return 0.0
endif
if Lk<1. then
set Lk=1.0/Lk
set Bk=-1.0
endif
loop
exitwhen not(Lk>=1.0001)
if Lk>Xk then
set Lk=Lk/Xk
set Vk=Vk+Ck
else
set Xk=SquareRoot(Xk)
set Ck=Ck/2.
endif
endloop
return Bk*Vk
endfunction
function bj takes integer ij,integer Sj,string cj returns nothing
local integer oj
local integer Oj
local integer lj
set Dd[Ad]=cj
set Ad=Ad+1
set oj=ow[ij]
set lj=Sj
if oj==0 then
set oj=tx("when calling new_BigNum_l in BigNum, line 99")
set ow[ij]=oj
endif
loop
exitwhen not(lj!=0)
set Oj=lw[oj]+lj
set lj=Oj/Ow[ij]
set Oj=Oj-lj*Ow[ij]
set lw[oj]=Oj
if bw[oj]==0 then
set bw[oj]=tx("when calling new_BigNum_l in BigNum, line 110")
endif
set oj=bw[oj]
endloop
set Ad=Ad-1
endfunction
function Qau takes integer xau,integer vau,string mau returns nothing
set Dd[Ad]=mau
set Ad=Ad+1
if Te[xau]==0 then
if xau==0 then
call tsw("Nullpointer exception when calling BigNum.BigNum_BigNum_addSmall","when calling error in ")
else
call tsw("Called BigNum.BigNum_BigNum_addSmall on invalid object.","when calling error in ")
endif
endif
call bj(xau,vau,"when calling addSmall in BigNum, line 93")
set Ad=Ad-1
endfunction
function fj takes integer yj,integer pj,string ej returns nothing
local integer qj
local integer aj
local integer nj
local integer dj
set Dd[Ad]=ej
set Ad=Ad+1
set qj=ow[yj]
set dj=0
loop
exitwhen not(qj!=0 or dj!=0)
set aj=pj*lw[qj]+dj
set dj=aj/Ow[yj]
set nj=aj-dj*Ow[yj]
set lw[qj]=nj
if bw[qj]==0 and dj!=0 then
set bw[qj]=tx("when calling new_BigNum_l in BigNum, line 127")
endif
set qj=bw[qj]
endloop
set Ad=Ad-1
endfunction
function Uau takes integer Wau,integer Eau,string Zau returns nothing
set Dd[Ad]=Zau
set Ad=Ad+1
if Te[Wau]==0 then
if Wau==0 then
call tsw("Nullpointer exception when calling BigNum.BigNum_BigNum_mulSmall","when calling error in ")
else
call tsw("Called BigNum.BigNum_BigNum_mulSmall on invalid object.","when calling error in ")
endif
endif
call fj(Wau,Eau,"when calling mulSmall in BigNum, line 116")
set Ad=Ad-1
endfunction
function I5 takes integer W5,integer E5,integer Z5,string U5 returns nothing
set Dd[Ad]=U5
set Ad=Ad+1
set Ns[W5]=Ns[W5]+Nk(Z5+1.,Bs[W5]+0.)
call Uau(Ms[W5],Z5+1,"when calling mulSmall in Encoder, line 27")
call Qau(Ms[W5],E5,"when calling addSmall in Encoder, line 28")
call PEw("encoded val: "+bfw(E5)+" max: "+bfw(Z5))
set Ad=Ad-1
endfunction
function phu takes integer Ohu,integer lhu,integer bhu,string yhu returns nothing
set Dd[Ad]=yhu
set Ad=Ad+1
if Aq[Ohu]==0 then
if Ohu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_encode","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_encode on invalid object.","when calling error in ")
endif
endif
call I5(Ohu,lhu,bhu,"when calling encode in Encoder, line 25")
set Ad=Ad-1
endfunction
function o7 takes integer S7,string c7 returns nothing
set Dd[Ad]=c7
set Ad=Ad+1
call phu(Ws[S7],wt[Ws[S7]],Ts,"when calling encode in Encoder, line 114")
set Ad=Ad-1
endfunction
function yvu takes integer lvu,string bvu returns nothing
set Dd[Ad]=bvu
set Ad=Ad+1
if Vq[lvu]==0 then
if lvu==0 then
call tsw("Nullpointer exception when calling ForForceCallback.Execute_ForForceCallback_run","when calling error in ")
else
call tsw("Called ForForceCallback.Execute_ForForceCallback_run on invalid object.","when calling error in ")
endif
endif
if Vq[lvu]<=747 then
if Vq[lvu]<=744 then
if Vq[lvu]<=743 then
if Vq[lvu]<=742 then
call C6(lvu,"when calling Encoder_closure_impl in Execute, line 11")
else
call N6(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
else
call o7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
elseif Vq[lvu]<=746 then
if Vq[lvu]<=745 then
call b7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
else
call e7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
else
call n7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
elseif Vq[lvu]<=750 then
if Vq[lvu]<=749 then
if Vq[lvu]<=748 then
call R7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
else
call G7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
else
call F7(lvu,"when calling Encoder_closure_impl in Execute, line 11")
endif
elseif Vq[lvu]<=751 then
call Lsw(lvu,"when calling Execute_closure_impl in Execute, line 11")
else
call Gpw(lvu,"when calling GroupUtils_closure_impl in Execute, line 11")
endif
set Ad=Ad-1
endfunction
function dsw takes string nsw returns nothing
set Dd[Ad]=nsw
set Ad=Ad+1
set ri=""
call yvu(fsw(),"when calling run in Execute, line 20")
call Tsw(true)
set Ad=Ad-1
endfunction
function O4u takes nothing returns nothing
set Ad=0
call dsw("Execute, line 100")
endfunction
function O_u takes nothing returns boolean
set My="UI\\Feedback\\GoldCredit\\GoldCredit.mdx"
return true
endfunction
function Ox takes nothing returns boolean
set pw=450
set ew=25
return true
endfunction
function vAw takes string xAw returns boolean
set Dd[Ad]=xAw
set Ad=Ad+1
set LO=1747989042
set XO=1747988550
set CO=1747989049
set VO=1093677401
set BO=1093677400
set NO=1093677388
set MO=1227894850
set wl=1227894851
set ul=1227894852
set rl=VJw("Units\\Creeps\\Ogre\\OgrePissed5.wav",false,"when calling new_SoundDefinition in Selector, line 23")
set Ad=Ad-1
return true
endfunction
function P1u takes nothing returns boolean
set Ad=0
return vAw("Selector, line 1")
endfunction
function P8w takes nothing returns boolean
set Ay=15.
set Dy=1747988805
set Hy=1747988806
set Jy=1747989060
return true
endfunction
function AM takes nothing returns nothing
call Q2w(CreateTimer(),1.,PG)
endfunction
function rjw takes multiboard ujw returns boolean
return IsMultiboardDisplayed(ujw)
endfunction
function PM takes nothing returns nothing
if Rr then
set Rr=false
call AM()
endif
if GetLocalPlayer()==GetTriggerPlayer() then
call ijw(yr,not rjw(yr))
endif
endfunction
function Pk takes nothing returns boolean
return true
endfunction
function FZu takes string gZu returns integer
local integer hZu
set Dd[Ad]=gZu
set Ad=Ad+1
if Ha==0 then
if Ja<32768 then
set Ja=Ja+1
set hZu=Ja
set Ka[hZu]=696
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set hZu=0
endif
else
set Ha=Ha-1
set hZu=Da[Ha]
set Ka[hZu]=696
endif
set Ad=Ad-1
return hZu
endfunction
function daw takes string eaw returns boolean
local integer qaw
local real aaw
local real naw
set Dd[Ad]=eaw
set Ad=Ad+1
set qS=1747989057
set aS[0]=1.75
set aS[1]=1.5
set aS[2]=2.0
set aS[3]=1.95
set nS[0]=1
set nS[1]=2
set nS[2]=2
set nS[3]=3
set dS[0]=865.
set dS[1]=885.
set dS[2]=915.
set dS[3]=950.
set WS=Ngw("when calling new_LinkedList in HealbackTower, line 31")
set aaw=pp
set naw=ep
set ES=aaw
set ZS=naw
set qaw=FZu("when calling alloc_Closure in HealbackTower, line 33")
set US=qaw
set fS=32.
set RS=K
set TS=j
set Ad=Ad-1
return true
endfunction
function Q1u takes nothing returns boolean
set Ad=0
return daw("HealbackTower, line 1")
endfunction
function Squ takes integer iqu returns nothing
endfunction
function ZMu takes integer WMu,string EMu returns nothing
set Dd[Ad]=EMu
set Ad=Ad+1
if sd[WMu]==0 then
call tsw("Double free: object of type NormalWave","when calling error in ")
else
set wd[ud]=WMu
set ud=ud+1
set sd[WMu]=0
endif
set Ad=Ad-1
endfunction
function xeu takes integer keu,string jeu returns nothing
set Dd[Ad]=jeu
set Ad=Ad+1
call Squ(keu)
call ZMu(keu,"when calling NormalWave in Wave, line 15")
set Ad=Ad-1
endfunction
function FMu takes integer gMu,string hMu returns nothing
set Dd[Ad]=hMu
set Ad=Ad+1
if sd[gMu]==0 then
if gMu==0 then
call tsw("Nullpointer exception when calling NormalWave.destroyNormalWave","when calling error in ")
else
call tsw("Called NormalWave.destroyNormalWave on invalid object.","when calling error in ")
endif
endif
call xeu(gMu,"when calling destroyNormalWave in Wave, line 15")
set Ad=Ad-1
endfunction
function Ofw takes integer ofw returns real
return ofw*1.
endfunction
function PMu takes string UMu returns integer
local integer IMu
set Dd[Ad]=UMu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set IMu=ae
set ne[IMu]=692
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set IMu=0
endif
else
set qe=qe-1
set IMu=ee[qe]
set ne[IMu]=692
endif
set Ad=Ad-1
return IMu
endfunction
function Feu takes string neu returns nothing
local timer deu
local integer feu
local integer Reu
local integer Teu
local integer Yeu
local integer Geu
local integer geu
local real heu
set Dd[Ad]=neu
set Ad=Ad+1
set deu=GetExpiredTimer()
set feu=c2w(deu,"when calling getData in Wave, line 39")
set Reu=0
set Teu=Mp[feu]
if Teu==0 then
set Reu=Xp[feu]
set Mp[feu]=1
call j2w(deu,0.8,jg)
elseif Teu==1 then
set Reu=Cp[feu]
set Mp[feu]=2
call j2w(deu,0.8,xg)
elseif Teu==2 then
set Reu=Vp[feu]
call FMu(feu,"when calling NormalWave in Wave, line 52")
call e2w(deu,"when calling release in Wave, line 53")
endif
set Yeu=0
set Geu=Bp[feu]-1
loop
exitwhen Yeu>Geu
set heu=Ofw(Yeu)
set geu=PMu("when calling alloc_Closure in Wave, line 56")
call VC(geu)
set Kp[geu]=Reu
set Lp[geu]=feu
call gX(heu,geu,"when calling doAfter in Wave, line 56")
set Yeu=Yeu+1
endloop
set Ad=Ad-1
set deu=null
endfunction
function Q4u takes nothing returns nothing
set Ad=0
call Feu("Wave, line 45")
endfunction
function Q5 takes nothing returns boolean
set Ts=1000
return true
endfunction
function b8w takes trigger l8w returns boolean
return TriggerEvaluate(l8w)
endfunction
function exw takes nothing returns nothing
set Jo=Jo-1
endfunction
function pxw takes unit yxw returns nothing
set Ho[Jo]=yxw
set Jo=Jo+1
endfunction
function tiu takes unit uiu,integer riu,boolean siu returns boolean
return UnitMakeAbilityPermanent(uiu,siu,riu)
endfunction
function Gxw takes unit Rxw returns nothing
local unit Txw=Rxw
local unit Yxw
call Osu(Txw,Ko)
set Yxw=Txw
call tiu(Yxw,Ko,true)
call pxw(Rxw)
call b8w(Ao)
call exw()
set Txw=null
set Yxw=null
endfunction
function Qxw takes nothing returns nothing
call Gxw(GetEnumUnit())
endfunction
function om takes string cm returns boolean
set Dd[Ad]=cm
set Ad=Ad+1
set Jw=VJw(cb,false,"when calling new_SoundDefinition in Boss, line 7")
set Ad=Ad-1
return true
endfunction
function R1u takes nothing returns boolean
set Ad=0
return om("Boss, line 1")
endfunction
function TKu takes integer fKu,string RKu returns nothing
set Dd[Ad]=RKu
set Ad=Ad+1
if Fn[fKu]==0 then
call tsw("Double free: object of type DynamicSound","when calling error in ")
else
set hn=hn+1
set Fn[fKu]=0
endif
set Ad=Ad-1
endfunction
function DLw takes sound ALw returns boolean
return GetSoundIsPlaying(ALw)
endfunction
function TJw takes integer dJw,real fJw,string RJw returns nothing
set Dd[Ad]=RJw
set Ad=Ad+1
if Ul[dJw]==0 then
call tsw("Must play sound before setting pitch","when calling error in SoundUtils, line 178")
endif
if not DLw(rb[Ul[dJw]]) then
if fJw==1. then
call ZLw(rb[Ul[dJw]],1.0001)
else
call ZLw(rb[Ul[dJw]],fJw)
endif
else
call ZLw(rb[Ul[dJw]],1./Wl[dJw])
call ZLw(rb[Ul[dJw]],fJw)
endif
set Wl[dJw]=fJw
set Ad=Ad-1
endfunction
function OKu takes integer SKu,real cKu,string oKu returns nothing
set Dd[Ad]=oKu
set Ad=Ad+1
if Fn[SKu]==0 then
if SKu==0 then
call tsw("Nullpointer exception when calling DynamicSound.SoundUtils_DynamicSound_setAbsolutePitch","when calling error in ")
else
call tsw("Called DynamicSound.SoundUtils_DynamicSound_setAbsolutePitch on invalid object.","when calling error in ")
endif
endif
call TJw(SKu,cKu,"when calling setAbsolutePitch in SoundUtils, line 176")
set Ad=Ad-1
endfunction
function PJw takes integer IJw returns nothing
set Dl[IJw]=2
endfunction
function qKu takes integer pKu,string eKu returns nothing
set Dd[Ad]=eKu
set Ad=Ad+1
if Fn[pKu]==0 then
if pKu==0 then
call tsw("Nullpointer exception when calling DynamicSound.SoundUtils_DynamicSound_TimedLoop_stopTimedLoop","when calling error in ")
else
call tsw("Called DynamicSound.SoundUtils_DynamicSound_TimedLoop_stopTimedLoop on invalid object.","when calling error in ")
endif
endif
call PJw(pKu)
set Ad=Ad-1
endfunction
function xLw takes sound FLw,boolean kLw,boolean jLw returns nothing
call StopSound(FLw,kLw,jLw)
endfunction
function vJw takes integer jJw,string xJw returns nothing
set Dd[Ad]=xJw
set Ad=Ad+1
call OKu(jJw,1.,"when calling setAbsolutePitch in SoundUtils, line 197")
call xLw(rb[Ul[jJw]],false,false)
call OKu(jJw,1.,"when calling setAbsolutePitch in SoundUtils, line 199")
if Dl[jJw]!=1 then
call qKu(jJw,"when calling stopTimedLoop in TimerUtils, line 113")
call UEw("Destroyed Instance using TimedLoop before stopping the Loop")
endif
set Ad=Ad-1
endfunction
function kJw takes integer hJw,string FJw returns nothing
set Dd[Ad]=FJw
set Ad=Ad+1
call vJw(hJw,"when calling DynamicSound_onDestroy in SoundUtils, line 196")
call TKu(hJw,"when calling DynamicSound in SoundUtils, line 196")
set Ad=Ad-1
endfunction
function iKu takes integer sKu,string tKu returns nothing
set Dd[Ad]=tKu
set Ad=Ad+1
if Fn[sKu]==0 then
if sKu==0 then
call tsw("Nullpointer exception when calling DynamicSound.destroyDynamicSound","when calling error in ")
else
call tsw("Called DynamicSound.destroyDynamicSound on invalid object.","when calling error in ")
endif
endif
call kJw(sKu,"when calling destroyDynamicSound in SoundUtils, line 154")
set Ad=Ad-1
endfunction
function QJw takes integer mJw returns nothing
set Dl[mJw]=3
endfunction
function dKu takes integer aKu,string nKu returns nothing
set Dd[Ad]=nKu
set Ad=Ad+1
if Fn[aKu]==0 then
if aKu==0 then
call tsw("Nullpointer exception when calling DynamicSound.SoundUtils_DynamicSound_TimedLoop_stopTimedLoopAndDestroy","when calling error in ")
else
call tsw("Called DynamicSound.SoundUtils_DynamicSound_TimedLoop_stopTimedLoopAndDestroy on invalid object.","when calling error in ")
endif
endif
call QJw(aKu)
set Ad=Ad-1
endfunction
function nUw takes real eUw,real qUw,real aUw returns real
return eUw*(1.0-aUw)+qUw*aUw
endfunction
function gJw takes integer YJw,string GJw returns nothing
set Dd[Ad]=GJw
set Ad=Ad+1
if Ul[YJw]!=0 then
call OKu(YJw,nUw(Wl[YJw],Ql[YJw],El[YJw]),"when calling setAbsolutePitch in SoundUtils, line 191")
set Zl[YJw]=Zl[YJw]-sw
if (not DLw(rb[Ul[YJw]]))and Zl[YJw]<=0. then
call dKu(YJw,"when calling stopTimedLoopAndDestroy in SoundUtils, line 194")
endif
endif
set Ad=Ad-1
endfunction
function yKu takes integer lKu,string bKu returns nothing
set Dd[Ad]=bKu
set Ad=Ad+1
if Fn[lKu]==0 then
if lKu==0 then
call tsw("Nullpointer exception when calling DynamicSound.SoundUtils_DynamicSound_onTimedLoop","when calling error in ")
else
call tsw("Called DynamicSound.SoundUtils_DynamicSound_onTimedLoop on invalid object.","when calling error in ")
endif
endif
call gJw(lKu,"when calling onTimedLoop in SoundUtils, line 189")
set Ad=Ad-1
endfunction
function UJw takes string WJw returns boolean
local integer EJw
local integer ZJw
set Dd[Ad]=WJw
set Ad=Ad+1
set EJw=Pl-1
loop
exitwhen not(EJw>=0)
set ZJw=Il[EJw]
call yKu(ZJw,"when calling onTimedLoop in TimerUtils, line 78")
if Dl[ZJw]!=0 then
set Pl=Pl-1
set Il[EJw]=Il[Pl]
if Dl[ZJw]==3 then
set Dl[ZJw]=1
call iKu(ZJw,"when calling DynamicSound in TimerUtils, line 84")
else
set Dl[ZJw]=1
endif
endif
set EJw=EJw-1
endloop
if Pl==0 then
call TriggerRemoveCondition(dy,Al)
set Al=null
set fy=fy-1
endif
set Ad=Ad-1
return false
endfunction
function R4u takes nothing returns boolean
set Ad=0
return UJw("TimerUtils, line 67")
endfunction
function RX takes nothing returns boolean
set Eu=200
return true
endfunction
function eCu takes string yCu returns integer
local integer pCu
set Dd[Ad]=yCu
set Ad=Ad+1
if Wa==0 then
if Ea<32768 then
set Ea=Ea+1
set pCu=Ea
set Za[pCu]=886
else
call tsw("Out of memory: Could not create Table.","when calling error in ")
set pCu=0
endif
else
set Wa=Wa-1
set pCu=Qa[Wa]
set Za[pCu]=886
endif
set Ad=Ad-1
return pCu
endfunction
function v3w takes string j3w returns integer
local integer x3w
set Dd[Ad]=j3w
set Ad=Ad+1
set x3w=eCu("when calling Table in Table, line 5")
call Q3w(x3w)
set Ad=Ad-1
return x3w
endfunction
function M4w takes string N4w returns boolean
set Dd[Ad]=N4w
set Ad=Ad+1
set qy=0
set ay=v3w("when calling new_Table in TimerUtils, line 12")
set ny=679645218
call CreateTimer()
set dy=CreateTrigger()
set fy=0
set Ad=Ad-1
return true
endfunction
function S1u takes nothing returns boolean
set Ad=0
return M4w("TimerUtils, line 1")
endfunction
function lA takes integer OA returns nothing
set bu[OA]=Su
endfunction
function BRu takes integer CRu,string VRu returns nothing
set Dd[Ad]=VRu
set Ad=Ad+1
if uq[CRu]==0 then
if CRu==0 then
call tsw("Nullpointer exception when calling Iterator.Buff_Buff_LinkedListModule_Iterator_reset","when calling error in ")
else
call tsw("Called Iterator.Buff_Buff_LinkedListModule_Iterator_reset on invalid object.","when calling error in ")
endif
endif
call lA(CRu)
set Ad=Ad-1
endfunction
function qA takes integer pA returns integer
local integer eA=bu[pA]
set bu[pA]=lu[bu[pA]]
return eA
endfunction
function bP takes integer OP,string lP returns nothing
set Dd[Ad]=lP
set Ad=Ad+1
if ru[OP]<=0. then
call DEw("Terminating Buff: duration <= 0.")
call J4u(2,OP,"when calling terminate in Buff, line 96",0,null)
else
set ru[OP]=ru[OP]-Vw
endif
set Ad=Ad-1
endfunction
function FE takes integer gE,string hE returns nothing
set Dd[Ad]=hE
set Ad=Ad+1
call bP(gE,"when calling update in BossThree, line 17")
set Ad=Ad-1
endfunction
function sEw takes integer uEw,string rEw returns nothing
set Dd[Ad]=rEw
set Ad=Ad+1
call bP(uEw,"when calling update in PresetBuffs, line 68")
if fO[uEw]<=0. then
call J4u(2,uEw,"when calling terminate in PresetBuffs, line 70",0,null)
endif
set Ad=Ad-1
endfunction
function IQ takes integer ZQ,string UQ returns nothing
set Dd[Ad]=UQ
set Ad=Ad+1
call sEw(ZQ,"when calling update in BossFour, line 18")
set Ad=Ad-1
endfunction
function qfw takes integer yfw,integer pfw,real efw returns integer
return OUw(yfw*(1.-efw)+pfw*efw)
endfunction
function dB takes integer bB,integer yB,integer pB,integer eB,integer qB,integer aB,real nB returns integer
set Rf=qfw(bB,eB,nB)
set Tf=qfw(yB,qB,nB)
set Yf=qfw(pB,aB,nB)
return Rf
endfunction
function xB takes unit hB,integer FB,integer kB,integer jB returns nothing
call SetUnitVertexColor(hB,FB,kB,jB,255)
endfunction
function xZ takes integer dZ,string fZ returns nothing
local integer RZ
local integer TZ
local integer YZ
local integer GZ
local integer gZ
local integer hZ
local integer FZ
local integer kZ
local unit jZ
set Dd[Ad]=fZ
set Ad=Ad+1
call sEw(dZ,"when calling update in BossTwo, line 18")
set RZ=dZ
set kZ=RZ
set TZ=dZ
set gZ=Zw[TZ]
set hZ=Uw[TZ]
set FZ=Iw[TZ]
set YZ=dZ
set Zw[kZ]=dB(gZ,hZ,FZ,Pw[YZ],Aw[YZ],Dw[YZ],0.35)
set Uw[RZ]=Tf
set Iw[RZ]=Yf
set jZ=Nt[uu[dZ]]
set GZ=dZ
call xB(jZ,Zw[GZ],Uw[GZ],Iw[GZ])
set Ad=Ad-1
set jZ=null
endfunction
function xRu takes integer kRu,string jRu returns nothing
set Dd[Ad]=jRu
set Ad=Ad+1
if Ie[kRu]==0 then
if kRu==0 then
call tsw("Nullpointer exception when calling Buff.Buff_Buff_update","when calling error in ")
else
call tsw("Called Buff.Buff_Buff_update on invalid object.","when calling error in ")
endif
endif
if Ie[kRu]<=643 then
if Ie[kRu]<=641 then
if Ie[kRu]<=640 then
call bP(kRu,"when calling update in Buff, line 93")
else
call FE(kRu,"when calling update in Buff, line 93")
endif
elseif Ie[kRu]<=642 then
call sEw(kRu,"when calling update in Buff, line 93")
else
call IQ(kRu,"when calling update in Buff, line 93")
endif
elseif Ie[kRu]<=645 then
if Ie[kRu]<=644 then
call sEw(kRu,"when calling update in Buff, line 93")
else
call xZ(kRu,"when calling update in Buff, line 93")
endif
else
call bP(kRu,"when calling update in Buff, line 93")
endif
set Ad=Ad-1
endfunction
function yA takes integer bA returns boolean
return bu[bA]!=0
endfunction
function V0w takes string L0w returns nothing
local integer X0w
local integer C0w
set Dd[Ad]=L0w
set Ad=Ad+1
call BRu(Gt,"when calling reset in EntityManagement, line 20")
set C0w=Gt
loop
exitwhen not yA(C0w)
set X0w=qA(C0w)
if not iu[X0w]then
call xRu(X0w,"when calling update in EntityManagement, line 23")
endif
endloop
set Ad=Ad-1
endfunction
function S4u takes nothing returns nothing
set Ad=0
call V0w("EntityManagement, line 27")
endfunction
function Yjw takes multiboard Rjw,real Tjw returns nothing
call MultiboardSetItemsWidth(Rjw,Tjw)
endfunction
function fjw takes multiboard ajw,boolean njw,boolean djw returns nothing
call MultiboardSetItemsStyle(ajw,njw,djw)
endfunction
function Sfw takes nothing returns nothing
local multiboarditem rfw
local integer sfw
local integer tfw
local string ifw
set PS=CreateMultiboard()
call yjw(PS,2)
call qjw(PS,IS+1)
call fjw(PS,true,false)
call Yjw(PS,0.10)
call hjw(PS,"Instance Board")
set rfw=Ojw(PS,0,0)
call Zjw(rfw,"ClassName")
set rfw=Ojw(PS,0,1)
call Zjw(rfw,"Instance count")
set sfw=1
set tfw=IS
loop
exitwhen sfw>tfw
set ifw=DS[sfw]
if ifw!=null then
set rfw=Ojw(PS,sfw,0)
call Zjw(rfw,ifw)
set rfw=Ojw(PS,sfw,1)
call Zjw(rfw,bfw(AS[sfw]))
endif
set sfw=sfw+1
endloop
call ijw(PS,true)
set rfw=null
endfunction
function EUw takes region QUw,rect WUw returns nothing
call RegionAddRect(QUw,WUw)
endfunction
function ecu takes real bcu,real ycu,real pcu returns real
set hf=bcu*pcu
set Ff=ycu*pcu
return hf
endfunction
function initMapBounds takes nothing returns nothing
local rect cond_result
local region receiver
local rect cond_result_2
local region receiver_2
local real temp_MapBounds_playableMin_x
local real temp_MapBounds_playableMin_y
local real temp_MapBounds_playableMax_x
local real temp_MapBounds_playableMax_y
local real temp_MapBounds_boundMin_x
local real temp_MapBounds_boundMin_y
local real temp_MapBounds_boundMax_x
local real temp_MapBounds_boundMax_y
if Ro then
set cond_result=Rect(-1024.,-1024.,1024.,1024.)
else
set cond_result=GetPlayableMapRect()
endif
set To=cond_result
set receiver=CreateRegion()
call EUw(receiver,To)
if Ro then
set cond_result_2=Rect(-1536.,-1536.,1536.,1536.)
else
set cond_result_2=GetWorldBounds()
endif
set Yo=cond_result_2
set receiver_2=CreateRegion()
call EUw(receiver_2,Yo)
set Go=receiver_2
set temp_MapBounds_playableMin_x=TUw(To)
set temp_MapBounds_playableMin_y=hUw(To)
set go=temp_MapBounds_playableMin_x
set ho=temp_MapBounds_playableMin_y
set temp_MapBounds_playableMax_x=GUw(To)
set temp_MapBounds_playableMax_y=kUw(To)
set Fo=temp_MapBounds_playableMax_x
set ko=temp_MapBounds_playableMax_y
set temp_MapBounds_boundMin_x=TUw(Yo)
set temp_MapBounds_boundMin_y=hUw(Yo)
set jo=temp_MapBounds_boundMin_x
set xo=temp_MapBounds_boundMin_y
set temp_MapBounds_boundMax_x=GUw(Yo)
set temp_MapBounds_boundMax_y=kUw(Yo)
set vo=temp_MapBounds_boundMax_x
set mo=temp_MapBounds_boundMax_y
call ecu(lcu(go,ho,Fo,ko),Ld,.5)
call ecu(lcu(jo,xo,vo,mo),Ld,.5)
endfunction
function Skw takes nothing returns boolean
call initMapBounds()
return true
endfunction
function Sxw takes nothing returns boolean
set Zo="Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdx"
set Uo="Objects\\Spawnmodels\\Demon\\DemonSmallDeathExplode\\DemonSmallDeathExplode.mdx"
set Io="Objects\\Spawnmodels\\NightElf\\EntBirthTarget\\EntBirthTarget.mdx"
set Po="Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdx"
return true
endfunction
function Flu takes string Glu returns boolean
local integer glu
local integer hlu
set Dd[Ad]=Glu
set Ad=Ad+1
set fp=VJw("Abilities\\Spells\\Other\\Silence\\Silence1.wav",false,"when calling new_SoundDefinition in WarningBuff, line 9")
set glu=1095577651
set hlu=1112354866
set Rp=glu
set Tp=hlu
set Ad=Ad-1
return true
endfunction
function T1u takes nothing returns boolean
set Ad=0
return Flu("WarningBuff, line 1")
endfunction
function T4u takes nothing returns nothing
set Ad=0
call DKw("SoundUtils, line 90")
endfunction
function Tkw takes nothing returns boolean
set Qo=6.28318
return true
endfunction
function gAu takes string YAu returns integer
local integer GAu
set Dd[Ad]=YAu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set GAu=ae
set ne[GAu]=680
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set GAu=0
endif
else
set qe=qe-1
set GAu=ee[qe]
set ne[GAu]=680
endif
set Ad=Ad-1
return GAu
endfunction
function jkw takes string Fkw returns boolean
local integer kkw
set Dd[Ad]=Fkw
set Ad=Ad+1
set kkw=gAu("when calling alloc_Closure in MultiboardSystem, line 6")
call VC(kkw)
call gX(0.25,kkw,"when calling doAfter in MultiboardSystem, line 6")
set Ad=Ad-1
return true
endfunction
function U1u takes nothing returns boolean
set Ad=0
return jkw("MultiboardSystem, line 1")
endfunction
function UE takes nothing returns boolean
local integer EE=1095577653
local integer ZE=1112354868
set Qw=EE
set Ww=ZE
set Ew=1966092375
return true
endfunction
function VL takes nothing returns integer
return mu[Qu-1]
endfunction
function CL takes string XL returns nothing
set Dd[Ad]=XL
set Ad=Ad+1
call iYu(VL(),GetFilterUnit(),"when calling callback in ClosureForGroups, line 12")
set Ad=Ad-1
endfunction
function V1u takes nothing returns nothing
set Ad=0
call CL("ClosureForGroups, line 12")
endfunction
function SRw takes item tRw,boolean iRw returns nothing
call SetItemVisible(tRw,iRw)
endfunction
function oRw takes item cRw returns boolean
return IsItemVisible(cRw)
endfunction
function V3w takes nothing returns nothing
if oRw(GetEnumItem()) then
set ry[sy]=GetEnumItem()
call SRw(ry[sy],false)
set sy=sy+1
endif
endfunction
function VEw takes nothing returns boolean
set TO=4
return true
endfunction
function ufw takes string wfw returns boolean
set Dd[Ad]=wfw
set Ad=Ad+1
set IS=0
call InitHashtable()
set PS=null
call j2w(b2w("when calling getTimer in InstanceBoard, line 11"),0.0,cg)
set Ad=Ad-1
return true
endfunction
function W1u takes nothing returns boolean
set Ad=0
return ufw("InstanceBoard, line 1")
endfunction
function W3w takes nothing returns boolean
return true
endfunction
function W4u takes nothing returns nothing
set Ad=0
call Feu("Wave, line 49")
endfunction
function Wxw takes nothing returns boolean
set Lo=851983
set Xo=852556
return true
endfunction
function cK takes string SK returns nothing
set Dd[Ad]=SK
set Ad=Ad+1
call MK("when calling generalEventCallback in ClosureEvents, line 287")
set Ad=Ad-1
endfunction
function X1u takes nothing returns nothing
set Ad=0
call cK("ClosureEvents, line 287")
endfunction
function IM takes nothing returns nothing
local multiboarditem vM
local multiboarditem mM
local multiboarditem QM
local multiboarditem WM
local multiboarditem EM
local multiboarditem ZM
local multiboarditem UM
set yr=CreateMultiboard()
call yjw(yr,er)
call qjw(yr,pr)
call fjw(yr,true,false)
call Yjw(yr,0.04)
call hjw(yr,"Debug Info")
set vM=Ojw(yr,0,0)
set mM=vM
call Zjw(mM,"Allocations")
set QM=mM
call Pjw(QM,0.10)
set vM=Ojw(yr,1,0)
set WM=vM
call Zjw(WM,"Callbacks")
set EM=WM
call Pjw(EM,0.10)
set vM=Ojw(yr,2,0)
set ZM=vM
call Zjw(ZM,"Entites")
set UM=ZM
call Pjw(UM,0.10)
set vM=null
set mM=null
set QM=null
set WM=null
set EM=null
set ZM=null
set UM=null
endfunction
function XM takes nothing returns nothing
if yr==null then
call IM()
endif
set qr=qr+1
set nr=nr+ar
set fr=fr+dr
call Zjw(Ojw(yr,0,1),bfw(dr))
call Zjw(Ojw(yr,0,2),pUw(fr*1./qr))
call Zjw(Ojw(yr,1,1),bfw(ar))
call Zjw(Ojw(yr,1,2),pUw(nr*1./qr))
call Zjw(Ojw(yr,2,1),bfw(Kt))
call Zjw(Ojw(yr,2,2),bfw(Lt))
set ar=0
set dr=0
endfunction
function XVw takes nothing returns boolean
set Qb=1966092354
set Wb=1966092355
set Eb=1966092356
set Zb=1966092357
return true
endfunction
function Xpw takes nothing returns nothing
call H3u(lS,GetEnumUnit())
endfunction
function GGu takes string TGu returns integer
local integer YGu
set Dd[Ad]=TGu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set YGu=Le
set Xe[YGu]=724
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set YGu=0
endif
else
set Ke=Ke-1
set YGu=Je[Ke]
set Xe[YGu]=724
endif
set Ad=Ad-1
return YGu
endfunction
function xM takes string GM returns boolean
local integer gM
local trigger hM
local trigger FM
local integer kM
local playerevent jM
set Dd[Ad]=GM
set Ad=Ad+1
set pr=3
set er=3
set qr=0
set ar=0
set nr=0
set dr=0
set fr=0
set Rr=true
set gM=0
loop
exitwhen gM>11
set hM=CreateTrigger()
call g8w(hM,OO[gM],"-debug",true)
set FM=hM
call r8w(FM,IG)
set gM=gM+1
endloop
set jM=pu
set kM=GGu("when calling alloc_Closure in DebugInfo, line 42")
call cL(kM)
call pK(jM,kM,"when calling add in DebugInfo, line 42")
set Ad=Ad-1
set hM=null
set FM=null
set jM=null
return true
endfunction
function Y1u takes nothing returns boolean
set Ad=0
return xM("DebugInfo, line 1")
endfunction
function pJw takes integer yJw returns nothing
endfunction
function rKu takes integer wKu,string uKu returns nothing
set Dd[Ad]=uKu
set Ad=Ad+1
if gn[wKu]==0 then
call tsw("Double free: object of type Sim3DSound","when calling error in ")
else
set Gn=Gn+1
set gn[wKu]=0
endif
set Ad=Ad-1
endfunction
function aJw takes integer eJw,string qJw returns nothing
set Dd[Ad]=qJw
set Ad=Ad+1
call pJw(eJw)
call rKu(eJw,"when calling Sim3DSound in Simulate3dSound, line 87")
set Ad=Ad-1
endfunction
function MJu takes integer BJu,string NJu returns nothing
set Dd[Ad]=NJu
set Ad=Ad+1
if gn[BJu]==0 then
if BJu==0 then
call tsw("Nullpointer exception when calling Sim3DSound.destroySim3DSound","when calling error in ")
else
call tsw("Called Sim3DSound.destroySim3DSound on invalid object.","when calling error in ")
endif
endif
call aJw(BJu,"when calling destroySim3DSound in Simulate3dSound, line 87")
set Ad=Ad-1
endfunction
function hgw takes integer Ygw,integer Ggw,string ggw returns nothing
set Dd[Ad]=ggw
set Ad=Ad+1
call j3u(Ygw,Ggw,"when calling add in LinkedList, line 66")
set Ad=Ad-1
endfunction
function PIu takes integer ZIu,integer UIu,string IIu returns nothing
set Dd[Ad]=IIu
set Ad=Ad+1
if yn[ZIu]==0 then
if ZIu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_push","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_push on invalid object.","when calling error in ")
endif
endif
call hgw(ZIu,UIu,"when calling push in LinkedList, line 65")
set Ad=Ad-1
endfunction
function SLu takes integer tLu,string iLu returns nothing
set Dd[Ad]=iLu
set Ad=Ad+1
if En[tLu]==0 then
call tsw("Double free: object of type SoundInstance","when calling error in ")
else
set mn[Qn]=tLu
set Qn=Qn+1
set En[tLu]=0
endif
set Ad=Ad-1
endfunction
function fLw takes integer dLw returns nothing
endfunction
function YLw takes integer RLw,string TLw returns nothing
set Dd[Ad]=TLw
set Ad=Ad+1
call fLw(RLw)
call SLu(RLw,"when calling SoundInstance in SoundUtils, line 25")
set Ad=Ad-1
endfunction
function wLu takes integer NKu,string MKu returns nothing
set Dd[Ad]=MKu
set Ad=Ad+1
if En[NKu]==0 then
if NKu==0 then
call tsw("Nullpointer exception when calling SoundInstance.destroySoundInstance","when calling error in ")
else
call tsw("Called SoundInstance.destroySoundInstance on invalid object.","when calling error in ")
endif
endif
call YLw(NKu,"when calling destroySoundInstance in SoundUtils, line 25")
set Ad=Ad-1
endfunction
function SLw takes string sLw returns nothing
local timer tLw
local integer iLw
set Dd[Ad]=sLw
set Ad=Ad+1
set tLw=GetExpiredTimer()
set iLw=c2w(tLw,"when calling getData in SoundUtils, line 142")
set ib[iLw]=null
if Sb[iLw]!=0 then
call MJu(Sb[iLw],"when calling Sim3DSound in SoundUtils, line 145")
endif
if sPu(Hl[sb[iLw]],"when calling size in SoundUtils, line 146")<4 then
call PIu(Hl[sb[iLw]],iLw,"when calling push in SoundUtils, line 147")
else
call wLu(iLw,"when calling SoundInstance in SoundUtils, line 149")
endif
call e2w(tLw,"when calling release in SoundUtils, line 151")
set Ad=Ad-1
set tLw=null
endfunction
function Y4u takes nothing returns nothing
set Ad=0
call SLw("SoundUtils, line 136")
endfunction
function Y9 takes nothing returns boolean
local unit d9=GetFilterUnit()
local integer f9
local boolean R9
local boolean T9
if IsUnitType(d9,UNIT_TYPE_STRUCTURE) and xtu(d9) then
set f9=Oe[sww(d9)]
set R9=f9>=861 and f9<=867
else
set R9=false
endif
set T9=R9 and wO[kQw(utu(d9))]!=0
set d9=null
return T9
endfunction
function Yh takes nothing returns boolean
set Y="Abilities\\Spells\\Items\\AIam\\AIamTarget.mdx"
set G="Abilities\\Spells\\Human\\Avatar\\AvatarCaster.mdx"
set g="Abilities\\Weapons\\BansheeMissile\\BansheeMissile.mdx"
set h="Abilities\\Weapons\\CannonTowerMissile\\CannonTowerMissile.mdx"
set F="Abilities\\Spells\\Other\\Charm\\CharmTarget.mdx"
set k="Abilities\\Spells\\Other\\CrushingWave\\CrushingWaveMissile.mdx"
set j="Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdx"
set x="Abilities\\Spells\\Orc\\FeralSpirit\\feralspiritdone.mdx"
set v="Abilities\\Weapons\\FragDriller\\FragDriller.mdx"
set m="Abilities\\Weapons\\GryphonRiderMissile\\GryphonRiderMissileTarget.mdx"
set Q="Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdx"
set W="Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdx"
set E="Abilities\\Spells\\Human\\ManaFlare\\ManaFlareBoltImpact.mdx"
set Z="Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdx"
set U="Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdx"
set I="Abilities\\Spells\\Undead\\PlagueCloud\\PlagueCloudCaster.mdx"
set P="Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdx"
set A="Abilities\\Spells\\Human\\ReviveHuman\\ReviveHuman.mdx"
set D="Abilities\\Spells\\NightElf\\ReviveNightElf\\ReviveNightElf.mdx"
set H="Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdx"
set J="Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdx"
set K="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdx"
set L="Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdx"
return true
endfunction
function jAw takes integer FAw,string kAw returns nothing
set KO[FAw]=kAw
call uMw(kAw)
endfunction
function uJu takes string MHu returns integer
local integer wJu
set Dd[Ad]=MHu
set Ad=Ad+1
if Tn==0 then
if Yn<32768 then
set Yn=Yn+1
set wJu=Yn
else
call tsw("Out of memory: Could not create Delimiter.","when calling error in ")
set wJu=0
endif
else
set Tn=Tn-1
set wJu=Rn[Tn]
endif
set Ad=Ad-1
return wJu
endfunction
function hAw takes string YAw,string GAw returns integer
local integer gAw
set Dd[Ad]=GAw
set Ad=Ad+1
set gAw=uJu("when calling Delimiter in Scanner, line 18")
call jAw(gAw,YAw)
set Ad=Ad-1
return gAw
endfunction
function qRw takes string eRw returns boolean
set Dd[Ad]=eRw
set Ad=Ad+1
call hAw("=","when calling new_Delimiter in Json, line 9")
set oc=hAw("_","when calling new_Delimiter in Json, line 10")
call hAw("(","when calling new_Delimiter in Json, line 11")
call hAw(")","when calling new_Delimiter in Json, line 12")
set Oc=hAw("[","when calling new_Delimiter in Json, line 13")
set lc=hAw("]","when calling new_Delimiter in Json, line 14")
call hAw("J","when calling new_Delimiter in Json, line 15")
set Ad=Ad-1
return true
endfunction
function Z1u takes nothing returns boolean
set Ad=0
return qRw("Json, line 1")
endfunction
function Z3w takes nothing returns boolean
local item E3w
set Nb=10.*10.
set Mb=2003790951
set E3w=Zfw(Mb,pp,ep)
call SRw(E3w,false)
set wy=E3w
set uy=Rect(0.,0.,128.,128.)
set sy=0
call bUw(vo-jo)
call bUw(mo-xo)
set E3w=null
return true
endfunction
function ZB takes nothing returns boolean
local integer EB
set rr=OO[9]
set EB=0
loop
exitwhen EB>31
call R2I(Pow(2.,I2R(EB)))
set EB=EB+1
endloop
return true
endfunction
function Zxw takes nothing returns boolean
return true
endfunction
function D4 takes integer P4,boolean A4 returns nothing
endfunction
function Ugu takes string Egu returns integer
local integer Zgu
set Dd[Ad]=Egu
set Ad=Ad+1
if Fq==0 then
if kq<32768 then
set kq=kq+1
set Zgu=kq
else
call tsw("Out of memory: Could not create Iterator.","when calling error in ")
set Zgu=0
endif
else
set Fq=Fq-1
set Zgu=hq[Fq]
endif
set Ad=Ad-1
return Zgu
endfunction
function I4 takes boolean E4,string Z4 returns integer
local integer U4
set Dd[Ad]=Z4
set Ad=Ad+1
set U4=Ugu("when calling Iterator in LinkedListModule, line 75")
call D4(U4,E4)
set Ad=Ad-1
return U4
endfunction
function W4 takes integer m4,boolean Q4 returns nothing
endfunction
function Wgu takes string mgu returns integer
local integer Qgu
set Dd[Ad]=mgu
set Ad=Ad+1
if Gq==0 then
if gq<32768 then
set gq=gq+1
set Qgu=gq
else
call tsw("Out of memory: Could not create BackIterator.","when calling error in ")
set Qgu=0
endif
else
set Gq=Gq-1
set Qgu=Yq[Gq]
endif
set Ad=Ad-1
return Qgu
endfunction
function v4 takes boolean k4,string j4 returns integer
local integer x4
set Dd[Ad]=j4
set Ad=Ad+1
set x4=Wgu("when calling BackIterator in LinkedListModule, line 97")
call W4(x4,k4)
set Ad=Ad-1
return x4
endfunction
function X1 takes string L1 returns boolean
set Dd[Ad]=L1
set Ad=Ad+1
set Hr=2019847535
set Jr=500000
set rs=0
set ss=0
set ts=0
call I4(false,"when calling new_Iterator in LinkedListModule, line 55")
call v4(false,"when calling new_BackIterator in LinkedListModule, line 65")
set Kr=CreateTimer()
set Ad=Ad-1
return true
endfunction
function a1u takes nothing returns boolean
set Ad=0
return X1("DmgMod, line 1")
endfunction
function wjw takes string Mkw returns nothing
set Dd[Ad]=Mkw
set Ad=Ad+1
call Nkw("when calling update in MultiboardSystem, line 14")
set Ad=Ad-1
endfunction
function a4u takes nothing returns nothing
set Ad=0
call wjw("MultiboardSystem, line 14")
endfunction
function aRw takes nothing returns boolean
set KS="-0123456789"
set LS="abcdefghijklmnopqrstuvwxyz"
return true
endfunction
function Iow takes force Zow,player Uow returns nothing
call ForceAddPlayer(Zow,Uow)
endfunction
function asw takes nothing returns boolean
set ti=CreateForce()
call Iow(ti,lO)
set ci=0
return true
endfunction
function CNw takes nothing returns nothing
set Hb[0]=""
set Hb[1]=""
set Hb[2]=""
set Hb[3]=""
set Hb[4]=""
set Hb[5]=""
set Hb[6]=""
set Hb[7]=""
set Hb[8]=""
set Hb[9]="\t"
set Hb[10]="\n"
set Hb[11]=""
set Hb[12]=""
set Hb[13]="\r"
set Hb[14]=""
set Hb[15]=""
set Hb[16]=""
set Hb[17]=""
set Hb[18]=""
set Hb[19]=""
set Hb[20]=""
set Hb[21]=""
set Hb[22]=""
set Hb[23]=""
set Hb[24]=""
set Hb[25]=""
set Hb[26]=""
set Hb[27]=""
set Hb[28]=""
set Hb[29]=""
set Hb[30]=""
set Hb[31]=""
set Hb[32]=" "
set Hb[33]="!"
set Hb[34]="\""
set Hb[35]="#"
set Hb[36]="$"
set Hb[37]="%"
set Hb[38]="&"
set Hb[39]="'"
set Hb[40]="("
set Hb[41]=")"
set Hb[42]="*"
set Hb[43]="+"
set Hb[44]=","
set Hb[45]="-"
set Hb[46]="."
set Hb[47]="/"
set Hb[48]="0"
set Hb[49]="1"
set Hb[50]="2"
set Hb[51]="3"
set Hb[52]="4"
set Hb[53]="5"
set Hb[54]="6"
set Hb[55]="7"
set Hb[56]="8"
set Hb[57]="9"
set Hb[58]=":"
set Hb[59]=";"
set Hb[60]="<"
set Hb[61]="="
set Hb[62]=">"
set Hb[63]="?"
set Hb[64]="@"
set Hb[65]="A"
set Hb[66]="B"
set Hb[67]="C"
set Hb[68]="D"
set Hb[69]="E"
set Hb[70]="F"
set Hb[71]="G"
set Hb[72]="H"
set Hb[73]="I"
set Hb[74]="J"
set Hb[75]="K"
set Hb[76]="L"
set Hb[77]="M"
set Hb[78]="N"
set Hb[79]="O"
set Hb[80]="P"
set Hb[81]="Q"
set Hb[82]="R"
set Hb[83]="S"
set Hb[84]="T"
set Hb[85]="U"
set Hb[86]="V"
set Hb[87]="W"
set Hb[88]="X"
set Hb[89]="Y"
set Hb[90]="Z"
set Hb[91]="["
set Hb[92]="\\"
set Hb[93]="]"
set Hb[94]="^"
set Hb[95]="_"
set Hb[96]="`"
set Hb[97]="a"
set Hb[98]="b"
set Hb[99]="c"
set Hb[100]="d"
set Hb[101]="e"
set Hb[102]="f"
set Hb[103]="g"
set Hb[104]="h"
set Hb[105]="i"
set Hb[106]="j"
set Hb[107]="k"
set Hb[108]="l"
set Hb[109]="m"
set Hb[110]="n"
set Hb[111]="o"
set Hb[112]="p"
set Hb[113]="q"
set Hb[114]="r"
set Hb[115]="s"
set Hb[116]="t"
set Hb[117]="u"
set Hb[118]="v"
set Hb[119]="w"
set Hb[120]="x"
set Hb[121]="y"
set Hb[122]="z"
set Hb[123]="{"
set Hb[124]="|"
set Hb[125]="}"
set Hb[126]="~"
set Hb[127]=""
endfunction
function MNw takes nothing returns nothing
endfunction
function TMw takes string RMw returns string
return StringCase(RMw,true)
endfunction
function NNw takes nothing returns nothing
local integer VNw=0
local integer BNw=Jb
loop
exitwhen VNw>BNw
if TMw(Hb[VNw])==Hb[VNw]then
endif
set VNw=VNw+1
endloop
endfunction
function initialize takes nothing returns nothing
call CNw()
call NNw()
call MNw()
endfunction
function XNw takes string LNw returns boolean
set Dd[Ad]=LNw
set Ad=Ad+1
set Jb=126+1
call initialize()
call J0u("","when calling stringToIndex in StringUtils, line 165")
set Ad=Ad-1
return true
endfunction
function b1u takes nothing returns boolean
set Ad=0
return XNw("StringUtils, line 1")
endfunction
function oku takes string Sku returns integer
local integer cku
set Dd[Ad]=Sku
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set cku=oe
set Oe[cku]=849
else
call tsw("Out of memory: Could not create EndBoss.","when calling error in ")
set cku=0
endif
else
set ce=ce-1
set cku=Se[ce]
set Oe[cku]=849
endif
set Ad=Ad-1
return cku
endfunction
function gU takes integer qU,real aU,real nU,real dU,integer fU,integer RU,real TU,real YU,string GU returns nothing
set Dd[Ad]=GU
set Ad=Ad+1
call J2u(0,0,0,0,7,qU,0,null,aU,nU,dU,fU,RU,TU,YU,qlu(aU,nU,dU,TU,YU),"when calling construct_Creep in Boss, line 10",null,0.,0.,0.,0.,null,null,null)
set Kw[qU]=Kqu(Nt[qU],"war3mapImported\\GeneralHeroGlow.mdx","origin")
if fU==1848651827 then
call xKu(Jw,"when calling play in Boss, line 14")
endif
set Ad=Ad-1
endfunction
function r0w takes integer K9,real L9,real X9,real C9,integer V9,integer B9,real N9,real M9,integer w0w,string u0w returns nothing
set Dd[Ad]=u0w
set Ad=Ad+1
call gU(K9,L9,X9,C9,V9,B9,N9,M9,"when calling construct_Boss in EndBoss, line 25")
set qt[K9]=1
set at[K9]=0
set dt[K9]=Ngw("when calling new_LinkedList in EndBoss, line 22")
call j3u(dt[K9],J0u("blockade","when calling stringToIndex in EndBoss, line 27"),"when calling add in EndBoss, line 27")
call j3u(dt[K9],J0u("destroyerSummoner","when calling stringToIndex in EndBoss, line 28"),"when calling add in EndBoss, line 28")
set nt[K9]=b2w("when calling getTimer in EndBoss, line 29")
call s2w(nt[K9],K9,"when calling setData in EndBoss, line 30")
call Q2w(nt[K9],ct,LG)
set ft[K9]=w0w
set Ad=Ad-1
endfunction
function J9 takes real Q9,real W9,real E9,integer Z9,integer U9,real I9,real P9,integer A9,string D9 returns integer
local integer H9
set Dd[Ad]=D9
set Ad=Ad+1
set H9=oku("when calling EndBoss in EndBoss, line 25")
call r0w(H9,Q9,W9,E9,Z9,U9,I9,P9,A9,"when calling construct_EndBoss in EndBoss, line 25")
set Ad=Ad-1
return H9
endfunction
function Ogu takes string cgu returns integer
local integer ogu
set Dd[Ad]=cgu
set Ad=Ad+1
if qq==0 then
if aq<32768 then
set aq=aq+1
set ogu=aq
set nq[ogu]=738
else
call tsw("Out of memory: Could not create FinalBossSummoning.","when calling error in ")
set ogu=0
endif
else
set qq=qq-1
set ogu=eq[qq]
set nq[ogu]=738
endif
set Ad=Ad-1
return ogu
endfunction
function GC takes integer YC returns nothing
endfunction
function dgu takes string agu returns integer
local integer ngu
set Dd[Ad]=agu
set Ad=Ad+1
if bq==0 then
if yq<32768 then
set yq=yq+1
set ngu=yq
set pq[ngu]=655
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set ngu=0
endif
else
set bq=bq-1
set ngu=lq[bq]
set pq[ngu]=655
endif
set Ad=Ad-1
return ngu
endfunction
function dC takes integer qC,real aC,string nC returns nothing
set Dd[Ad]=nC
set Ad=Ad+1
set Iu[qC]=b2w("when calling getTimer in ClosureTimers, line 89")
call s2w(Iu[qC],qC,"when calling setData in ClosureTimers, line 90")
call Q2w(Iu[qC],aC,ZG)
set Ad=Ad-1
endfunction
function IYu takes integer EYu,real ZYu,string UYu returns nothing
set Dd[Ad]=UYu
set Ad=Ad+1
if pq[EYu]==0 then
if EYu==0 then
call tsw("Nullpointer exception when calling CallbackPeriodic.ClosureTimers_CallbackPeriodic_start","when calling error in ")
else
call tsw("Called CallbackPeriodic.ClosureTimers_CallbackPeriodic_start on invalid object.","when calling error in ")
endif
endif
call dC(EYu,ZYu,"when calling start in ClosureTimers, line 88")
set Ad=Ad-1
endfunction
function mX takes real jX,integer xX,string vX returns integer
set Dd[Ad]=vX
set Ad=Ad+1
call IYu(xX,jX,"when calling start in ClosureTimers, line 36")
set Ad=Ad-1
return xX
endfunction
function W1 takes integer k1,integer j1,string x1 returns nothing
local integer v1
local real m1
local integer Q1
set Dd[Ad]=x1
set Ad=Ad+1
set Qr[k1]=0.
set Wr[k1]=0.
set Er[k1]=0
set Zr[k1]=Ngw("when calling new_LinkedList in DestroyerSummoner, line 20")
set Ur[k1]=0
set Pr[k1]=Ptw(Ycu(Up,Ip),jf,xf,"0%",12.,"when calling createFText in DestroyerSummoner, line 23")
set Ar[k1]=j1
call F4w(pi[Pr[k1]],false)
set Q1=k1
set m1=kr
set v1=dgu("when calling alloc_Closure in DestroyerSummoner, line 29")
call GC(v1)
set Dr[v1]=k1
set Ir[Q1]=mX(m1,v1,"when calling doPeriodically in DestroyerSummoner, line 29")
set Ad=Ad-1
endfunction
function Z3 takes integer Q3,string W3 returns integer
local integer E3
set Dd[Ad]=W3
set Ad=Ad+1
set E3=Ogu("when calling FinalBossSummoning in DestroyerSummoner, line 26")
call W1(E3,Q3,"when calling construct_FinalBossSummoning in DestroyerSummoner, line 26")
set Ad=Ad-1
return E3
endfunction
function F8 takes integer Y8,string G8 returns nothing
local integer g8
local integer h8
set Dd[Ad]=G8
set Ad=Ad+1
set bt[Y8]=Ngw("when calling new_LinkedList in EndBoss, line 109")
set pt[Y8]=false
call PlayMusic(Rt[tt])
call xKu(VJw(Ob,false,"when calling new_SoundDefinition in EndBoss, line 116"),"when calling play in EndBoss, line 116")
call gEw("|cffE62121 Prepare for your end!")
set yt[Y8]=Z3(Y8,"when calling new_FinalBossSummoning in EndBoss, line 118")
set g8=0
set h8=Zp
loop
exitwhen g8>h8
call j3u(bt[Y8],J9(Ycu(fUw(Ep[g8]),qR),jf,xf,st,175,Up,Ip,Y8,"when calling new_EndBoss in EndBoss, line 120"),"when calling add in EndBoss, line 120")
set g8=g8+1
endloop
set Ad=Ad-1
endfunction
function jku takes string Fku returns integer
local integer kku
set Dd[Ad]=Fku
set Ad=Ad+1
if ra==0 then
if sa<32768 then
set sa=sa+1
set kku=sa
set ta[kku]=717
else
call tsw("Out of memory: Could not create EndBossFight.","when calling error in ")
set kku=0
endif
else
set ra=ra-1
set kku=ua[ra]
set ta[kku]=717
endif
set Ad=Ad-1
return kku
endfunction
function T8 takes string f8 returns integer
local integer R8
set Dd[Ad]=f8
set Ad=Ad+1
set R8=jku("when calling EndBossFight in EndBoss, line 114")
call F8(R8,"when calling construct_EndBossFight in EndBoss, line 114")
set Ad=Ad-1
return R8
endfunction
function V7 takes string C7 returns nothing
set Dd[Ad]=C7
set Ad=Ad+1
call vEw("    |cffFFC519Beat the final boss to win!",25.)
set lt=T8("when calling new_EndBossFight in EndBoss, line 146")
set Ad=Ad-1
endfunction
function b4u takes nothing returns nothing
set Ad=0
call V7("GameConditions, line 25")
endfunction
function bJw takes nothing returns boolean
return true
endfunction
function osw takes string csw returns boolean
set Dd[Ad]=csw
set Ad=Ad+1
call wqw("when calling new_HashMap in EventHelper, line 6")
call wqw("when calling new_HashMap in EventHelper, line 7")
call v3w("when calling new_Table in EventHelper, line 8")
set Ad=Ad-1
return true
endfunction
function c1u takes nothing returns boolean
set Ad=0
return osw("EventHelper, line 1")
endfunction
function TLu takes string fLu returns integer
local integer RLu
set Dd[Ad]=fLu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set RLu=ae
set ne[RLu]=684
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set RLu=0
endif
else
set qe=qe-1
set RLu=ee[qe]
set ne[RLu]=684
endif
set Ad=Ad-1
return RLu
endfunction
function gLu takes string YLu returns integer
local integer GLu
set Dd[Ad]=YLu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set GLu=ae
set ne[GLu]=685
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set GLu=0
endif
else
set qe=qe-1
set GLu=ee[qe]
set ne[GLu]=685
endif
set Ad=Ad-1
return GLu
endfunction
function ruw takes integer uuw returns nothing
set Pt[uuw]=Pt[uuw]+1
endfunction
function ZXw takes integer RXw,string TXw returns nothing
local unit YXw
local unit GXw
local unit gXw
local integer hXw
local real FXw
local real kXw
local integer jXw
local integer xXw
local integer vXw
local real mXw
local real QXw
local real WXw
local integer EXw
set Dd[Ad]=TXw
set Ad=Ad+1
call ruw(RXw)
if xtu(Nt[RXw]) then
set Yb[RXw]=Yb[RXw]+1
if Yb[RXw]>=fb then
set Yb[RXw]=GetRandomInt(-4,4)
set YXw=Nt[RXw]
call SSu(YXw,Qh(0))
set GXw=YXw
call Tiu(GXw,"Stand Work Gold")
set gXw=GXw
call Oiu(gXw,"Stand Work Gold")
set hXw=TLu("when calling alloc_Closure in SpecialFive, line 29")
call VC(hXw)
set ab[hXw]=RXw
call gX(6.,hXw,"when calling doAfter in SpecialFive, line 29")
set QXw=wou(EOu(wvu(RXw,"when calling getPos in SpecialFive, line 32"),sf,tf),Ef,Psu(Nt[RXw]),128.)
set WXw=Cd
set FXw=QXw
set kXw=WXw
set jXw=1
set xXw=Rb
loop
exitwhen jXw>xXw
set mXw=Ofw(jXw-1)*1.5
set vXw=gLu("when calling alloc_Closure in SpecialFive, line 34")
call VC(vXw)
set EXw=vXw
set nb[EXw]=FXw
set db[EXw]=kXw
call gX(mXw,vXw,"when calling doAfter in SpecialFive, line 34")
set jXw=jXw+1
endloop
endif
endif
set Ad=Ad-1
set YXw=null
set GXw=null
set gXw=null
endfunction
function LH takes real DH,real HH,real JH,real KH returns nothing
call PanCameraToTimedWithZ(DH,HH,JH-hcu(EOu(DH,HH,JH),Ef),KH)
endfunction
function oJ takes player sJ,real tJ,real iJ,real SJ,real cJ returns nothing
if lO==sJ then
call LH(tJ,iJ,SJ,cJ)
endif
endfunction
function wDw takes integer NAw,string MAw returns nothing
set Dd[Ad]=MAw
set Ad=Ad+1
call ruw(NAw)
call oJ(Et[NAw],wvu(NAw,"when calling getPos in Selector, line 64"),sf,tf,0.)
call NQw(Et[NAw],Nt[NAw])
set Ad=Ad-1
endfunction
function wxu takes integer Nju,string Mju returns nothing
set Dd[Ad]=Mju
set Ad=Ad+1
if Oe[Nju]==0 then
if Nju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_slowUpdate","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_slowUpdate on invalid object.","when calling error in ")
endif
endif
if Oe[Nju]<=859 then
if Oe[Nju]<=853 then
if Oe[Nju]<=852 then
call ruw(Nju)
else
call ZXw(Nju,"when calling slowUpdate in Entity, line 170")
endif
else
call ruw(Nju)
endif
elseif Oe[Nju]<=860 then
call wDw(Nju,"when calling slowUpdate in Entity, line 170")
else
call ruw(Nju)
endif
set Ad=Ad-1
endfunction
function K0w takes string H0w returns nothing
local integer J0w
set Dd[Ad]=H0w
set Ad=Ad+1
set J0w=Ht
loop
exitwhen not(J0w!=0)
call wxu(J0w,"when calling slowUpdate in EntityManagement, line 16")
set J0w=Ct[J0w]
endloop
set Ad=Ad-1
endfunction
function c4u takes nothing returns nothing
set Ad=0
call K0w("EntityManagement, line 28")
endfunction
function cfw takes nothing returns boolean
set HS=2147483647
set JS=-2147483648
return true
endfunction
function Cfu takes string Lfu returns integer
local integer Xfu
set Dd[Ad]=Lfu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set Xfu=Le
set Xe[Xfu]=720
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set Xfu=0
endif
else
set Ke=Ke-1
set Xfu=Je[Ke]
set Xe[Xfu]=720
endif
set Ad=Ad-1
return Xfu
endfunction
function Nfu takes string Vfu returns integer
local integer Bfu
set Dd[Ad]=Vfu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set Bfu=Le
set Xe[Bfu]=721
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set Bfu=0
endif
else
set Ke=Ke-1
set Bfu=Je[Ke]
set Xe[Bfu]=721
endif
set Ad=Ad-1
return Bfu
endfunction
function dA takes integer aA,boolean nA returns nothing
set bu[aA]=Su
endfunction
function wTu takes string NRu returns integer
local integer MRu
set Dd[Ad]=NRu
set Ad=Ad+1
if Me==0 then
if wq<32768 then
set wq=wq+1
set MRu=wq
set uq[MRu]=768
else
call tsw("Out of memory: Could not create Iterator.","when calling error in ")
set MRu=0
endif
else
set Me=Me-1
set MRu=Ne[Me]
set uq[MRu]=768
endif
set Ad=Ad-1
return MRu
endfunction
function oA takes boolean iA,string SA returns integer
local integer cA
set Dd[Ad]=SA
set Ad=Ad+1
set cA=wTu("when calling Iterator in LinkedListModule, line 75")
call dA(cA,iA)
set Ad=Ad-1
return cA
endfunction
function tRu takes string rRu returns integer
local integer sRu
set Dd[Ad]=rRu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set sRu=Le
set Xe[sRu]=722
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set sRu=0
endif
else
set Ke=Ke-1
set sRu=Je[Ke]
set Xe[sRu]=722
endif
set Ad=Ad-1
return sRu
endfunction
function XRu takes string KRu returns integer
local integer LRu
set Dd[Ad]=KRu
set Ad=Ad+1
if Ve==0 then
if Be<32768 then
set Be=Be+1
set LRu=Be
else
call tsw("Out of memory: Could not create BackIterator.","when calling error in ")
set LRu=0
endif
else
set Ve=Ve-1
set LRu=Ce[Ve]
endif
set Ad=Ad-1
return LRu
endfunction
function tA takes integer rA,boolean sA returns nothing
endfunction
function uA takes boolean NP,string MP returns integer
local integer wA
set Dd[Ad]=MP
set Ad=Ad+1
set wA=XRu("when calling BackIterator in LinkedListModule, line 97")
call tA(wA,NP)
set Ad=Ad-1
return wA
endfunction
function HU takes string EU returns boolean
local integer ZU
local integer UU
local integer IU
local unitevent PU
local playerunitevent AU
local playerunitevent DU
set Dd[Ad]=EU
set Ad=Ad+1
set Vw=0.25
set Su=0
set cu=0
set ou=0
call oA(false,"when calling new_Iterator in LinkedListModule, line 55")
call uA(false,"when calling new_BackIterator in LinkedListModule, line 65")
set PU=EVENT_UNIT_DAMAGED
set ZU=Cfu("when calling alloc_Closure in Buff, line 122")
call cL(ZU)
call pK(PU,ZU,"when calling add in Buff, line 122")
set AU=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set UU=Nfu("when calling alloc_Closure in Buff, line 146")
call cL(UU)
call pK(AU,UU,"when calling add in Buff, line 146")
set DU=EVENT_PLAYER_UNIT_DEATH
set IU=tRu("when calling alloc_Closure in Buff, line 157")
call cL(IU)
call pK(DU,IU,"when calling add in Buff, line 157")
set Ad=Ad-1
set PU=null
set AU=null
set DU=null
return true
endfunction
function d1u takes nothing returns boolean
set Ad=0
return HU("Buff, line 1")
endfunction
function IJu takes integer ZJu,string UJu returns nothing
set Dd[Ad]=UJu
set Ad=Ad+1
if Kq[ZJu]==0 then
call tsw("Double free: object of type SeqCallback","when calling error in ")
else
set Dq[Hq]=ZJu
set Hq=Hq+1
set Kq[ZJu]=0
endif
set Ad=Ad-1
endfunction
function xHw takes integer kHw,string jHw returns nothing
set Dd[Ad]=jHw
set Ad=Ad+1
if al[kHw]!=null then
call e2w(al[kHw],"when calling release in SeqWorker, line 53")
set al[kHw]=null
endif
set Ad=Ad-1
endfunction
function gHw takes integer YHw,string GHw returns nothing
set Dd[Ad]=GHw
set Ad=Ad+1
call xHw(YHw,"when calling SeqCallback_onDestroy in SeqWorker, line 51")
call IJu(YHw,"when calling SeqCallback in SeqWorker, line 51")
set Ad=Ad-1
endfunction
function YJu takes integer RJu,string TJu returns nothing
set Dd[Ad]=TJu
set Ad=Ad+1
if Kq[RJu]==0 then
if RJu==0 then
call tsw("Nullpointer exception when calling SeqCallback.destroySeqCallback","when calling error in ")
else
call tsw("Called SeqCallback.destroySeqCallback on invalid object.","when calling error in ")
endif
endif
call gHw(RJu,"when calling destroySeqCallback in SeqWorker, line 32")
set Ad=Ad-1
endfunction
function THw takes integer fHw,string RHw returns nothing
set Dd[Ad]=RHw
set Ad=Ad+1
if (not ql[fHw])or al[fHw]!=null then
set ql[fHw]=true
call YJu(fHw,"when calling SeqCallback in SeqWorker, line 42")
endif
set Ad=Ad-1
endfunction
function hJu takes integer GJu,string gJu returns nothing
set Dd[Ad]=gJu
set Ad=Ad+1
if Kq[GJu]==0 then
if GJu==0 then
call tsw("Nullpointer exception when calling SeqCallback.SeqWorker_SeqCallback_terminate","when calling error in ")
else
call tsw("Called SeqCallback.SeqWorker_SeqCallback_terminate on invalid object.","when calling error in ")
endif
endif
call THw(GJu,"when calling terminate in SeqWorker, line 39")
set Ad=Ad-1
endfunction
function O3u takes integer i3u,integer S3u,string c3u returns string
local string o3u
set Dd[Ad]=c3u
set Ad=Ad+1
if S3u<0 or S3u>=25 then
call tsw("Index out of Bounds","when calling error in ")
elseif S3u<=12 then
if S3u<=6 then
if S3u<=3 then
if S3u<=1 then
if S3u<=0 then
set o3u=od[i3u]
else
set o3u=Od[i3u]
endif
elseif S3u<=2 then
set o3u=ld[i3u]
else
set o3u=bd[i3u]
endif
elseif S3u<=5 then
if S3u<=4 then
set o3u=yd[i3u]
else
set o3u=pd[i3u]
endif
else
set o3u=ed[i3u]
endif
elseif S3u<=9 then
if S3u<=8 then
if S3u<=7 then
set o3u=qd[i3u]
else
set o3u=ad[i3u]
endif
else
set o3u=nd[i3u]
endif
elseif S3u<=11 then
if S3u<=10 then
set o3u=dd[i3u]
else
set o3u=fd[i3u]
endif
else
set o3u=Rd[i3u]
endif
elseif S3u<=18 then
if S3u<=15 then
if S3u<=14 then
if S3u<=13 then
set o3u=Td[i3u]
else
set o3u=Yd[i3u]
endif
else
set o3u=Gd[i3u]
endif
elseif S3u<=17 then
if S3u<=16 then
set o3u=gd[i3u]
else
set o3u=hd[i3u]
endif
else
set o3u=Fd[i3u]
endif
elseif S3u<=21 then
if S3u<=20 then
if S3u<=19 then
set o3u=kd[i3u]
else
set o3u=jd[i3u]
endif
else
set o3u=xd[i3u]
endif
elseif S3u<=23 then
if S3u<=22 then
set o3u=vd[i3u]
else
set o3u=md[i3u]
endif
else
set o3u=Qd[i3u]
endif
set Ad=Ad-1
return o3u
endfunction
function dv takes integer nv returns integer
return fw[nv]
endfunction
function ddu takes integer qdu,string adu returns integer
local integer ndu
set Dd[Ad]=adu
set Ad=Ad+1
if We[qdu]==0 then
if qdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_getStart","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_getStart on invalid object.","when calling error in ")
endif
endif
set ndu=dv(qdu)
set Ad=Ad-1
return ndu
endfunction
function ev takes integer pv returns integer
return Rw[pv]
endfunction
function ldu takes integer cdu,string odu returns integer
local integer Odu
set Dd[Ad]=odu
set Ad=Ad+1
if We[cdu]==0 then
if cdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_getSingleLength","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_getSingleLength on invalid object.","when calling error in ")
endif
endif
set Odu=ev(cdu)
set Ad=Ad-1
return Odu
endfunction
function dx takes integer lx,integer bx,string yx returns string
local integer px
local integer ex
local integer qx
local string ax
local string nx
set Dd[Ad]=yx
set Ad=Ad+1
if ddu(bx,"when calling getStart in BigString, line 154")+ldu(bx,"when calling getSingleLength in BigString, line 154")>qw[lx]then
call tsw("string out of bounds: length: "+bfw(qw[lx])+" s.length: "+bfw(ldu(bx,"when calling getSingleLength in BigString, line 155"))+" s.start: "+bfw(ddu(bx,"when calling getStart in BigString, line 155")),"when calling error in BigString, line 155")
endif
if ldu(bx,"when calling getSingleLength in BigString, line 156")>pw then
call tsw("substring is longer than maxsize","when calling error in BigString, line 157")
endif
set px=bUw(ddu(bx,"when calling getStart in BigString, line 158")*1./pw)
set ex=ModuloInteger(ddu(bx,"when calling getStart in BigString, line 159"),pw)
set qx=ex+ldu(bx,"when calling getSingleLength in BigString, line 160")
if qx>pw then
set ax=iMw(O3u(lx,px,"when calling substrings in BigString, line 162"),ex,pw)+iMw(O3u(lx,px+1,"when calling substrings in BigString, line 162"),0,qx-pw)
set Ad=Ad-1
return ax
endif
set nx=iMw(O3u(lx,px,"when calling substrings in BigString, line 163"),ex,qx)
set Ad=Ad-1
return nx
endfunction
function Anu takes integer Znu,integer Unu,string Inu returns string
local string Pnu
set Dd[Ad]=Inu
set Ad=Ad+1
if xe[Znu]==0 then
if Znu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_getSubStringData","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_getSubStringData on invalid object.","when calling error in ")
endif
endif
set Pnu=dx(Znu,Unu,"when calling getSubStringData in BigString, line 153")
set Ad=Ad-1
return Pnu
endfunction
function jv takes integer hv,string Fv returns string
local string kv
set Dd[Ad]=Fv
set Ad=Ad+1
if ldu(hv,"when calling getSingleLength in BigString, line 42")>pw then
call tsw("cannot use getSingle on oversized SubStrings. You need to iterate through the chunks","when calling error in BigString, line 43")
endif
if nw[hv]==0 and Tw[hv]==null then
call tsw("cannot generate new cache without parent","when calling error in BigString, line 45")
endif
if Tw[hv]!=null then
set Ad=Ad-1
return Tw[hv]
else
set kv=Anu(nw[hv],hv,"when calling getSubStringData in BigString, line 49")
set Ad=Ad-1
return kv
endif
endfunction
function Ydu takes integer fdu,string Rdu returns string
local string Tdu
set Dd[Ad]=Rdu
set Ad=Ad+1
if We[fdu]==0 then
if fdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_getSingle","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_getSingle on invalid object.","when calling error in ")
endif
endif
set Tdu=jv(fdu,"when calling getSingle in BigString, line 41")
set Ad=Ad-1
return Tdu
endfunction
function NRw takes integer CRw,integer VRw,string BRw returns nothing
set Dd[Ad]=BRw
set Ad=Ad+1
if pc[VRw]!=0 and Rw[pc[VRw]]>=0 then
call j3u(yc[CRw],VRw,"when calling add in Json, line 44")
set dw[pc[VRw]]=0
set dw[ec[VRw]]=0
call YEu(bc[CRw],ZMw(Ydu(pc[VRw],"when calling getSingle in Json, line 47")),VRw,"when calling put in Json, line 47")
endif
set Ad=Ad-1
endfunction
function JZu takes integer AZu,integer DZu,string HZu returns nothing
set Dd[Ad]=HZu
set Ad=Ad+1
if Xa[AZu]==0 then
if AZu==0 then
call tsw("Nullpointer exception when calling Json.Json_Json_addProperty","when calling error in ")
else
call tsw("Called Json.Json_Json_addProperty on invalid object.","when calling error in ")
endif
endif
call NRw(AZu,DZu,"when calling addProperty in Json, line 42")
set Ad=Ad-1
endfunction
function Edu takes string Qdu returns integer
local integer Wdu
set Dd[Ad]=Qdu
set Ad=Ad+1
if me==0 then
if Qe<32768 then
set Qe=Qe+1
set Wdu=Qe
set We[Wdu]=635
else
call tsw("Out of memory: Could not create BigSubString.","when calling error in ")
set Wdu=0
endif
else
set me=me-1
set Wdu=ve[me]
set We[Wdu]=635
endif
set Ad=Ad-1
return Wdu
endfunction
function Nv takes integer Xv,integer Cv,integer Vv,integer Bv returns nothing
set nw[Xv]=0
set dw[Xv]=0
set fw[Xv]=0
set Rw[Xv]=0
set Tw[Xv]=null
set nw[Xv]=Cv
set fw[Xv]=Vv
set Rw[Xv]=Bv
endfunction
function gv takes integer fv,integer Rv,integer Tv,string Yv returns integer
local integer Gv
set Dd[Ad]=Yv
set Ad=Ad+1
set Gv=Edu("when calling BigSubString in BigString, line 18")
call Nv(Gv,fv,Rv,Tv)
set Ad=Ad-1
return Gv
endfunction
function XZu takes string KZu returns integer
local integer LZu
set Dd[Ad]=KZu
set Ad=Ad+1
if Va==0 then
if Ba<32768 then
set Ba=Ba+1
set LZu=Ba
else
call tsw("Out of memory: Could not create Property.","when calling error in ")
set LZu=0
endif
else
set Va=Va-1
set LZu=Ca[Va]
endif
set Ad=Ad-1
return LZu
endfunction
function cTw takes integer tTw,integer iTw,integer STw returns nothing
set pc[tTw]=iTw
set ec[tTw]=STw
endfunction
function sTw takes integer MRw,integer wTw,string uTw returns integer
local integer rTw
set Dd[Ad]=uTw
set Ad=Ad+1
set rTw=XZu("when calling Property in Json, line 21")
call cTw(rTw,MRw,wTw)
set Ad=Ad-1
return rTw
endfunction
function JRw takes integer ARw,string DRw returns nothing
local integer HRw
set Dd[Ad]=DRw
set Ad=Ad+1
set HRw=rc[ARw]
if HRw==0 then
set Sc[ARw]=gv(NS[ARw],MS[ARw],1,"when calling new_BigSubString in JsonParser, line 150")
set wc[ARw]=MS[ARw]+1
elseif HRw==2 then
set cc[ARw]=gv(NS[ARw],wc[ARw],MS[ARw]-wc[ARw],"when calling new_BigSubString in JsonParser, line 153")
call JZu(tc[ARw],sTw(Sc[ARw],cc[ARw],"when calling new_Property in JsonParser, line 154"),"when calling addProperty in JsonParser, line 154")
set Sc[ARw]=gv(NS[ARw],MS[ARw],1,"when calling new_BigSubString in JsonParser, line 155")
set wc[ARw]=MS[ARw]+1
elseif HRw==4 then
set Sc[ARw]=gv(NS[ARw],MS[ARw],1,"when calling new_BigSubString in JsonParser, line 158")
set wc[ARw]=MS[ARw]+1
endif
set rc[ARw]=1
set Ad=Ad-1
endfunction
function PZu takes integer UZu,string IZu returns nothing
set Dd[Ad]=IZu
set Ad=Ad+1
if La[UZu]==0 then
if UZu==0 then
call tsw("Nullpointer exception when calling JsonParser.JsonParser_JsonParser_onLetter","when calling error in ")
else
call tsw("Called JsonParser.JsonParser_JsonParser_onLetter on invalid object.","when calling error in ")
endif
endif
call JRw(UZu,"when calling onLetter in JsonParser, line 147")
set Ad=Ad-1
endfunction
function FMw takes string YMw,string GMw returns integer
local integer gMw=0
local integer hMw=uMw(YMw)-uMw(GMw)
loop
exitwhen gMw>hMw
if iMw(YMw,gMw,gMw+uMw(GMw))==GMw then
return gMw
endif
set gMw=gMw+1
endloop
return -1
endfunction
function WMw takes string mMw,string QMw returns boolean
return FMw(mMw,QMw)!=-1
endfunction
function Zx takes integer hx,integer Fx,integer kx,string jx returns string
local integer xx
local integer vx
local integer mx
local integer Qx
local string Wx
local string Ex
set Dd[Ad]=jx
set Ad=Ad+1
if Fx+kx>hnu(hx,"when calling getLength in BigString, line 174") then
call tsw("2Trying to get string out of bounds","when calling error in BigString, line 175")
endif
if kx>pw then
call tsw("Trying to get oversized string","when calling error in BigString, line 177")
endif
set xx=Fx+aw[hx]
set vx=bUw(xx*1./pw)
set mx=ModuloInteger(xx,pw)
set Qx=mx+kx
if Qx>pw then
set Wx=iMw(O3u(hx,vx,"when calling substrings in BigString, line 183"),mx,uMw(O3u(hx,vx,"when calling substrings in BigString, line 183")))+iMw(O3u(hx,vx+1,"when calling substrings in BigString, line 183"),0,Qx-pw)
set Ad=Ad-1
return Wx
endif
set Ex=iMw(O3u(hx,vx,"when calling substrings in BigString, line 184"),mx,Qx)
set Ad=Ad-1
return Ex
endfunction
function Xnu takes integer Dnu,integer Hnu,integer Jnu,string Knu returns string
local string Lnu
set Dd[Ad]=Knu
set Ad=Ad+1
if xe[Dnu]==0 then
if Dnu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_getString","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_getString on invalid object.","when calling error in ")
endif
endif
set Lnu=Zx(Dnu,Hnu,Jnu,"when calling getString in BigString, line 173")
set Ad=Ad-1
return Lnu
endfunction
function XRw takes integer KRw returns nothing
local integer LRw=rc[KRw]
if LRw==1 then
set wc[KRw]=MS[KRw]
endif
set rc[KRw]=2
endfunction
function ZZu takes integer WZu,string EZu returns nothing
set Dd[Ad]=EZu
set Ad=Ad+1
if La[WZu]==0 then
if WZu==0 then
call tsw("Nullpointer exception when calling JsonParser.JsonParser_JsonParser_onNumber","when calling error in ")
else
call tsw("Called JsonParser.JsonParser_JsonParser_onNumber on invalid object.","when calling error in ")
endif
endif
call XRw(WZu)
set Ad=Ad-1
endfunction
function PRw takes integer ZRw,string URw returns nothing
local string IRw
set Dd[Ad]=URw
set Ad=Ad+1
set sc[ZRw]=Xnu(NS[ZRw],MS[ZRw],1,"when calling getString in JsonParser, line 117")
set IRw=sc[ZRw]
if IRw==KO[Oc]then
set uc[ZRw]=uc[ZRw]+1
if uc[ZRw]==1 then
set wc[ZRw]=MS[ZRw]
endif
set rc[ZRw]=3
elseif IRw==KO[lc]then
set uc[ZRw]=uc[ZRw]-1
if uc[ZRw]==0 then
set cc[ZRw]=gv(NS[ZRw],wc[ZRw],MS[ZRw]-wc[ZRw]+1,"when calling new_BigSubString in JsonParser, line 127")
call JZu(tc[ZRw],sTw(Sc[ZRw],cc[ZRw],"when calling new_Property in JsonParser, line 128"),"when calling addProperty in JsonParser, line 128")
set wc[ZRw]=MS[ZRw]+1
endif
set rc[ZRw]=4
elseif uc[ZRw]==0 then
if WMw(LS,sc[ZRw]) then
call PZu(ZRw,"when calling onLetter in JsonParser, line 134")
elseif WMw(KS,sc[ZRw]) then
call ZZu(ZRw,"when calling onNumber in JsonParser, line 136")
endif
endif
set MS[ZRw]=MS[ZRw]+1
set Ad=Ad-1
endfunction
function QZu takes integer vZu,string mZu returns nothing
set Dd[Ad]=mZu
set Ad=Ad+1
if La[vZu]==0 then
if vZu==0 then
call tsw("Nullpointer exception when calling JsonParser.JsonParser_JsonParser_parseSeq","when calling error in ")
else
call tsw("Called JsonParser.JsonParser_JsonParser_parseSeq on invalid object.","when calling error in ")
endif
endif
call PRw(vZu,"when calling parseSeq in JsonParser, line 116")
set Ad=Ad-1
endfunction
function uv takes integer Bx,string Nx returns nothing
local integer Mx
local integer wv
set Dd[Ad]=Nx
set Ad=Ad+1
if TO==0 then
call DEw("BigString length: "+bfw(hnu(Bx,"when calling getLength in BigString, line 188"))+" lines: ")
set Mx=0
set wv=ew-1
loop
exitwhen Mx>wv
if uMw(O3u(Bx,Mx,"when calling substrings in BigString, line 190"))>0 then
call DEw("\n\tLine "+bfw(Mx)+" : "+O3u(Bx,Mx,"when calling substrings in BigString, line 191"))
else
exitwhen true
endif
set Mx=Mx+1
endloop
endif
set Ad=Ad-1
endfunction
function Bnu takes integer Cnu,string Vnu returns nothing
set Dd[Ad]=Vnu
set Ad=Ad+1
if xe[Cnu]==0 then
if Cnu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_debugPrint","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_debugPrint on invalid object.","when calling error in ")
endif
endif
call uv(Cnu,"when calling debugPrint in BigString, line 186")
set Ad=Ad-1
endfunction
function DFu takes string PFu returns integer
local integer AFu
set Dd[Ad]=PFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set AFu=Cq
set Vq[AFu]=750
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set AFu=0
endif
else
set Xq=Xq-1
set AFu=Lq[Xq]
set Vq[AFu]=750
endif
set Ad=Ad-1
return AFu
endfunction
function EFu takes string QFu returns integer
local integer WFu
set Dd[Ad]=QFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set WFu=Cq
set Vq[WFu]=748
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set WFu=0
endif
else
set Xq=Xq-1
set WFu=Lq[Xq]
set Vq[WFu]=748
endif
set Ad=Ad-1
return WFu
endfunction
function IFu takes string ZFu returns integer
local integer UFu
set Dd[Ad]=ZFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set UFu=Cq
set Vq[UFu]=749
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set UFu=0
endif
else
set Xq=Xq-1
set UFu=Lq[Xq]
set Vq[UFu]=749
endif
set Ad=Ad-1
return UFu
endfunction
function bHw takes integer lHw returns nothing
endfunction
function fJu takes integer nJu,string dJu returns nothing
set Dd[Ad]=dJu
set Ad=Ad+1
if wa[nJu]==0 then
call tsw("Double free: object of type PayloadCallback","when calling error in ")
else
set Bq[Nq]=nJu
set Nq=Nq+1
set wa[nJu]=0
endif
set Ad=Ad-1
endfunction
function eHw takes integer yHw,string pHw returns nothing
set Dd[Ad]=pHw
set Ad=Ad+1
call bHw(yHw)
call fJu(yHw,"when calling PayloadCallback in SeqWorker, line 24")
set Ad=Ad-1
endfunction
function aJu takes integer eJu,string qJu returns nothing
set Dd[Ad]=qJu
set Ad=Ad+1
if wa[eJu]==0 then
if eJu==0 then
call tsw("Nullpointer exception when calling PayloadCallback.destroyPayloadCallback","when calling error in ")
else
call tsw("Called PayloadCallback.destroyPayloadCallback on invalid object.","when calling error in ")
endif
endif
call eHw(eJu,"when calling destroyPayloadCallback in SeqWorker, line 24")
set Ad=Ad-1
endfunction
function sUu takes string uUu returns integer
local integer rUu
set Dd[Ad]=uUu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set rUu=ae
set ne[rUu]=678
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set rUu=0
endif
else
set qe=qe-1
set rUu=ee[qe]
set ne[rUu]=678
endif
set Ad=Ad-1
return rUu
endfunction
function ITw takes integer WTw,integer ETw,string ZTw returns nothing
local integer UTw
set Dd[Ad]=ZTw
set Ad=Ad+1
if el[ETw]==1 then
call DEw("file valid")
set UTw=sUu("when calling alloc_Closure in LZW, line 66")
call VC(UTw)
set vc[UTw]=Qc[WTw]
set mc[UTw]=Wc[WTw]
call kX(UTw,"when calling nullTimer in LZW, line 66")
else
call tsw("loaded input is invalid","when calling error in LZW, line 89")
endif
call aJu(ETw,"when calling PayloadCallback in LZW, line 90")
set Ad=Ad-1
endfunction
function Sm takes boolean tm returns integer
local integer im
if tm then
set im=1
else
set im=0
endif
return im
endfunction
function yUu takes string lUu returns integer
local integer bUu
set Dd[Ad]=lUu
set Ad=Ad+1
if Hq==0 then
if Jq<32768 then
set Jq=Jq+1
set bUu=Jq
set Kq[bUu]=822
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set bUu=0
endif
else
set Hq=Hq-1
set bUu=Dq[Hq]
set Kq[bUu]=822
endif
set Ad=Ad-1
return bUu
endfunction
function TYw takes integer pYw,integer eYw,string qYw returns nothing
local integer aYw
local integer nYw
local string dYw
local string fYw
local integer RYw
set Dd[Ad]=qYw
set Ad=Ad+1
set aYw=el[eYw]
set nYw=cPu(aYw,"when calling staticItr in LZW, line 164")
set dYw=""
set fYw=""
set RYw=yUu("when calling alloc_Closure in LZW, line 168")
call FHw(RYw)
set Hc[RYw]=nYw
set Jc[RYw]=fYw
set Kc[RYw]=dYw
set Lc[RYw]=Cc[pYw]
set Xc[RYw]=Vc[pYw]
call MDw(RYw,"when calling doSeq in LZW, line 168")
set Ad=Ad-1
endfunction
function Uj takes integer Qj,string Wj returns nothing
local integer Ej
local integer Zj
set Dd[Ad]=Wj
set Ad=Ad+1
set Ej=ow[Qj]
loop
exitwhen not(Ej!=0)
set Zj=bw[Ej]
call Mau(Ej,"when calling BigNum_l in BigNum, line 75")
set Ej=Zj
endloop
set Ad=Ad-1
endfunction
function Vau takes integer Xau,string Cau returns nothing
set Dd[Ad]=Cau
set Ad=Ad+1
if Te[Xau]==0 then
call tsw("Double free: object of type BigNum","when calling error in ")
else
set de[fe]=Xau
set fe=fe+1
set Te[Xau]=0
endif
set Ad=Ad-1
endfunction
function Aj takes integer Ij,string Pj returns nothing
set Dd[Ad]=Pj
set Ad=Ad+1
call Uj(Ij,"when calling BigNum_onDestroy in BigNum, line 70")
call Vau(Ij,"when calling BigNum in BigNum, line 70")
set Ad=Ad-1
endfunction
function Tau takes integer fau,string Rau returns nothing
set Dd[Ad]=Rau
set Ad=Ad+1
if Te[fau]==0 then
if fau==0 then
call tsw("Nullpointer exception when calling BigNum.destroyBigNum","when calling error in ")
else
call tsw("Called BigNum.destroyBigNum on invalid object.","when calling error in ")
endif
endif
call Aj(fau,"when calling destroyBigNum in BigNum, line 63")
set Ad=Ad-1
endfunction
function I7 takes integer Z7,string U7 returns nothing
set Dd[Ad]=U7
set Ad=Ad+1
call Tau(Ms[Z7],"when calling BigNum in Encoder, line 23")
set Ad=Ad-1
endfunction
function cFu takes integer iFu,string SFu returns nothing
set Dd[Ad]=SFu
set Ad=Ad+1
if Aq[iFu]==0 then
call tsw("Double free: object of type Encoder","when calling error in ")
else
set Uq[Iq]=iFu
set Iq=Iq+1
set Aq[iFu]=0
endif
set Ad=Ad-1
endfunction
function D7 takes integer P7,string A7 returns nothing
set Dd[Ad]=A7
set Ad=Ad+1
call I7(P7,"when calling Encoder_onDestroy in Encoder, line 22")
call cFu(P7,"when calling Encoder in Encoder, line 22")
set Ad=Ad-1
endfunction
function ohu takes integer Shu,string chu returns nothing
set Dd[Ad]=chu
set Ad=Ad+1
if Aq[Shu]==0 then
if Shu==0 then
call tsw("Nullpointer exception when calling Encoder.destroyEncoder","when calling error in ")
else
call tsw("Called Encoder.destroyEncoder on invalid object.","when calling error in ")
endif
endif
call D7(Shu,"when calling destroyEncoder in Encoder, line 11")
set Ad=Ad-1
endfunction
function o5u takes integer B2u,integer N2u,integer M2u,integer w5u,string u5u,integer r5u,string s5u returns nothing
local integer t5u
local integer i5u
local integer S5u
local integer c5u
if B2u==0 then
if N2u==0 then
if M2u==0 then
set Dd[Ad]=u5u
set Ad=Ad+1
if wa[w5u]==0 then
if w5u==0 then
call tsw("Nullpointer exception when calling PayloadCallback.SeqWorker_PayloadCallback_doStep","when calling error in ")
else
call tsw("Called PayloadCallback.SeqWorker_PayloadCallback_doStep on invalid object.","when calling error in ")
endif
endif
call o5u(0,0,1,w5u,"when calling doStep in SeqWorker, line 27",0,null)
set Ad=Ad-1
elseif M2u==1 then
set Dd[Ad]=u5u
set Ad=Ad+1
call o5u(0,0,2,w5u,null,w5u,"when calling onExecute in SeqWorker, line 28")
set Ad=Ad-1
elseif M2u==2 then
set Dd[Ad]=s5u
set Ad=Ad+1
if wa[w5u]==0 then
if w5u==0 then
call tsw("Nullpointer exception when calling PayloadCallback.SeqWorker_PayloadCallback_onExecute","when calling error in ")
else
call tsw("Called PayloadCallback.SeqWorker_PayloadCallback_onExecute on invalid object.","when calling error in ")
endif
endif
if wa[w5u]<=807 then
if wa[w5u]<=806 then
if wa[w5u]<=805 then
call o5u(0,0,3,w5u,null,r5u,"when calling Encoder_closure_impl in SeqWorker, line 30")
else
call o5u(0,1,w5u,r5u,"when calling LZW_closure_impl in SeqWorker, line 30",0,null)
endif
else
call ITw(w5u,r5u,"when calling LZW_closure_impl in SeqWorker, line 30")
endif
elseif wa[w5u]<=808 then
call o5u(1,w5u,r5u,0,"when calling LZW_closure_impl in SeqWorker, line 30",0,null)
else
call TYw(w5u,r5u,"when calling LZW_closure_impl in SeqWorker, line 30")
endif
set Ad=Ad-1
elseif M2u==3 then
set Dd[Ad]=s5u
set Ad=Ad+1
call DEw("loaded..")
set t5u=EFu("when calling alloc_Closure in Encoder, line 129")
set Js[t5u]=Xs[w5u]
call xsw(t5u,"when calling execute in Encoder, line 129")
call DEw("decoded..")
set i5u=IFu("when calling alloc_Closure in Encoder, line 133")
set Ks[i5u]=Xs[w5u]
call xsw(i5u,"when calling execute in Encoder, line 133")
call DEw("claned..")
set S5u=DFu("when calling alloc_Closure in Encoder, line 135")
set Ls[S5u]=Xs[w5u]
call xsw(S5u,"when calling execute in Encoder, line 135")
call DEw("hashed..")
set el[Cs[w5u]]=Sm(ut[Xs[w5u]]==rt[Xs[w5u]])
call o5u(0,0,0,Cs[w5u],"when calling doStep in Encoder, line 140",0,null)
set Ad=Ad-1
endif
elseif N2u==1 then
set Dd[Ad]=u5u
set Ad=Ad+1
set el[fc[M2u]]=el[w5u]
call ohu(Rc[M2u],"when calling Encoder in LZW, line 53")
call o5u(0,0,0,fc[M2u],"when calling doStep in LZW, line 54",0,null)
set Ad=Ad-1
endif
elseif B2u==1 then
set Dd[Ad]=u5u
set Ad=Ad+1
call DEw("positions encoded")
set c5u=el[M2u]
call Bnu(c5u,"when calling debugPrint in LZW, line 147")
set el[Ec[N2u]]=c5u
call o5u(0,0,0,Ec[N2u],"when calling doStep in LZW, line 149",0,null)
set Ad=Ad-1
endif
endfunction
function ERw takes integer xRw,integer vRw,string mRw returns boolean
local boolean QRw
local boolean WRw
set Dd[Ad]=mRw
set Ad=Ad+1
set QRw=true
if MS[VS[xRw]]<hnu(NS[VS[xRw]],"when calling getLength in JsonParser, line 106") then
call QZu(VS[xRw],"when calling parseSeq in JsonParser, line 107")
else
set QRw=false
if wc[VS[xRw]]<MS[VS[xRw]]then
set cc[VS[xRw]]=gv(NS[VS[xRw]],wc[VS[xRw]],MS[VS[xRw]]-wc[VS[xRw]],"when calling new_BigSubString in JsonParser, line 111")
call JZu(tc[VS[xRw]],sTw(Sc[VS[xRw]],cc[VS[xRw]],"when calling new_Property in JsonParser, line 112"),"when calling addProperty in JsonParser, line 112")
endif
call o5u(0,0,0,BS[xRw],"when calling doStep in JsonParser, line 113",0,null)
endif
set WRw=QRw
set Ad=Ad-1
return WRw
endfunction
function aFu takes string eFu returns integer
local integer qFu
set Dd[Ad]=eFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set qFu=Cq
set Vq[qFu]=743
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set qFu=0
endif
else
set Xq=Xq-1
set qFu=Lq[Xq]
set Vq[qFu]=743
endif
set Ad=Ad-1
return qFu
endfunction
function fFu takes string nFu returns integer
local integer dFu
set Dd[Ad]=nFu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set dFu=ae
set ne[dFu]=670
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set dFu=0
endif
else
set qe=qe-1
set dFu=ee[qe]
set ne[dFu]=670
endif
set Ad=Ad-1
return dFu
endfunction
function pFu takes string bFu returns integer
local integer yFu
set Dd[Ad]=bFu
set Ad=Ad+1
if Xq==0 then
if Cq<32768 then
set Cq=Cq+1
set yFu=Cq
set Vq[yFu]=742
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set yFu=0
endif
else
set Xq=Xq-1
set yFu=Lq[Xq]
set Vq[yFu]=742
endif
set Ad=Ad-1
return yFu
endfunction
function K6 takes integer U6,integer I6,integer P6,string A6 returns nothing
local integer D6
local integer H6
local integer J6
set Dd[Ad]=A6
set Ad=Ad+1
call DEw("save1")
set D6=pFu("when calling alloc_Closure in Encoder, line 106")
set ms[D6]=U6
call xsw(D6,"when calling execute in Encoder, line 106")
call DEw("save2")
set wt[U6]=-1
set H6=aFu("when calling alloc_Closure in Encoder, line 109")
set Qs[H6]=U6
call xsw(H6,"when calling execute in Encoder, line 109")
set J6=fFu("when calling alloc_Closure in Encoder, line 112")
call VC(J6)
set As[J6]=U6
set Ds[J6]=I6
set Hs[J6]=P6
call kX(J6,"when calling nullTimer in Encoder, line 112")
set Ad=Ad-1
endfunction
function Jhu takes integer Phu,integer Ahu,integer Dhu,string Hhu returns nothing
set Dd[Ad]=Hhu
set Ad=Ad+1
if Aq[Phu]==0 then
if Phu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_save","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_save on invalid object.","when calling error in ")
endif
endif
call K6(Phu,Ahu,Dhu,"when calling save in Encoder, line 104")
set Ad=Ad-1
endfunction
function OHw takes integer oHw returns nothing
set el[oHw]=0
endfunction
function SIu takes integer sIu,string tIu returns integer
local integer iIu
set Dd[Ad]=tIu
set Ad=Ad+1
if on[sIu]==0 then
if sIu==0 then
call tsw("Nullpointer exception when calling LLIterator.LinkedList_LLIterator_next","when calling error in ")
else
call tsw("Called LLIterator.LinkedList_LLIterator_next on invalid object.","when calling error in ")
endif
endif
set iIu=qGw(sIu)
set Ad=Ad-1
return iIu
endfunction
function rIu takes integer MUu,string wIu returns boolean
local boolean uIu
set Dd[Ad]=wIu
set Ad=Ad+1
if on[MUu]==0 then
if MUu==0 then
call tsw("Nullpointer exception when calling LLIterator.LinkedList_LLIterator_hasNext","when calling error in ")
else
call tsw("Called LLIterator.LinkedList_LLIterator_hasNext on invalid object.","when calling error in ")
endif
endif
set uIu=nGw(MUu)
set Ad=Ad-1
return uIu
endfunction
function t3u takes integer w3u,integer u3u,string r3u,string s3u returns nothing
set Dd[Ad]=s3u
set Ad=Ad+1
if u3u<0 or u3u>=25 then
call tsw("Index out of Bounds","when calling error in ")
elseif u3u<=12 then
if u3u<=6 then
if u3u<=3 then
if u3u<=1 then
if u3u<=0 then
set od[w3u]=r3u
else
set Od[w3u]=r3u
endif
elseif u3u<=2 then
set ld[w3u]=r3u
else
set bd[w3u]=r3u
endif
elseif u3u<=5 then
if u3u<=4 then
set yd[w3u]=r3u
else
set pd[w3u]=r3u
endif
else
set ed[w3u]=r3u
endif
elseif u3u<=9 then
if u3u<=8 then
if u3u<=7 then
set qd[w3u]=r3u
else
set ad[w3u]=r3u
endif
else
set nd[w3u]=r3u
endif
elseif u3u<=11 then
if u3u<=10 then
set dd[w3u]=r3u
else
set fd[w3u]=r3u
endif
else
set Rd[w3u]=r3u
endif
elseif u3u<=18 then
if u3u<=15 then
if u3u<=14 then
if u3u<=13 then
set Td[w3u]=r3u
else
set Yd[w3u]=r3u
endif
else
set Gd[w3u]=r3u
endif
elseif u3u<=17 then
if u3u<=16 then
set gd[w3u]=r3u
else
set hd[w3u]=r3u
endif
else
set Fd[w3u]=r3u
endif
elseif u3u<=21 then
if u3u<=20 then
if u3u<=19 then
set kd[w3u]=r3u
else
set jd[w3u]=r3u
endif
else
set xd[w3u]=r3u
endif
elseif u3u<=23 then
if u3u<=22 then
set vd[w3u]=r3u
else
set md[w3u]=r3u
endif
else
set Qd[w3u]=r3u
endif
set Ad=Ad-1
endfunction
function Dx takes integer Ux,string Ix returns nothing
local integer Px
local integer Ax
set Dd[Ad]=Ix
set Ad=Ad+1
set Px=0
set Ax=ew-1
loop
exitwhen Px>Ax
call t3u(Ux,Px,"","when calling substrings in BigString, line 115")
set Px=Px+1
endloop
set qw[Ux]=0
set aw[Ux]=0
set Ad=Ad-1
endfunction
function Tnu takes integer fnu,string Rnu returns nothing
set Dd[Ad]=Rnu
set Ad=Ad+1
if xe[fnu]==0 then
if fnu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_reset","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_reset on invalid object.","when calling error in ")
endif
endif
call Dx(fnu,"when calling reset in BigString, line 113")
set Ad=Ad-1
endfunction
function cv takes integer iv,string Sv returns nothing
set Dd[Ad]=Sv
set Ad=Ad+1
set qw[iv]=0
set aw[iv]=0
call Tnu(iv,"when calling reset in BigString, line 107")
set Ad=Ad-1
endfunction
function wdu takes string Nnu returns integer
local integer Mnu
set Dd[Ad]=Nnu
set Ad=Ad+1
if ke==0 then
if je<32768 then
set je=je+1
set Mnu=je
set xe[Mnu]=634
else
call tsw("Out of memory: Could not create BigString.","when calling error in ")
set Mnu=0
endif
else
set ke=ke-1
set Mnu=Fe[ke]
set xe[Mnu]=634
endif
set Ad=Ad-1
return Mnu
endfunction
function tv takes string rv returns integer
local integer sv
set Dd[Ad]=rv
set Ad=Ad+1
set sv=wdu("when calling BigString in BigString, line 106")
call cv(sv,"when calling construct_BigString in BigString, line 106")
set Ad=Ad-1
return sv
endfunction
function wUu takes string NZu returns integer
local integer MZu
set Dd[Ad]=NZu
set Ad=Ad+1
if Nq==0 then
if Mq<32768 then
set Mq=Mq+1
set MZu=Mq
set wa[MZu]=806
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set MZu=0
endif
else
set Nq=Nq-1
set MZu=Bq[Nq]
set wa[MZu]=806
endif
set Ad=Ad-1
return MZu
endfunction
function QTw takes integer gTw,integer hTw,string FTw returns boolean
local boolean kTw
local integer jTw
local boolean xTw
local integer vTw
local integer mTw
set Dd[Ad]=FTw
set Ad=Ad+1
set kTw=true
if rIu(Tc[gTw],"when calling hasNext in LZW, line 45") then
call phu(Yc[gTw],SIu(Tc[gTw],"when calling next in LZW, line 46"),Gc[gTw],"when calling encode in LZW, line 46")
else
set kTw=false
call phu(Yc[gTw],Gc[gTw],qc,"when calling encode in LZW, line 49")
call xIu(gc[gTw],"when calling LinkedList in LZW, line 50")
set vTw=Yc[gTw]
set mTw=tv("when calling new_BigString in LZW, line 51")
set jTw=wUu("when calling alloc_Closure in LZW, line 51")
call OHw(jTw)
set fc[jTw]=hc[gTw]
set Rc[jTw]=Yc[gTw]
call Jhu(vTw,mTw,jTw,"when calling save in LZW, line 51")
endif
set xTw=kTw
set Ad=Ad-1
return xTw
endfunction
function jRw takes integer GRw,string gRw returns nothing
local string hRw
local integer FRw
local integer kRw
set Dd[Ad]=gRw
set Ad=Ad+1
set sc[GRw]=Xnu(NS[GRw],MS[GRw],1,"when calling getString in JsonParser, line 74")
set hRw=sc[GRw]
if hRw==KO[Oc]then
set uc[GRw]=uc[GRw]+1
if uc[GRw]==1 then
set wc[GRw]=MS[GRw]+1
endif
elseif hRw==KO[lc]then
set uc[GRw]=uc[GRw]-1
if uc[GRw]==0 then
set FRw=gv(NS[GRw],wc[GRw],MS[GRw]-wc[GRw],"when calling new_BigSubString in JsonParser, line 83")
call j3u(ic[GRw],FRw,"when calling add in JsonParser, line 84")
set wc[GRw]=MS[GRw]+1
endif
elseif hRw==KO[oc]then
if uc[GRw]==1 then
set kRw=gv(NS[GRw],wc[GRw],MS[GRw]-wc[GRw],"when calling new_BigSubString in JsonParser, line 88")
call j3u(ic[GRw],kRw,"when calling add in JsonParser, line 89")
set wc[GRw]=MS[GRw]+1
endif
endif
set MS[GRw]=MS[GRw]+1
set Ad=Ad-1
endfunction
function xZu takes integer kZu,string jZu returns nothing
set Dd[Ad]=jZu
set Ad=Ad+1
if La[kZu]==0 then
if kZu==0 then
call tsw("Nullpointer exception when calling JsonParser.JsonParser_JsonParser_parseListSeq","when calling error in ")
else
call tsw("Called JsonParser.JsonParser_JsonParser_parseListSeq on invalid object.","when calling error in ")
endif
endif
call jRw(kZu,"when calling parseListSeq in JsonParser, line 73")
set Ad=Ad-1
endfunction
function YRw takes integer nRw,integer dRw,string fRw returns boolean
local boolean RRw
local boolean TRw
set Dd[Ad]=fRw
set Ad=Ad+1
set RRw=true
if MS[XS[nRw]]<hnu(NS[XS[nRw]],"when calling getLength in JsonParser, line 64") then
call xZu(XS[nRw],"when calling parseListSeq in JsonParser, line 65")
else
set RRw=false
call DEw("parsed list")
call o5u(0,0,0,CS[nRw],"when calling doStep in JsonParser, line 69",0,null)
endif
set TRw=RRw
set Ad=Ad-1
return TRw
endfunction
function v6 takes integer h6,string F6 returns integer
local integer k6=0
local string j6=Vs[h6]
local integer x6=Bs[h6]
loop
exitwhen not(k6<x6 and F6!=SubString(j6,k6,k6+1))
set k6=k6+1
endloop
return k6
endfunction
function Vhu takes integer Khu,string Lhu,string Xhu returns integer
local integer Chu
set Dd[Ad]=Xhu
set Ad=Ad+1
if Aq[Khu]==0 then
if Khu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_chartoi","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_chartoi on invalid object.","when calling error in ")
endif
endif
set Chu=v6(Khu,Lhu)
set Ad=Ad-1
return Chu
endfunction
function Ov takes integer ov returns nothing
set qw[ov]=-1
endfunction
function sdu takes integer udu,string rdu returns nothing
set Dd[Ad]=rdu
set Ad=Ad+1
if xe[udu]==0 then
call tsw("Double free: object of type BigString","when calling error in ")
else
set Fe[ke]=udu
set ke=ke+1
set xe[udu]=0
endif
set Ad=Ad-1
endfunction
function yv takes integer lv,string bv returns nothing
set Dd[Ad]=bv
set Ad=Ad+1
call Ov(lv)
call sdu(lv,"when calling BigString in BigString, line 194")
set Ad=Ad-1
endfunction
function dnu takes integer anu,string nnu returns nothing
set Dd[Ad]=nnu
set Ad=Ad+1
if xe[anu]==0 then
if anu==0 then
call tsw("Nullpointer exception when calling BigString.destroyBigString","when calling error in ")
else
call tsw("Called BigString.destroyBigString on invalid object.","when calling error in ")
endif
endif
call yv(anu,"when calling destroyBigString in BigString, line 101")
set Ad=Ad-1
endfunction
function g6 takes integer f6,integer R6,string T6 returns boolean
local boolean Y6
local boolean G6
set Dd[Ad]=T6
set Ad=Ad+1
set Y6=true
set lw[Fs[f6]]=Vhu(ks[f6],Xnu(js[f6],xs[f6],1,"when calling getString in Encoder, line 80"),"when calling chartoi in Encoder, line 80")
if xs[f6]<hnu(js[f6],"when calling getLength in Encoder, line 81")-1 then
set bw[Fs[f6]]=tx("when calling new_BigNum_l in Encoder, line 82")
set Fs[f6]=bw[Fs[f6]]
set xs[f6]=xs[f6]+1
else
set Y6=false
call dnu(js[f6],"when calling BigString in Encoder, line 87")
call o5u(0,0,0,vs[f6],"when calling doStep in Encoder, line 88",0,null)
endif
set G6=Y6
set Ad=Ad-1
return G6
endfunction
function lMw takes string oMw,integer OMw returns string
return SubString(oMw,OMw,uMw(oMw))
endfunction
function gx takes integer fx,string Rx,string Tx returns nothing
local integer Yx
local integer Gx
set Dd[Ad]=Tx
set Ad=Ad+1
if uMw(Rx)>pw then
call tsw("adding too long string","when calling error in BigString, line 142")
endif
set Yx=bUw(hnu(fx,"when calling getLength in BigString, line 143")*1./pw)
if uMw(O3u(fx,Yx,"when calling substrings in BigString, line 144"))+uMw(Rx)>pw then
set Gx=pw-uMw(O3u(fx,Yx,"when calling substrings in BigString, line 145"))
call t3u(fx,Yx,O3u(fx,Yx,"when calling substrings in BigString, line 146")+iMw(Rx,0,Gx),"when calling substrings in BigString, line 146")
set Yx=Yx+1
call t3u(fx,Yx,O3u(fx,Yx,"when calling substrings in BigString, line 148")+lMw(Rx,Gx),"when calling substrings in BigString, line 148")
else
call t3u(fx,Yx,O3u(fx,Yx,"when calling substrings in BigString, line 150")+Rx,"when calling substrings in BigString, line 150")
endif
set qw[fx]=qw[fx]+uMw(Rx)
set Ad=Ad-1
endfunction
function Enu takes integer mnu,string Qnu,string Wnu returns nothing
set Dd[Ad]=Wnu
set Ad=Ad+1
if xe[mnu]==0 then
if mnu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_addString","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_addString on invalid object.","when calling error in ")
endif
endif
call gx(mnu,Qnu,"when calling addString in BigString, line 140")
set Ad=Ad-1
endfunction
function Dqw takes hashtable Iqw,integer Pqw,integer Aqw returns string
return LoadStr(Iqw,Pqw,Aqw)
endfunction
function a3w takes integer e3w,integer q3w returns string
return Dqw(Bb,e3w,q3w)
endfunction
function VXu takes integer KXu,integer LXu,string XXu returns string
local string CXu
set Dd[Ad]=XXu
set Ad=Ad+1
if Za[KXu]==0 then
if KXu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_loadString","when calling error in ")
else
call tsw("Called Table.Table_Table_loadString on invalid object.","when calling error in ")
endif
endif
set CXu=a3w(KXu,LXu)
set Ad=Ad-1
return CXu
endfunction
function KGw takes integer DGw,string HGw returns integer
local integer JGw
set Dd[Ad]=HGw
set Ad=Ad+1
set JGw=0
if rIu(DGw,"when calling hasNext in LinkedList, line 419") then
set JGw=Bc[Mc[uo[DGw]]]
endif
set Ad=Ad-1
return JGw
endfunction
function lIu takes integer cIu,string oIu returns integer
local integer OIu
set Dd[Ad]=oIu
set Ad=Ad+1
if on[cIu]==0 then
if cIu==0 then
call tsw("Nullpointer exception when calling LLIterator.LinkedList_LLIterator_lookahead","when calling error in ")
else
call tsw("Called LLIterator.LinkedList_LLIterator_lookahead on invalid object.","when calling error in ")
endif
endif
set OIu=KGw(cIu,"when calling lookahead in LinkedList, line 417")
set Ad=Ad-1
return OIu
endfunction
function pMw takes string bMw,integer yMw returns string
return SubString(bMw,yMw,yMw+1)
endfunction
function yTw takes string lTw,string bTw returns nothing
set Dd[Ad]=bTw
set Ad=Ad+1
call YEu(nc,J0u(lTw,"when calling stringToIndex in LZW, line 20"),dc,"when calling put in LZW, line 20")
call uCu(nc,dc,lTw,"when calling saveString in LZW, line 21")
set dc=dc+1
set Ad=Ad-1
endfunction
function jYw takes integer YYw,integer GYw,string gYw returns boolean
local boolean hYw
local integer FYw
local boolean kYw
set Dd[Ad]=gYw
set Ad=Ad+1
set hYw=true
if rIu(Hc[YYw],"when calling hasNext in LZW, line 170") then
set FYw=SIu(Hc[YYw],"when calling next in LZW, line 171")
set Kc[YYw]=VXu(nc,FYw,"when calling loadString in LZW, line 172")
if rIu(Hc[YYw],"when calling hasNext in LZW, line 173") and lIu(Hc[YYw],"when calling lookahead in LZW, line 173")<dc then
set Jc[YYw]=VXu(nc,lIu(Hc[YYw],"when calling lookahead in LZW, line 174"),"when calling loadString in LZW, line 174")
set Jc[YYw]=pMw(Jc[YYw],0)
elseif not rIu(Hc[YYw],"when calling hasNext in LZW, line 176") then
set Jc[YYw]=null
else
set Jc[YYw]=pMw(Kc[YYw],0)
endif
if Jc[YYw]!=null and uMw(Jc[YYw])>0 then
call yTw(Kc[YYw]+Jc[YYw],"when calling putDict in LZW, line 181")
endif
call Enu(Lc[YYw],Kc[YYw],"when calling addString in LZW, line 183")
else
set hYw=false
call DEw("decompressed")
call Bnu(Lc[YYw],"when calling debugPrint in LZW, line 187")
set el[Xc[YYw]]=Lc[YYw]
call o5u(0,0,0,Xc[YYw],"when calling doStep in LZW, line 189",0,null)
endif
set kYw=hYw
set Ad=Ad-1
return kYw
endfunction
function d6 takes integer a6,integer n6 returns string
return SubString(Vs[a6],n6,n6+1)
endfunction
function uFu takes integer Bhu,integer Nhu,string Mhu returns string
local string wFu
set Dd[Ad]=Mhu
set Ad=Ad+1
if Aq[Bhu]==0 then
if Bhu==0 then
call tsw("Nullpointer exception when calling Encoder.Encoder_Encoder_itochar","when calling error in ")
else
call tsw("Called Encoder.Encoder_Encoder_itochar on invalid object.","when calling error in ")
endif
endif
set wFu=d6(Bhu,Nhu)
set Ad=Ad-1
return wFu
endfunction
function q6 takes integer l6,integer b6,string y6 returns boolean
local boolean p6
local boolean e6
set Dd[Ad]=y6
set Ad=Ad+1
set p6=true
if Ys[l6]!=0 then
call Enu(Gs[l6],uFu(gs[l6],lw[Ys[l6]],"when calling itochar in Encoder, line 65"),"when calling addString in Encoder, line 65")
set Ys[l6]=bw[Ys[l6]]
else
set p6=false
set el[hs[l6]]=Gs[l6]
call o5u(0,0,0,hs[l6],"when calling doStep in Encoder, line 70",0,null)
endif
set e6=p6
set Ad=Ad-1
return e6
endfunction
function Shw takes integer rhw,integer shw,string thw returns nothing
local integer ihw
set Dd[Ad]=thw
set Ad=Ad+1
set ihw=sGw(shw,co[rhw],Mc[co[rhw]],"when calling new_LLEntry in LinkedList, line 164")
set Nc[Mc[co[rhw]]]=ihw
set Mc[co[rhw]]=ihw
set oo[rhw]=oo[rhw]+1
set Ad=Ad-1
endfunction
function bPu takes integer oPu,integer OPu,string lPu returns nothing
set Dd[Ad]=lPu
set Ad=Ad+1
if yn[oPu]==0 then
if oPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_addtoStart","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_addtoStart on invalid object.","when calling error in ")
endif
endif
call Shw(oPu,OPu,"when calling addtoStart in LinkedList, line 163")
set Ad=Ad-1
endfunction
function uj takes integer Mk returns boolean
local integer wj=ow[Mk]
loop
exitwhen not(wj!=0)
if lw[wj]!=0 then
return false
endif
set wj=bw[wj]
endloop
return true
endfunction
function hau takes integer Yau,string Gau returns boolean
local boolean gau
set Dd[Ad]=Gau
set Ad=Ad+1
if Te[Yau]==0 then
if Yau==0 then
call tsw("Nullpointer exception when calling BigNum.BigNum_BigNum_isZero","when calling error in ")
else
call tsw("Called BigNum.BigNum_BigNum_isZero on invalid object.","when calling error in ")
endif
endif
set gau=uj(Yau)
set Ad=Ad-1
return gau
endfunction
function rYw takes integer LTw,integer XTw,string CTw returns boolean
local boolean VTw
local integer BTw
local string NTw
local integer MTw
local integer wYw
local boolean uYw
set Dd[Ad]=CTw
set Ad=Ad+1
set VTw=true
if not hau(Ms[Fc[LTw]],"when calling isZero in LZW, line 74") then
set BTw=dhu(Fc[LTw],kc[LTw],"when calling decode in LZW, line 75")
call bPu(jc[LTw],BTw,"when calling addtoStart in LZW, line 76")
else
set VTw=false
if TO==0 then
set NTw=""
set MTw=lgw(jc[LTw],"when calling iterator in LZW, line 81")
loop
exitwhen not nGw(MTw)
set wYw=qGw(MTw)
set NTw=NTw+bfw(wYw)+","
endloop
call RGw(MTw,"when calling close in LZW, line 81")
call kEw(0,"decoded positions: "+NTw)
endif
set el[xc[LTw]]=jc[LTw]
call o5u(0,0,0,xc[LTw],"when calling doStep in LZW, line 85",0,null)
endif
set uYw=VTw
set Ad=Ad-1
return uYw
endfunction
function av takes integer qv returns integer
if dw[qv]!=0 and dw[qv]!=qv then
return Rw[qv]+av(dw[qv])
endif
return Rw[qv]
endfunction
function edu takes integer bdu,string ydu returns integer
local integer pdu
set Dd[Ad]=ydu
set Ad=Ad+1
if We[bdu]==0 then
if bdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_getCombinedLength","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_getCombinedLength on invalid object.","when calling error in ")
endif
endif
set pdu=av(bdu)
set Ad=Ad-1
return pdu
endfunction
function Qv takes integer xv,string vv returns string
local string mv
set Dd[Ad]=vv
set Ad=Ad+1
if edu(xv,"when calling getCombinedLength in BigString, line 52")>pw then
call tsw("cannot use getCombined on oversized SubStrings. You need to iterate through the chunks","when calling error in BigString, line 53")
endif
if nw[xv]==0 and Tw[xv]==null then
call tsw("cannot generate new cache without parent","when calling error in BigString, line 55")
endif
set mv=""
if Tw[xv]!=null then
set mv=mv+Tw[xv]
else
set mv=mv+Anu(nw[xv],xv,"when calling getSubStringData in BigString, line 60")
endif
if dw[xv]!=0 then
set mv=mv+Qv(dw[xv],"when calling getCombined in BigString, line 62")
endif
set Ad=Ad-1
return mv
endfunction
function Fdu takes integer Gdu,string gdu returns string
local string hdu
set Dd[Ad]=gdu
set Ad=Ad+1
if We[Gdu]==0 then
if Gdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_getCombined","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_getCombined on invalid object.","when calling error in ")
endif
endif
set hdu=Qv(Gdu,"when calling getCombined in BigString, line 51")
set Ad=Ad-1
return hdu
endfunction
function BZu takes string CZu returns integer
local integer VZu
set Dd[Ad]=CZu
set Ad=Ad+1
if Hq==0 then
if Jq<32768 then
set Jq=Jq+1
set VZu=Jq
set Kq[VZu]=819
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set VZu=0
endif
else
set Hq=Hq-1
set VZu=Dq[Hq]
set Kq[VZu]=819
endif
set Ad=Ad-1
return VZu
endfunction
function Lau takes string Jau returns integer
local integer Kau
set Dd[Ad]=Jau
set Ad=Ad+1
if fe==0 then
if Re<32768 then
set Re=Re+1
set Kau=Re
set Te[Kau]=632
else
call tsw("Out of memory: Could not create BigNum.","when calling error in ")
set Kau=0
endif
else
set fe=fe-1
set Kau=de[fe]
set Te[Kau]=632
endif
set Ad=Ad-1
return Kau
endfunction
function mj takes integer xj,integer vj returns nothing
set ow[xj]=0
set Ow[xj]=vj
endfunction
function jj takes integer hj,string Fj returns integer
local integer kj
set Dd[Ad]=Fj
set Ad=Ad+1
set kj=Lau("when calling BigNum in BigNum, line 67")
call mj(kj,hj)
set Ad=Ad-1
return kj
endfunction
function E7 takes integer m7,string Q7,string W7 returns nothing
set Dd[Ad]=W7
set Ad=Ad+1
set Ns[m7]=0.
set wt[m7]=-1
set ut[m7]=-1
set rt[m7]=-1
set Vs[m7]=Q7
set Bs[m7]=uMw(Q7)
set Ms[m7]=jj(Bs[m7],"when calling new_BigNum in Encoder, line 20")
set Ad=Ad-1
endfunction
function tFu takes string rFu returns integer
local integer sFu
set Dd[Ad]=rFu
set Ad=Ad+1
if Iq==0 then
if Pq<32768 then
set Pq=Pq+1
set sFu=Pq
set Aq[sFu]=716
else
call tsw("Out of memory: Could not create Encoder.","when calling error in ")
set sFu=0
endif
else
set Iq=Iq-1
set sFu=Uq[Iq]
set Aq[sFu]=716
endif
set Ad=Ad-1
return sFu
endfunction
function v7 takes string k7,string j7 returns integer
local integer x7
set Dd[Ad]=j7
set Ad=Ad+1
set x7=tFu("when calling Encoder in Encoder, line 17")
call E7(x7,k7,"when calling construct_Encoder in Encoder, line 17")
set Ad=Ad-1
return x7
endfunction
function GTw takes integer pTw,integer eTw,integer qTw,string aTw returns nothing
local string nTw
local integer dTw
local integer fTw
local integer RTw
local integer TTw
local integer YTw
set Dd[Ad]=aTw
set Ad=Ad+1
if eTw>qc then
call tsw("dictionary size exceeds max size","when calling error in LZW, line 32")
endif
if TO==0 then
set nTw=""
set dTw=lgw(pTw,"when calling iterator in LZW, line 36")
loop
exitwhen not nGw(dTw)
set fTw=qGw(dTw)
set nTw=nTw+bfw(fTw)+","
endloop
call RGw(dTw,"when calling close in LZW, line 36")
call kEw(0,"encoding positions: "+nTw)
endif
set RTw=v7(ac,"when calling new_Encoder in LZW, line 40")
set TTw=cPu(pTw,"when calling staticItr in LZW, line 42")
set YTw=BZu("when calling alloc_Closure in LZW, line 43")
call FHw(YTw)
set Tc[YTw]=TTw
set Yc[YTw]=RTw
set Gc[YTw]=eTw
set gc[YTw]=pTw
set hc[YTw]=qTw
call MDw(YTw,"when calling doSeq in LZW, line 43")
set Ad=Ad-1
endfunction
function Lv takes integer Jv,string Kv returns nothing
set nw[Jv]=0
set dw[Jv]=0
set fw[Jv]=0
set Rw[Jv]=0
set Tw[Jv]=null
set Tw[Jv]=Kv
set Rw[Jv]=uMw(Tw[Jv])
endfunction
function Hv takes string Pv,string Av returns integer
local integer Dv
set Dd[Ad]=Av
set Ad=Ad+1
set Dv=Edu("when calling BigSubString in BigString, line 14")
call Lv(Dv,Pv)
set Ad=Ad-1
return Dv
endfunction
function OUu takes string cUu returns integer
local integer oUu
set Dd[Ad]=cUu
set Ad=Ad+1
if Nq==0 then
if Mq<32768 then
set Mq=Mq+1
set oUu=Mq
set wa[oUu]=808
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set oUu=0
endif
else
set Nq=Nq-1
set oUu=Bq[Nq]
set wa[oUu]=808
endif
set Ad=Ad-1
return oUu
endfunction
function Idu takes integer Zdu,string Udu returns nothing
set Dd[Ad]=Udu
set Ad=Ad+1
if We[Zdu]==0 then
call tsw("Double free: object of type BigSubString","when calling error in ")
else
set ve[me]=Zdu
set me=me+1
set We[Zdu]=0
endif
set Ad=Ad-1
endfunction
function wm takes integer Mv returns nothing
set Rw[Mv]=-1
endfunction
function sm takes integer um,string rm returns nothing
set Dd[Ad]=rm
set Ad=Ad+1
call wm(um)
call Idu(um,"when calling BigSubString in BigString, line 98")
set Ad=Ad-1
endfunction
function Sdu takes integer tdu,string idu returns nothing
set Dd[Ad]=idu
set Ad=Ad+1
if We[tdu]==0 then
if tdu==0 then
call tsw("Nullpointer exception when calling BigSubString.destroyBigSubString","when calling error in ")
else
call tsw("Called BigSubString.destroyBigSubString on invalid object.","when calling error in ")
endif
endif
call sm(tdu,"when calling destroyBigSubString in BigString, line 7")
set Ad=Ad-1
endfunction
function Iv takes integer Wv,integer Ev,string Zv returns integer
local integer Uv
set Dd[Ad]=Zv
set Ad=Ad+1
if Ev==0 then
call tsw("null","when calling error in BigString, line 68")
endif
set Uv=Wv
loop
exitwhen not(dw[Uv]!=0)
set Uv=dw[Uv]
endloop
set dw[Uv]=Ev
set Ad=Ad-1
return Wv
endfunction
function mdu takes integer kdu,integer jdu,string xdu returns integer
local integer vdu
set Dd[Ad]=xdu
set Ad=Ad+1
if We[kdu]==0 then
if kdu==0 then
call tsw("Nullpointer exception when calling BigSubString.BigString_BigSubString_concat","when calling error in ")
else
call tsw("Called BigSubString.BigString_BigSubString_concat on invalid object.","when calling error in ")
endif
endif
set vdu=Iv(kdu,jdu,"when calling concat in BigString, line 66")
set Ad=Ad-1
return vdu
endfunction
function Vx takes integer Kx,integer Lx,string Xx returns integer
local integer Cx
set Dd[Ad]=Xx
set Ad=Ad+1
set Cx=gv(Kx,Lx,1,"when calling new_BigSubString in BigString, line 138")
set Ad=Ad-1
return Cx
endfunction
function vnu takes integer Fnu,integer knu,string jnu returns integer
local integer xnu
set Dd[Ad]=jnu
set Ad=Ad+1
if xe[Fnu]==0 then
if Fnu==0 then
call tsw("Nullpointer exception when calling BigString.BigString_BigString_charAt","when calling error in ")
else
call tsw("Called BigString.BigString_BigString_charAt on invalid object.","when calling error in ")
endif
endif
set xnu=Vx(Fnu,knu,"when calling charAt in BigString, line 137")
set Ad=Ad-1
return xnu
endfunction
function yYw takes integer sYw,integer tYw,string iYw returns boolean
local boolean SYw
local string cYw
local integer oYw
local boolean OYw
local integer lYw
local integer bYw
set Dd[Ad]=iYw
set Ad=Ad+1
set SYw=true
if Zc[sYw]<hnu(Uc[sYw],"when calling getLength in LZW, line 108")-1 then
if Ic[sYw]!=0 then
call Sdu(Ic[sYw],"when calling BigSubString in LZW, line 110")
endif
set Ic[sYw]=vnu(Uc[sYw],Zc[sYw],"when calling charAt in LZW, line 111")
set Zc[sYw]=Zc[sYw]+1
if Pc[sYw]!=0 then
call Sdu(Pc[sYw],"when calling BigSubString in LZW, line 114")
endif
set Pc[sYw]=vnu(Uc[sYw],Zc[sYw],"when calling charAt in LZW, line 115")
call mdu(Ic[sYw],Pc[sYw],"when calling concat in LZW, line 116")
loop
exitwhen not true
if not nEu(nc,J0u(Fdu(Ic[sYw],"when calling getCombined in LZW, line 118"),"when calling stringToIndex in LZW, line 118"),"when calling has in LZW, line 118") then
exitwhen true
endif
set cYw=Ydu(Ic[sYw],"when calling getSingle in LZW, line 120")
if Ic[sYw]!=0 then
call Sdu(Ic[sYw],"when calling BigSubString in LZW, line 122")
endif
set Ic[sYw]=Hv(cYw+Ydu(Pc[sYw],"when calling getSingle in LZW, line 123"),"when calling new_BigSubString in LZW, line 123")
set Zc[sYw]=Zc[sYw]+1
if Zc[sYw]<hnu(Uc[sYw],"when calling getLength in LZW, line 125") then
if Pc[sYw]!=0 then
call Sdu(Pc[sYw],"when calling BigSubString in LZW, line 127")
endif
set Pc[sYw]=vnu(Uc[sYw],Zc[sYw],"when calling charAt in LZW, line 128")
call mdu(Ic[sYw],Pc[sYw],"when calling concat in LZW, line 129")
else
exitwhen true
endif
endloop
call j3u(Ac[sYw],kEu(nc,J0u(Ydu(Ic[sYw],"when calling getSingle in LZW, line 134"),"when calling stringToIndex in LZW, line 134"),"when calling get in LZW, line 134"),"when calling add in LZW, line 134")
call yTw(Fdu(Ic[sYw],"when calling getCombined in LZW, line 136"),"when calling putDict in LZW, line 136")
else
call DEw("Compressed")
set SYw=false
if Pc[sYw]!=0 and pMw(Ydu(Ic[sYw],"when calling getSingle in LZW, line 142"),ldu(Ic[sYw],"when calling getSingleLength in LZW, line 142")-1)!=Ydu(Pc[sYw],"when calling getSingle in LZW, line 142") then
call j3u(Ac[sYw],kEu(nc,J0u(Ydu(Pc[sYw],"when calling getSingle in LZW, line 143"),"when calling stringToIndex in LZW, line 143"),"when calling get in LZW, line 143"),"when calling add in LZW, line 143")
endif
set lYw=Ac[sYw]
set bYw=dc
set oYw=OUu("when calling alloc_Closure in LZW, line 144")
call OHw(oYw)
set Ec[oYw]=Dc[sYw]
call GTw(lYw,bYw,oYw,"when calling encodePositions in LZW, line 144")
endif
set OYw=SYw
set Ad=Ad-1
return OYw
endfunction
function EJu takes integer vJu,integer mJu,string QJu returns boolean
local boolean WJu
set Dd[Ad]=QJu
set Ad=Ad+1
if Kq[vJu]==0 then
if vJu==0 then
call tsw("Nullpointer exception when calling SeqCallback.SeqWorker_SeqCallback_onExecute","when calling error in ")
else
call tsw("Called SeqCallback.SeqWorker_SeqCallback_onExecute on invalid object.","when calling error in ")
endif
endif
if Kq[vJu]<=818 then
if Kq[vJu]<=816 then
if Kq[vJu]<=815 then
set WJu=q6(vJu,mJu,"when calling Encoder_closure_impl in SeqWorker, line 49")
else
set WJu=g6(vJu,mJu,"when calling Encoder_closure_impl in SeqWorker, line 49")
endif
elseif Kq[vJu]<=817 then
set WJu=YRw(vJu,mJu,"when calling JsonParser_closure_impl in SeqWorker, line 49")
else
set WJu=ERw(vJu,mJu,"when calling JsonParser_closure_impl in SeqWorker, line 49")
endif
elseif Kq[vJu]<=820 then
if Kq[vJu]<=819 then
set WJu=QTw(vJu,mJu,"when calling LZW_closure_impl in SeqWorker, line 49")
else
set WJu=rYw(vJu,mJu,"when calling LZW_closure_impl in SeqWorker, line 49")
endif
elseif Kq[vJu]<=821 then
set WJu=yYw(vJu,mJu,"when calling LZW_closure_impl in SeqWorker, line 49")
else
set WJu=jYw(vJu,mJu,"when calling LZW_closure_impl in SeqWorker, line 49")
endif
set Ad=Ad-1
return WJu
endfunction
function dHw takes integer qHw,string aHw returns boolean
local boolean nHw
set Dd[Ad]=aHw
set Ad=Ad+1
if not ql[qHw]then
set nHw=EJu(qHw,qHw,"when calling onExecute in SeqWorker, line 46")
set Ad=Ad-1
return nHw
endif
set Ad=Ad-1
return false
endfunction
function xJu takes integer FJu,string kJu returns boolean
local boolean jJu
set Dd[Ad]=kJu
set Ad=Ad+1
if Kq[FJu]==0 then
if FJu==0 then
call tsw("Nullpointer exception when calling SeqCallback.SeqWorker_SeqCallback_doStep","when calling error in ")
else
call tsw("Called SeqCallback.SeqWorker_SeqCallback_doStep on invalid object.","when calling error in ")
endif
endif
set jJu=dHw(FJu,"when calling doStep in SeqWorker, line 44")
set Ad=Ad-1
return jJu
endfunction
function iHw takes string rHw returns nothing
local timer sHw
local integer tHw
set Dd[Ad]=rHw
set Ad=Ad+1
set sHw=GetExpiredTimer()
set tHw=c2w(sHw,"when calling getData in SeqWorker, line 17")
if (not ql[tHw])and al[tHw]!=null then
if xJu(tHw,"when calling doStep in SeqWorker, line 19") then
call j2w(sHw,0.001,eg)
else
call hJu(tHw,"when calling terminate in SeqWorker, line 22")
endif
endif
set Ad=Ad-1
set sHw=null
endfunction
function uHw takes string wHw returns nothing
set Dd[Ad]=wHw
set Ad=Ad+1
call iHw("when calling onSeq in SeqWorker, line 13")
set Ad=Ad-1
endfunction
function d4u takes nothing returns nothing
set Ad=0
call uHw("SeqWorker, line 13")
endfunction
function dNw takes nothing returns boolean
set Pb=40.
return true
endfunction
function rWw takes player MQw,integer wWw,boolean uWw returns nothing
call SetPlayerAbilityAvailable(MQw,wWw,uWw)
endfunction
function vAu takes string jAu returns integer
local integer xAu
set Dd[Ad]=jAu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set xAu=ae
set ne[xAu]=681
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set xAu=0
endif
else
set qe=qe-1
set xAu=ee[qe]
set ne[xAu]=681
endif
set Ad=Ad-1
return xAu
endfunction
function bxw takes string cxw returns boolean
local integer oxw
local integer Oxw
local integer lxw
set Dd[Ad]=cxw
set Ad=Ad+1
set Ao=CreateTrigger()
set Do=CreateGroup()
set Jo=0
set Ko=1095577649
set oxw=0
set Oxw=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen oxw>Oxw
call rWw(OO[oxw],Ko,false)
set oxw=oxw+1
endloop
set lxw=vAu("when calling alloc_Closure in OnUnitEnterLeave, line 60")
call VC(lxw)
call kX(lxw,"when calling nullTimer in OnUnitEnterLeave, line 60")
set Ad=Ad-1
return true
endfunction
function e1u takes nothing returns boolean
set Ad=0
return bxw("OnUnitEnterLeave, line 1")
endfunction
function YWu takes string RWu returns integer
local integer TWu
set Dd[Ad]=RWu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set TWu=ae
set ne[TWu]=675
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set TWu=0
endif
else
set qe=qe-1
set TWu=ee[qe]
set ne[TWu]=675
endif
set Ad=Ad-1
return TWu
endfunction
function Tgw takes integer agw,integer ngw returns integer
local integer dgw=co[agw]
local integer fgw=0
local integer Rgw=ngw
loop
exitwhen fgw>Rgw
set dgw=Mc[dgw]
set fgw=fgw+1
endloop
return dgw
endfunction
function MPu takes integer CPu,integer VPu,string BPu returns integer
local integer NPu
set Dd[Ad]=BPu
set Ad=Ad+1
if yn[CPu]==0 then
if CPu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_getEntry","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_getEntry on invalid object.","when calling error in ")
endif
endif
set NPu=Tgw(CPu,VPu)
set Ad=Ad-1
return NPu
endfunction
function qgw takes integer bgw,integer ygw,string pgw returns integer
local integer egw
set Dd[Ad]=pgw
set Ad=Ad+1
set egw=Bc[MPu(bgw,ygw,"when calling getEntry in LinkedList, line 47")]
set Ad=Ad-1
return egw
endfunction
function EIu takes integer vIu,integer mIu,string QIu returns integer
local integer WIu
set Dd[Ad]=QIu
set Ad=Ad+1
if yn[vIu]==0 then
if vIu==0 then
call tsw("Nullpointer exception when calling LinkedList.LinkedList_LinkedList_get","when calling error in ")
else
call tsw("Called LinkedList.LinkedList_LinkedList_get on invalid object.","when calling error in ")
endif
endif
set WIu=qgw(vIu,mIu,"when calling get in LinkedList, line 46")
set Ad=Ad-1
return WIu
endfunction
function hru takes string Gru returns nothing
local timer gru
set Dd[Ad]=Gru
set Ad=Ad+1
set gru=CreateTimer()
if sPu(Mo,"when calling size in UnitSpawnSystem, line 141")<=1 and mQw(rO[EIu(Mo,0,"when calling get in UnitSpawnSystem, line 141")])=="WorldEdit" or mQw(rO[EIu(Mo,0,"when calling get in UnitSpawnSystem, line 141")])=="Frotty" then
call gEw("|cffFFCC00>>|r Fast Spawn")
call Q2w(gru,ip/2.5,hg)
else
call Q2w(gru,ip,Fg)
endif
call vEw("|cffFFCC00>>|r Enemies spawn in "+bfw(bUw(ip))+" seconds.",25.)
set Ad=Ad-1
set gru=null
endfunction
function nyw takes string pyw returns nothing
local integer eyw
local integer qyw
local integer ayw
set Dd[Ad]=pyw
set Ad=Ad+1
set eyw=VJw("Sound\\Dialogue\\HumanCampaign\\Human03\\H03Priest21.mp3",false,"when calling new_SoundDefinition in GameInit, line 43")
set qyw=VJw("Units\\Orc\\Peon\\PeonYesAttack1.wav",false,"when calling new_SoundDefinition in GameInit, line 44")
call xKu(eyw,"when calling play in GameInit, line 45")
call hru("when calling startSpawn in GameInit, line 46")
call e2w(GetExpiredTimer(),"when calling release in GameInit, line 47")
set ayw=YWu("when calling alloc_Closure in GameInit, line 48")
call VC(ayw)
set Vi[ayw]=qyw
call gX(7.75,ayw,"when calling doAfter in GameInit, line 48")
set Ad=Ad-1
endfunction
function e4u takes nothing returns nothing
set Ad=0
call nyw("GameInit, line 33")
endfunction
function eEw takes nothing returns boolean
set RO=45.
return true
endfunction
function eh takes nothing returns nothing
call CameraSetupApplyForPlayer(true,a,Player(0),0.)
endfunction
function lVu takes string oVu returns integer
local integer OVu
set Dd[Ad]=oVu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set OVu=Le
set Xe[OVu]=732
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set OVu=0
endif
else
set Ke=Ke-1
set OVu=Je[Ke]
set Xe[OVu]=732
endif
set Ad=Ad-1
return OVu
endfunction
function tVu takes string rVu returns integer
local integer sVu
set Dd[Ad]=rVu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set sVu=Le
set Xe[sVu]=731
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set sVu=0
endif
else
set Ke=Ke-1
set sVu=Je[Ke]
set Xe[sVu]=731
endif
set Ad=Ad-1
return sVu
endfunction
function uVu takes string MCu returns integer
local integer wVu
set Dd[Ad]=MCu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set wVu=Le
set Xe[wVu]=730
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set wVu=0
endif
else
set Ke=Ke-1
set wVu=Je[Ke]
set Xe[wVu]=730
endif
set Ad=Ad-1
return wVu
endfunction
function D2w takes string W2w returns boolean
local integer E2w
local integer Z2w
local integer U2w
local playerunitevent I2w
local playerunitevent P2w
local unitevent A2w
set Dd[Ad]=W2w
set Ad=Ad+1
set jy=1747988531
set xy=1747988528
set vy=1747989048
set I2w=EVENT_PLAYER_UNIT_CONSTRUCT_START
set E2w=uVu("when calling alloc_Closure in Tower, line 68")
call cL(E2w)
call pK(I2w,E2w,"when calling add in Tower, line 68")
set P2w=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set Z2w=tVu("when calling alloc_Closure in Tower, line 76")
call cL(Z2w)
call pK(P2w,Z2w,"when calling add in Tower, line 76")
set A2w=EVENT_UNIT_DAMAGED
set U2w=lVu("when calling alloc_Closure in Tower, line 84")
call cL(U2w)
call pK(A2w,U2w,"when calling add in Tower, line 84")
set Ad=Ad-1
set I2w=null
set P2w=null
set A2w=null
return true
endfunction
function f1u takes nothing returns boolean
set Ad=0
return D2w("Tower, line 1")
endfunction
function cHw takes string SHw returns nothing
set Dd[Ad]=SHw
set Ad=Ad+1
call iHw("when calling onSeq in SeqWorker, line 20")
set Ad=Ad-1
endfunction
function f4u takes nothing returns nothing
set Ad=0
call cHw("SeqWorker, line 20")
endfunction
function fA takes nothing returns boolean
return true
endfunction
function CP takes string LP returns integer
local integer XP
set Dd[Ad]=LP
set Ad=Ad+1
set XP=oA(true,"when calling new_Iterator in LinkedListModule, line 53")
set Ad=Ad-1
return XP
endfunction
function U0w takes string Z0w returns boolean
set Dd[Ad]=Z0w
set Ad=Ad+1
set Yt=Uuw("when calling iterator in EntityManagement, line 4")
set Gt=CP("when calling iterator in EntityManagement, line 5")
set Ad=Ad-1
return true
endfunction
function g1u takes nothing returns boolean
set Ad=0
return U0w("EntityManagement, line 1")
endfunction
function X4w takes string K4w returns nothing
local integer L4w
set Dd[Ad]=K4w
set Ad=Ad+1
set L4w=c2w(GetExpiredTimer(),"when calling getData in ThermoTower, line 30")
call e2w(GetExpiredTimer(),"when calling release in ThermoTower, line 31")
call eiu(Nt[L4w],by)
set Ad=Ad-1
endfunction
function g4u takes nothing returns nothing
set Ad=0
call X4w("ThermoTower, line 26")
endfunction
function gh takes nothing returns boolean
set X=0.017453293
set C=57.295779513
return true
endfunction
function dmu takes string amu returns integer
local integer nmu
set Dd[Ad]=amu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set nmu=tq
set iq[nmu]=754
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set nmu=0
endif
else
set sq=sq-1
set nmu=rq[sq]
set iq[nmu]=754
endif
set Ad=Ad-1
return nmu
endfunction
function ccw takes string ucw returns boolean
local integer rcw
local real scw
local real tcw
local real icw
local real Scw
set Dd[Ad]=ucw
set Ad=Ad+1
set icw=pp
set Scw=ep
set scw=icw
set tcw=Scw
set rcw=dmu("when calling alloc_Closure in FieldGenerator, line 42")
call aX(scw,tcw,128.,rcw,"when calling forUnitsInRange in FieldGenerator, line 42")
set Ad=Ad-1
return true
endfunction
function h1u takes nothing returns boolean
set Ad=0
return ccw("FieldGenerator, line 1")
endfunction
function q0u takes string b0u returns nothing
local integer y0u
local integer p0u
local integer e0u
set Dd[Ad]=b0u
set Ad=Ad+1
set y0u=sww(GetTriggerUnit())
set p0u=lgw(Xy[y0u],"when calling iterator in TrooperTower, line 60")
loop
exitwhen not nGw(p0u)
set e0u=qGw(p0u)
call gB(Nt[e0u],Ku,Lu,Xu,Cu)
call Siu(Nt[e0u])
endloop
call RGw(p0u,"when calling close in TrooperTower, line 60")
set Ad=Ad-1
endfunction
function h4u takes nothing returns nothing
set Ad=0
call q0u("TrooperTower, line 103")
endfunction
function initTypecastData takes string stackPos returns nothing
set Dd[Ad]=stackPos
set Ad=Ad+1
call uCu(By,0,"","when calling saveString in TypeCasting, line 11")
set Ad=Ad-1
endfunction
function E0u takes string W0u returns boolean
set Dd[Ad]=W0u
set Ad=Ad+1
set By=v3w("when calling new_Table in TypeCasting, line 6")
set Ny=1000.
call initTypecastData("when calling initTypecastData in TypeCasting, line 14")
set Ad=Ad-1
return true
endfunction
function i1u takes nothing returns boolean
set Ad=0
return E0u("TypeCasting, line 1")
endfunction
function mfw takes real kfw,real jfw,real xfw,real vfw returns real
return kfw+2.*(jfw-kfw)*vfw+(xfw-2.*jfw+kfw)*vfw*vfw
endfunction
function Ffw takes real afw,real nfw,real dfw,real ffw,real Rfw,real Tfw,real Yfw,real Gfw,real gfw,real hfw returns real
set JR=mfw(afw,ffw,Yfw,hfw)
set KR=mfw(nfw,Rfw,Gfw,hfw)
set LR=mfw(dfw,Tfw,gfw,hfw)
return JR
endfunction
function BAw takes integer mAw,string QAw returns nothing
local integer WAw
local integer EAw
local integer ZAw
local integer UAw
local integer IAw
local integer PAw
local real AAw
local real DAw
local real HAw
local real JAw
local real KAw
local real LAw
local integer XAw
local unit CAw
local texttag VAw
set Dd[Ad]=QAw
set Ad=Ad+1
if ll[mAw]>0.990 then
call sxu(mAw,"when calling deactivate in Selector, line 69")
set Ad=Ad-1
set CAw=null
set VAw=null
return
endif
set ll[mAw]=nUw(ll[mAw],1.,0.025)
set WAw=mAw
set XAw=WAw
set EAw=mAw
set AAw=ht[EAw]
set DAw=Ft[EAw]
set HAw=kt[EAw]
set ZAw=mAw
set JAw=cl[ZAw]
set KAw=ol[ZAw]
set LAw=Ol[ZAw]
set UAw=mAw
set ht[XAw]=Ffw(AAw,DAw,HAw,JAw,KAw,LAw,tl[UAw],il[UAw],Sl[UAw],ll[mAw])
set Ft[WAw]=KR
set kt[WAw]=LR
set CAw=Nt[mAw]
set IAw=mAw
call kSu(CAw,EOu(ht[IAw],Ft[IAw],kt[IAw]),Ef)
set VAw=pi[sl[mAw]]
set PAw=mAw
call J1w(VAw,Qou(ht[PAw],Ft[PAw],kt[PAw],20.,25.,0.),UR,IR)
call NQw(Et[mAw],Nt[mAw])
set Ad=Ad-1
set CAw=null
set VAw=null
endfunction
function SOw takes integer uOw,string rOw returns nothing
local integer sOw
local integer tOw
local integer iOw
set Dd[Ad]=rOw
set Ad=Ad+1
set sOw=uOw
if pkw(ht[sOw],Ft[sOw],kt[sOw]) then
call wuw(uOw,"when calling update in FxEntity, line 29")
set iOw=Wi[uOw]
set tOw=uOw
call HQu(iOw,ht[tOw],Ft[tOw],kt[tOw],"when calling setXYZ in FxEntity, line 30")
else
call J2u(0,0,0,0,0,0,uOw,"when calling terminate in FxEntity, line 32",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endfunction
function cZw takes integer BEw,string NEw returns nothing
local integer MEw
local integer wZw
local integer uZw
local integer rZw
local integer sZw
local real tZw
local real iZw
local real SZw
set Dd[Ad]=NEw
set Ad=Ad+1
set MEw=BEw
set sZw=MEw
set wZw=BEw
set jt[sZw]=Kou(jt[wZw],xt[wZw],vt[wZw],xO[BEw])
set xt[MEw]=Lf
set vt[MEw]=Xf
call SOw(BEw,"when calling update in Projectile, line 57")
if (not Ut[BEw])and FO[BEw]then
set mO[BEw]=mO[BEw]+sw
if mO[BEw]>=QO[BEw]then
call J2u(0,0,0,0,0,0,BEw,"when calling terminate in Projectile, line 61",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
endif
if (not Ut[BEw])and kO[BEw]then
set uZw=BEw
set tZw=GO[uZw]
set iZw=gO[uZw]
set SZw=hO[uZw]
set rZw=BEw
if slu(tZw,iZw,SZw,ht[rZw],Ft[rZw],kt[rZw])>vO[BEw]then
call J2u(0,0,0,0,0,0,BEw,"when calling terminate in Projectile, line 64",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
endif
set Ad=Ad-1
endfunction
function H5w takes integer A5w,string D5w returns nothing
set Dd[Ad]=D5w
set Ad=Ad+1
call cZw(A5w,"when calling update in TowerBlockade, line 26")
set Ad=Ad-1
endfunction
function akw takes real ekw,real qkw returns boolean
return ekw>jo and ekw<vo and qkw>xo and qkw<mo
endfunction
function Rkw takes real nkw,real dkw,real fkw returns boolean
return akw(nkw,dkw)
endfunction
function onw takes integer snw,string tnw returns nothing
local integer inw
local integer Snw
local string cnw
set Dd[Ad]=tnw
set Ad=Ad+1
if hS[snw]!=0 and xtu(Nt[hS[snw]]) then
set cnw=RS
set inw=hS[snw]
call d5(cnw,Mou(ht[inw],Ft[inw],kt[inw],0.,0.,50.),yR,pR)
call ysu(Nt[hS[snw]],gS[snw])
set Snw=snw
call f1w(ht[Snw],Ft[Snw],kt[Snw],GetRandomReal(-1.,1.),0.,GetRandomReal(7.,9.),bfw(bUw(gS[snw])),8.,.75,223,255,52,255,"when calling new_TextTagEntity in HealbackTower, line 126")
endif
set Ad=Ad-1
endfunction
function wZu takes integer NEu,string MEu returns nothing
set Dd[Ad]=MEu
set Ad=Ad+1
if Oe[NEu]==0 then
if NEu==0 then
call tsw("Nullpointer exception when calling HealbackMissile.HealbackTower_HealbackMissile_onReachTarget","when calling error in ")
else
call tsw("Called HealbackMissile.HealbackTower_HealbackMissile_onReachTarget on invalid object.","when calling error in ")
endif
endif
call onw(NEu,"when calling onReachTarget in HealbackTower, line 122")
set Ad=Ad-1
endfunction
function Haw takes integer Waw,string Eaw returns nothing
local integer Zaw
local integer Uaw
local integer Iaw
local real Paw
local real Aaw
local real Daw
set Dd[Ad]=Eaw
set Ad=Ad+1
call cZw(Waw,"when calling update in HealbackTower, line 115")
set Zaw=Waw
if not Rkw(ht[Zaw],Ft[Zaw],kt[Zaw]) then
call J2u(0,0,0,0,0,0,Waw,"when calling terminate in HealbackTower, line 117",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Uaw=Waw
set Paw=FS[Uaw]
set Aaw=kS[Uaw]
set Daw=jS[Uaw]
set Iaw=Waw
if slu(Paw,Aaw,Daw,ht[Iaw],Ft[Iaw],kt[Iaw])>xS[Waw]then
call wZu(Waw,"when calling onReachTarget in HealbackTower, line 119")
call J2u(0,0,0,0,0,0,Waw,"when calling terminate in HealbackTower, line 120",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endfunction
function A3w takes real U3w,real I3w,pathingtype P3w returns boolean
return IsTerrainPathable(U3w,I3w,P3w)
endfunction
function Bfw takes item Vfw returns real
return GetItemY(Vfw)
endfunction
function Cfw takes item Xfw returns real
return GetItemX(Xfw)
endfunction
function Mfw takes item Nfw returns real
set XR=Cfw(Nfw)
set CR=Bfw(Nfw)
return XR
endfunction
function mUw takes rect jUw,real xUw,real vUw returns nothing
call MoveRectTo(jUw,xUw,vUw)
endfunction
function sRw takes item wRw,real uRw,real rRw returns nothing
call SetItemPosition(wRw,uRw,rRw)
endfunction
function C3w takes real D3w,real H3w returns boolean
local real J3w
local real K3w
local real L3w
local real X3w
call mUw(uy,D3w,H3w)
call EnumItemsInRect(uy,null,fg)
call sRw(wy,D3w,H3w)
set L3w=Mfw(wy)
set X3w=CR
set J3w=L3w
set K3w=X3w
call SRw(wy,false)
loop
exitwhen not(sy>0)
set sy=sy-1
call SRw(ry[sy],true)
set ry[sy]=null
endloop
return (J3w-D3w)*(J3w-D3w)+(K3w-H3w)*(K3w-H3w)<=Nb and(not A3w(D3w,H3w,PATHING_TYPE_WALKABILITY))
endfunction
function Pcu takes real Ecu,real Zcu,real Ucu returns real
local real Icu=SquareRoot(Ecu*Ecu+Zcu*Zcu)
if Icu==0.0 then
set Gf=0.
set gf=0.
return Gf
endif
set Icu=Ucu/Icu
set Gf=Ecu*Icu
set gf=Zcu*Icu
return Gf
endfunction
function iN takes real UB,real IB returns real
local integer PB=8
local real AB=64.
local real BB=0.
local real NB=0.
local real DB=BB
local real HB=NB
local integer JB=1
local integer KB=PB
local real LB
local real XB
local real CB
local real VB
local real MB
local real wN
local real uN
local real rN
local real sN
local real tN
loop
exitwhen JB>KB
set MB=wou(0.,0.,Uh(JB*2*bj_PI/PB),AB)
set wN=Cd
set LB=MB
set XB=wN
set uN=lcu(UB,IB,LB,XB)
set rN=Ld
set CB=uN
set VB=rN
if C3w(CB,VB) then
set sN=lcu(DB,HB,LB,XB)
set tN=Ld
set DB=sN
set HB=tN
endif
set JB=JB+1
endloop
set SR=ecu(Pcu(DB,HB,1.),gf,-1.)
set cR=Ff
return SR
endfunction
function SOu takes real wOu,real uOu,real rOu,real sOu,real tOu,real iOu returns real
return wOu*sOu+uOu*tOu+rOu*iOu
endfunction
function vOu takes real GOu,real gOu,real hOu,real FOu,real kOu,real jOu returns real
local real xOu=YOu(FOu,kOu,jOu)
if xOu==0.0 then
set vf=0.
set mf=0.
set Qf=0.
return vf
endif
set xOu=SOu(GOu,gOu,hOu,FOu,kOu,jOu)/xOu
set vf=FOu*xOu
set mf=kOu*xOu
set Qf=jOu*xOu
return vf
endfunction
function xN takes real SN,real cN,real oN,real ON,real lN returns real
local real fN=Ycu(ON,lN)
local real RN=jf
local real TN=xf
local real bN=fN
local real yN=RN
local real pN=TN
local real YN=vOu(SN,cN,oN,bN,yN,pN)
local real GN=mf
local real gN=Qf
local real eN=YN
local real qN=GN
local real aN=gN
local real hN=EOu(eN,qN,aN)
local real FN=Ef
local real nN=hN
local real dN=FN
local real kN=ecu(nN,dN,-1.25)
local real jN=Ff
set nN=kN
set dN=jN
set oR=hou(SN,cN,oN,nN,dN)
set OR=Uf
set lR=If
return oR
endfunction
function LN takes integer vN,string mN returns nothing
local real QN
local real WN
local integer EN
local integer ZN
local integer UN
local integer IN
local real PN
local real AN
local integer DN
local integer HN
local integer JN
local integer KN
set Dd[Ad]=mN
set Ad=Ad+1
set EN=vN
if C3w(EOu(ht[EN],Ft[EN],kt[EN]),Ef) then
set ZN=vN
set JN=ZN
set UN=vN
set jt[JN]=Kou(jt[UN],xt[UN],vt[UN],0.975)
set xt[ZN]=Lf
set vt[ZN]=Xf
else
set IN=vN
set PN=iN(EOu(ht[IN],Ft[IN],kt[IN]),Ef)
set AN=cR
set QN=PN
set WN=AN
set DN=vN
set KN=DN
set HN=vN
set jt[KN]=xN(jt[HN],xt[HN],vt[HN],QN,WN)
set xt[DN]=OR
set vt[DN]=lR
endif
call Qrw(vN,"when calling update in Creep, line 95")
set Ad=Ad-1
endfunction
function Xww takes integer Kww returns real
local integer Lww=Kww
set oT=jt[Lww]
set OT=xt[Lww]
set lT=vt[Lww]
return oT
endfunction
function gju takes integer aju,string nju returns real
local real dju
local real fju
local real Rju
local real Tju
local real Yju
local real Gju
set Dd[Ad]=nju
set Ad=Ad+1
if Oe[aju]==0 then
if aju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_getVel","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_getVel on invalid object.","when calling error in ")
endif
endif
set Tju=Xww(aju)
set Yju=OT
set Gju=lT
set dju=Tju
set fju=Yju
set Rju=Gju
set Ad=Ad-1
set MR=dju
set wT=fju
set uT=Rju
return MR
endfunction
function vNu takes string jNu returns integer
local integer xNu
set Dd[Ad]=jNu
set Ad=Ad+1
if sq==0 then
if tq<32768 then
set tq=tq+1
set xNu=tq
set iq[xNu]=759
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set xNu=0
endif
else
set sq=sq-1
set xNu=rq[sq]
set iq[xNu]=759
endif
set Ad=Ad-1
return xNu
endfunction
function Mbu takes integer Hbu,string Jbu returns nothing
local integer Kbu
local real Lbu
local real Xbu
local real Cbu
local integer Vbu
local real Bbu
local real Nbu
set Dd[Ad]=Jbu
set Ad=Ad+1
call cZw(Hbu,"when calling update in WaveTower, line 49")
if YOu(gju(Hbu,"when calling getVel in WaveTower, line 51"),wT,uT)<16. then
call J2u(0,0,0,0,0,0,Hbu,"when calling terminate in WaveTower, line 52",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
return
endif
set Vbu=Hbu
set Bbu=EOu(ht[Vbu],Ft[Vbu],kt[Vbu])
set Nbu=Ef
set Lbu=Bbu
set Xbu=Nbu
set Cbu=xp
set Kbu=vNu("when calling alloc_Closure in WaveTower, line 55")
set vp[Kbu]=Hbu
call aX(Lbu,Xbu,Cbu,Kbu,"when calling forUnitsInRange in WaveTower, line 55")
set Ad=Ad-1
endfunction
function Gcw takes unit Ycw returns boolean
return (not IsUnitType(Ycw,UNIT_TYPE_DEAD))and(not IsUnitType(Ycw,UNIT_TYPE_MAGIC_IMMUNE)) and(not IsUnitType(Ycw,UNIT_TYPE_STRUCTURE)) and(not IsUnitType(Ycw,UNIT_TYPE_FLYING))
endfunction
function fcw takes integer dcw returns real
return 9.+5.75*dcw
endfunction
function Ucw takes integer gcw,string hcw returns nothing
local unit Fcw
local group kcw
local integer jcw
local real xcw
local real vcw
local integer mcw
local real Qcw
local real Wcw
local group Ecw
local real Zcw
set Dd[Ad]=hcw
set Ad=Ad+1
set Ecw=OS
set jcw=gcw
set vcw=ht[jcw]
set xcw=vcw
set Zcw=xcw
set mcw=gcw
set Wcw=Ft[mcw]
set Qcw=Wcw
call GroupEnumUnitsInRange(Ecw,Zcw,Qcw,hi,null)
set kcw=OS
loop
exitwhen not Jpw(kcw)
set Fcw=Bpw(kcw)
if IsUnitEnemy(Fcw,Et[gcw]) and Gcw(Fcw) then
call msu(Jmu(gcw,"when calling getDummy in FlamethrowerTower, line 50"),Fcw,fcw(ki[gcw]),ATTACK_TYPE_SIEGE)
endif
endloop
call cZw(gcw,"when calling update in FlamethrowerTower, line 51")
set Ad=Ad-1
set Fcw=null
set kcw=null
set Ecw=null
endfunction
function W8 takes integer v8,string m8 returns nothing
local real Q8
set Dd[Ad]=m8
set Ad=Ad+1
call LN(v8,"when calling update in EndBoss, line 35")
set Q8=Lsu(Nt[v8])/St
if qt[v8]==1 and Q8<ot then
set qt[v8]=2
endif
if qt[v8]==2 and Q8<Ot then
set qt[v8]=3
endif
set Ad=Ad-1
endfunction
function Lpw takes group Kpw returns group
set lS=CreateGroup()
call ForGroup(Kpw,Sg)
return lS
endfunction
function Mpw takes group Npw returns nothing
call Zpw(Npw)
call Ipw(Npw)
endfunction
function RNw takes unit fNw returns boolean
return (not IsUnitType(fNw,UNIT_TYPE_DEAD))and(not IsUnitType(fNw,UNIT_TYPE_MAGIC_IMMUNE)) and(not IsUnitType(fNw,UNIT_TYPE_STRUCTURE))
endfunction
function WNw takes integer TNw,string YNw returns nothing
local group GNw
local unit gNw
local integer hNw
local real FNw
local real kNw
local integer jNw
local real xNw
local real vNw
local group mNw
local real QNw
set Dd[Ad]=YNw
set Ad=Ad+1
call cZw(TNw,"when calling update in SphereTower, line 64")
set mNw=OS
set hNw=TNw
set kNw=ht[hNw]
set FNw=kNw
set QNw=FNw
set jNw=TNw
set vNw=Ft[jNw]
set xNw=vNw
call GroupEnumUnitsInRange(mNw,QNw,xNw,Pb,null)
set GNw=Lpw(OS)
loop
exitwhen not Jpw(GNw)
set gNw=Bpw(GNw)
if RNw(gNw) and IsUnitEnemy(gNw,Et[TNw]) then
call UnitDamageTarget(Jmu(TNw,"when calling getDummy in SphereTower, line 68"),gNw,5.*Ab[TNw],false,false,ATTACK_TYPE_PIERCE,DAMAGE_TYPE_NORMAL,null)
endif
endloop
call Mpw(GNw)
call Zpw(OS)
set Ad=Ad-1
set GNw=null
set gNw=null
set mNw=null
endfunction
function Mvw takes integer Nvw returns nothing
endfunction
function AAu takes integer IAu,string PAu returns nothing
set Dd[Ad]=PAu
set Ad=Ad+1
if Oe[IAu]==0 then
if IAu==0 then
call tsw("Nullpointer exception when calling PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onGroundHit","when calling error in ")
else
call tsw("Called PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onGroundHit on invalid object.","when calling error in ")
endif
endif
call Mvw(IAu)
set Ad=Ad-1
endfunction
function cww takes integer rww,real sww_2 returns nothing
local integer tww=rww
local integer Sww_2=tww
local integer iww=rww
set jt[Sww_2]=Kou(jt[iww],xt[iww],vt[iww],sww_2)
set xt[tww]=Lf
set vt[tww]=Xf
endfunction
function Eju takes integer mju,real Qju,string Wju returns nothing
set Dd[Ad]=Wju
set Ad=Ad+1
if Oe[mju]==0 then
if mju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_scaleVel","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_scaleVel on invalid object.","when calling error in ")
endif
endif
call cww(mju,Qju)
set Ad=Ad-1
endfunction
function imw takes integer rmw,integer smw,string tmw returns nothing
set Dd[Ad]=tmw
set Ad=Ad+1
if Zt[smw]then
set Zt[smw]=false
call AAu(rmw,"when calling onGroundHit in PhysicsEntity, line 34")
endif
call Eju(smw,No[rmw],"when calling scaleVel in PhysicsEntity, line 36")
set Ad=Ad-1
endfunction
function MAu takes integer VAu,integer BAu,string NAu returns nothing
set Dd[Ad]=NAu
set Ad=Ad+1
if Oe[VAu]==0 then
if VAu==0 then
call tsw("Nullpointer exception when calling PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onGround","when calling error in ")
else
call tsw("Called PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onGround on invalid object.","when calling error in ")
endif
endif
call imw(VAu,BAu,"when calling onGround in PhysicsEntity, line 31")
set Ad=Ad-1
endfunction
function umw takes integer wmw returns nothing
endfunction
function JAu takes integer DAu,string HAu returns nothing
set Dd[Ad]=HAu
set Ad=Ad+1
if Oe[DAu]==0 then
if DAu==0 then
call tsw("Nullpointer exception when calling PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onEscapeGround","when calling error in ")
else
call tsw("Called PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_onEscapeGround on invalid object.","when calling error in ")
endif
endif
call umw(DAu)
set Ad=Ad-1
endfunction
function Omw takes integer Smw,integer cmw,string omw returns nothing
set Dd[Ad]=omw
set Ad=Ad+1
if not Zt[cmw]then
set Zt[cmw]=true
call JAu(Smw,"when calling onEscapeGround in PhysicsEntity, line 41")
endif
set Ad=Ad-1
endfunction
function sDu takes integer wDu,integer uDu,string rDu returns nothing
set Dd[Ad]=rDu
set Ad=Ad+1
if Oe[wDu]==0 then
if wDu==0 then
call tsw("Nullpointer exception when calling PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_inAir","when calling error in ")
else
call tsw("Called PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_inAir on invalid object.","when calling error in ")
endif
endif
call Omw(wDu,uDu,"when calling inAir in PhysicsEntity, line 38")
set Ad=Ad-1
endfunction
function Bvw takes integer Avw,integer Dvw,string Hvw returns nothing
local real Jvw
local real Kvw
local real Lvw
local real Xvw
local real Cvw
local real Vvw
set Dd[Ad]=Hvw
set Ad=Ad+1
set Xvw=Oju(Dvw,"when calling getPos in PhysicsEntity, line 22")
set Cvw=yf
set Vvw=pf
set Jvw=Xvw
set Kvw=Cvw
set Lvw=Vvw
if xi then
set Bo[Avw]=xcu(Jvw,Kvw,Lvw)
endif
if Lvw<=Bo[Avw]+.45 then
call MAu(Avw,Dvw,"when calling onGround in PhysicsEntity, line 26")
else
call sDu(Avw,Dvw,"when calling inAir in PhysicsEntity, line 28")
endif
set Ad=Ad-1
endfunction
function CAu takes integer KAu,integer LAu,string XAu returns nothing
set Dd[Ad]=XAu
set Ad=Ad+1
if Oe[KAu]==0 then
if KAu==0 then
call tsw("Nullpointer exception when calling PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_physicsUpdate","when calling error in ")
else
call tsw("Called PhysicsProjectile.PhysicsProjectile_PhysicsProjectile_PhysicsModule_physicsUpdate on invalid object.","when calling error in ")
endif
endif
call Bvw(KAu,LAu,"when calling physicsUpdate in PhysicsEntity, line 21")
set Ad=Ad-1
endfunction
function hkw takes real Ykw,real Gkw,real gkw returns real
return Atan2(Gkw-Ykw,gkw)
endfunction
function avw takes integer Kxw,string Lxw returns nothing
local integer Xxw
local integer Cxw
local integer Vxw
local integer Bxw
local real Nxw
local real Mxw
local integer wvw
local real uvw
local real rvw
local integer svw
local real tvw
local real ivw
local real Svw
local real cvw
local real ovw
local real Ovw
local real lvw
local real bvw
local integer yvw
local real pvw
local real evw
local integer qvw
set Dd[Ad]=Lxw
set Ad=Ad+1
call CAu(Kxw,Kxw,"when calling physicsUpdate in PhysicsProjectile, line 19")
set yvw=Kxw
set Xxw=Kxw
set Ovw=ht[Xxw]
set lvw=Ft[Xxw]
set bvw=kt[Xxw]
set Cxw=Kxw
set Svw=ht[Cxw]
set cvw=Ft[Cxw]
set ovw=kt[Cxw]
set Vxw=Kxw
call oHu(yvw,Ylu(Ovw,lvw,bvw,fou(Svw,cvw,ovw,jt[Vxw],xt[Vxw],vt[Vxw]),Of,lf),"when calling setXYAngle in PhysicsProjectile, line 20")
set qvw=Kxw
set Bxw=Kxw
set Mxw=kt[Bxw]
set Nxw=Mxw
set evw=Nxw
set wvw=Kxw
set rvw=kt[wvw]
set uvw=rvw
set pvw=uvw
set svw=Kxw
set ivw=vt[svw]
set tvw=ivw
call aHu(qvw,hkw(evw,pvw+tvw,2.),"when calling setZAngle in PhysicsProjectile, line 21")
call cZw(Kxw,"when calling update in PhysicsProjectile, line 22")
set Ad=Ad-1
endfunction
function Hcu takes real Acu,real Dcu returns real
return Acu*Acu+Dcu*Dcu
endfunction
function sTu takes string uTu returns integer
local integer rTu
set Dd[Ad]=uTu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set rTu=ae
set ne[rTu]=662
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set rTu=0
endif
else
set qe=qe-1
set rTu=ee[qe]
set ne[rTu]=662
endif
set Ad=Ad-1
return rTu
endfunction
function VA takes real RA,real TA,string YA returns real
local integer GA
local real gA
local real hA
local real FA
local integer kA
local integer jA
local real xA
local real vA
local real mA
local real QA
local effect WA
local integer EA
local real ZA
local real UA
local real IA
local real PA
local real AA
local real DA
local real HA
local real JA
local real KA
local real LA
local real XA
local real CA
set Dd[Ad]=YA
set Ad=Ad+1
set GA=9
set gA=32.
set IA=0.
set PA=0.
set hA=IA
set FA=PA
set kA=0
set jA=GA-1
loop
exitwhen kA>jA
set AA=wou(0.,0.,Uh(kA*2*bj_PI/GA),gA)
set DA=Cd
set xA=AA
set vA=DA
set HA=lcu(RA,TA,xA,vA)
set JA=Ld
set mA=HA
set QA=JA
set WA=m5(g,mA,QA)
set EA=sTu("when calling alloc_Closure in Builder, line 43")
call VC(EA)
set yu[EA]=WA
call gX(1.,EA,"when calling doAfter in Builder, line 43")
if C3w(mA,QA) then
set KA=lcu(hA,FA,xA,vA)
set LA=Ld
set hA=KA
set FA=LA
endif
set kA=kA+1
endloop
set XA=ecu(Pcu(hA,FA,1.),gf,-1.)
set CA=Ff
set ZA=XA
set UA=CA
set Ad=Ad-1
set Pf=ZA
set Af=UA
set WA=null
return Pf
endfunction
function YD takes real MA,real wD,real uD,real rD,real sD returns real
local real yD=Ycu(rD,sD)
local real pD=jf
local real eD=xf
local real tD=yD
local real iD=pD
local real SD=eD
local real qD=vOu(MA,wD,uD,tD,iD,SD)
local real aD=mf
local real nD=Qf
local real cD=qD
local real oD=aD
local real OD=nD
local real dD=EOu(cD,oD,OD)
local real fD=Ef
local real lD=dD
local real bD=fD
local real RD=ecu(lD,bD,-1.9)
local real TD=Ff
set lD=RD
set bD=TD
set Cf=hou(MA,wD,uD,lD,bD)
set Vf=Uf
set Bf=If
return Cf
endfunction
function dOu takes real qOu,real aOu,real nOu returns real
return SquareRoot(qOu*qOu+aOu*aOu+nOu*nOu)
endfunction
function eOu takes real cOu,real oOu,real OOu returns real
local real lOu=dOu(cOu,oOu,OOu)
local real bOu=0.
local real yOu=0.
local real pOu=0.
if lOu!=0.0 then
set bOu=cOu/lOu
set yOu=oOu/lOu
set pOu=OOu/lOu
endif
set Df=bOu
set Hf=yOu
set Jf=pOu
return Df
endfunction
function fcu takes real qcu,real acu,real ncu,real dcu returns real
return qcu*ncu+acu*dcu
endfunction
function cH takes integer GD,string gD returns nothing
local real hD
local real FD
local integer kD
local integer jD
local real xD
local real vD
local integer mD
local real QD
local real WD
local integer ED
local integer ZD
local integer UD
local integer ID
local integer PD
local integer AD
local integer DD
local integer HD
local integer JD
local integer KD
local integer LD
local integer XD
local real CD
local real VD
local real BD
local integer ND
local integer MD
local real wH
local real uH
local real rH
local real sH
local real tH
local real iH
local integer SH
set Dd[Ad]=gD
set Ad=Ad+1
call SOw(GD,"when calling update in Builder, line 63")
set kD=GD
if not C3w(EOu(ht[kD],Ft[kD],kt[kD]),Ef) then
set jD=GD
set xD=VA(EOu(ht[jD],Ft[jD],kt[jD]),Ef,"when calling getPathingNormal in Builder, line 65")
set vD=Af
set hD=xD
set FD=vD
if Hcu(hD,FD)==0. then
set mD=GD
set QD=EOu(Kou(eOu(jt[mD],xt[mD],vt[mD]),Hf,Jf,-1),Lf,Xf)
set WD=Ef
set hD=QD
set FD=WD
endif
set ED=GD
if fcu(EOu(eOu(jt[ED],xt[ED],vt[ED]),Hf,Jf),Ef,hD,FD)<0. then
set ZD=GD
call gEw("bounced "+pUw(fcu(EOu(eOu(jt[ZD],xt[ZD],vt[ZD]),Hf,Jf),Ef,hD,FD)))
set UD=GD
set XD=UD
set ID=GD
set jt[XD]=YD(jt[ID],xt[ID],vt[ID],hD,FD)
set xt[UD]=Vf
set vt[UD]=Bf
endif
endif
set PD=GD
set ND=PD
set AD=GD
set CD=ht[AD]
set VD=Ft[AD]
set BD=kt[AD]
set DD=GD
set ht[ND]=fou(CD,VD,BD,jt[DD],xt[DD],vt[DD])
set Ft[PD]=Of
set kt[PD]=lf
set MD=Wi[GD]
set HD=GD
call HQu(MD,ht[HD],Ft[HD],kt[HD],"when calling setXYZ in Builder, line 72")
set SH=Wi[GD]
set JD=GD
set sH=ht[JD]
set tH=Ft[JD]
set iH=kt[JD]
set KD=GD
set wH=ht[KD]
set uH=Ft[KD]
set rH=kt[KD]
set LD=GD
call mQu(SH,Ylu(sH,tH,iH,fou(wH,uH,rH,jt[LD],xt[LD],vt[LD]),Of,lf),"when calling setXYAngle in Builder, line 73")
set Ad=Ad-1
endfunction
function mPw takes integer FPw,string kPw returns nothing
local integer jPw
local real xPw
local real vPw
set Dd[Ad]=kPw
set Ad=Ad+1
call avw(FPw,"when calling update in Rocket, line 22")
set jPw=FPw
set vPw=vt[jPw]
set xPw=vPw
if xPw<=0. then
call J2u(0,0,0,0,0,0,FPw,"when calling terminate in Rocket, line 24",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endfunction
function NOw takes integer VOw returns integer
local integer BOw=VOw
set bT=Ii[BOw]
set yT=Pi[BOw]
set pT=Ai[BOw]
set eT=Di[BOw]
return bT
endfunction
function aQu takes integer SQu,string cQu returns integer
local integer oQu
local integer OQu
local integer lQu
local integer bQu
local integer yQu
local integer pQu
local integer eQu
local integer qQu
set Dd[Ad]=cQu
set Ad=Ad+1
if Fa[SQu]==0 then
if SQu==0 then
call tsw("Nullpointer exception when calling Fx.Fx_Fx_getColor","when calling error in ")
else
call tsw("Called Fx.Fx_Fx_getColor on invalid object.","when calling error in ")
endif
endif
set yQu=NOw(SQu)
set pQu=yT
set eQu=pT
set qQu=eT
set oQu=yQu
set OQu=pQu
set lQu=eQu
set bQu=qQu
set Ad=Ad-1
set PR=oQu
set AR=OQu
set DR=lQu
set HR=bQu
return PR
endfunction
function oAw takes integer NPw,string MPw returns nothing
local integer wAw
local integer uAw
local integer rAw
local integer sAw
local integer tAw
local integer iAw
local integer SAw
local integer cAw
set Dd[Ad]=MPw
set Ad=Ad+1
set tAw=aQu(Wi[NPw],"when calling getColor in Rocket, line 48")
set iAw=AR
set SAw=DR
set cAw=HR
set wAw=tAw
set uAw=iAw
set rAw=SAw
set sAw=cAw
set sAw=bUw(mfw(255.,200.,-5.,mO[NPw]/JO[NPw]))
call kQu(Wi[NPw],wAw,uAw,rAw,sAw,"when calling setColor in Rocket, line 50")
call avw(NPw,"when calling update in Rocket, line 51")
set Ad=Ad-1
endfunction
function rQ takes integer Nm,string Mm returns nothing
local integer wQ
local unit uQ
set Dd[Ad]=Mm
set Ad=Ad+1
call LN(Nm,"when calling update in BossFour, line 38")
set uQ=Nt[Nm]
set wQ=Nm
call KSu(uQ,ht[wQ],Ft[wQ],kt[wQ])
set Ad=Ad-1
set uQ=null
endfunction
function s1w takes integer B3w,string N3w returns nothing
local integer M3w
local integer w1w
local texttag u1w
local texttag r1w
set Dd[Ad]=N3w
set Ad=Ad+1
call wuw(B3w,"when calling update in TextTagEntity, line 19")
set u1w=pi[ty[B3w]]
set M3w=B3w
call J1w(u1w,ht[M3w],Ft[M3w],kt[M3w])
set r1w=pi[ty[B3w]]
set w1w=B3w
call s4w(r1w,Sy[w1w],cy[w1w],oy[w1w],Oy[w1w])
set iy[B3w]=iy[B3w]-sw
if iy[B3w]<=0. then
call J2u(0,0,0,0,0,0,B3w,"when calling terminate in TextTagEntity, line 24",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
set u1w=null
set r1w=null
endfunction
function sF takes integer Vh,string Bh returns nothing
local integer Nh
local real Mh
local real wF
local integer uF
local real rF
set Dd[Ad]=Bh
set Ad=Ad+1
set Nh=Vh
set wF=kt[Nh]
set Mh=wF
set rF=Mh
set uF=Vh
if rF<xcu(ht[uF],Ft[uF],kt[uF])+4. then
call J2u(0,0,0,0,0,0,Vh,"when calling terminate in ArtilleryTower, line 54",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
set Ad=Ad-1
return
endif
call cZw(Vh,"when calling update in ArtilleryTower, line 56")
set Ad=Ad-1
endfunction
function Bju takes integer Cju,string Vju returns nothing
set Dd[Ad]=Vju
set Ad=Ad+1
if Oe[Cju]==0 then
if Cju==0 then
call tsw("Nullpointer exception when calling Entity.Entity_Entity_update","when calling error in ")
else
call tsw("Called Entity.Entity_Entity_update on invalid object.","when calling error in ")
endif
endif
if Oe[Cju]<=835 then
if Oe[Cju]<=829 then
if Oe[Cju]<=826 then
if Oe[Cju]<=825 then
if Oe[Cju]<=824 then
call wuw(Cju,"when calling update in Entity, line 151")
else
call SOw(Cju,"when calling update in Entity, line 151")
endif
else
call cH(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=828 then
if Oe[Cju]<=827 then
call SOw(Cju,"when calling update in Entity, line 151")
else
call cZw(Cju,"when calling update in Entity, line 151")
endif
else
call sF(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=832 then
if Oe[Cju]<=831 then
if Oe[Cju]<=830 then
call Ucw(Cju,"when calling update in Entity, line 151")
else
call Haw(Cju,"when calling update in Entity, line 151")
endif
else
call avw(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=834 then
if Oe[Cju]<=833 then
call mPw(Cju,"when calling update in Entity, line 151")
else
call oAw(Cju,"when calling update in Entity, line 151")
endif
else
call WNw(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=845 then
if Oe[Cju]<=838 then
if Oe[Cju]<=837 then
if Oe[Cju]<=836 then
call H5w(Cju,"when calling update in Entity, line 151")
else
call Mbu(Cju,"when calling update in Entity, line 151")
endif
else
call s1w(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=844 then
if Oe[Cju]<=841 then
call Qrw(Cju,"when calling update in Entity, line 151")
else
call LN(Cju,"when calling update in Entity, line 151")
endif
else
call rQ(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=858 then
if Oe[Cju]<=849 then
if Oe[Cju]<=848 then
call LN(Cju,"when calling update in Entity, line 151")
else
call W8(Cju,"when calling update in Entity, line 151")
endif
else
call LN(Cju,"when calling update in Entity, line 151")
endif
elseif Oe[Cju]<=860 then
if Oe[Cju]<=859 then
call Qrw(Cju,"when calling update in Entity, line 151")
else
call BAw(Cju,"when calling update in Entity, line 151")
endif
else
call Qrw(Cju,"when calling update in Entity, line 151")
endif
set Ad=Ad-1
endfunction
function trw takes integer srw returns nothing
set Bt[srw]=At
endfunction
function vxu takes integer jxu,string xxu returns nothing
set Dd[Ad]=xxu
set Ad=Ad+1
if ba[jxu]==0 then
if jxu==0 then
call tsw("Nullpointer exception when calling Iterator.Entity_Entity_DupletListModule_Iterator_reset","when calling error in ")
else
call tsw("Called Iterator.Entity_Entity_DupletListModule_Iterator_reset on invalid object.","when calling error in ")
endif
endif
call trw(jxu)
set Ad=Ad-1
endfunction
function D0w takes string I0w returns nothing
local integer P0w
local integer A0w
set Dd[Ad]=I0w
set Ad=Ad+1
call vxu(Yt,"when calling reset in EntityManagement, line 8")
set A0w=Yt
loop
exitwhen not Luw(A0w)
set P0w=Vuw(A0w)
if not Ut[P0w]then
call Bju(P0w,"when calling update in EntityManagement, line 11")
endif
endloop
set Ad=Ad-1
endfunction
function i4u takes nothing returns nothing
set Ad=0
call D0w("EntityManagement, line 26")
endfunction
function icu takes nothing returns boolean
local real wcu=0.
local real ucu=0.
local real rcu
local real scu
local real tcu
set pp=wcu
set ep=ucu
set rcu=0.
set scu=0.
set tcu=0.
set qp=rcu
set ap=scu
set np=tcu
set dp=Location(0.,0.)
return true
endfunction
function ikw takes nothing returns boolean
set Ro=false
return true
endfunction
function emw takes string pmw returns boolean
set Dd[Ad]=pmw
set Ad=Ad+1
set Mo=Ngw("when calling new_LinkedList in PlayerData, line 9")
set Ad=Ad-1
return true
endfunction
function j1u takes nothing returns boolean
set Ad=0
return emw("PlayerData, line 1")
endfunction
function dSu takes unit aSu,integer nSu returns nothing
call SetUnitUserData(aSu,nSu)
endfunction
function K_u takes integer J_u returns nothing
set sp=tp[J_u]
call b8w(up)
call dSu(tp[J_u],0)
endfunction
function xBu takes integer kBu,string jBu returns nothing
set Dd[Ad]=jBu
set Ad=Ad+1
if Pn[kBu]==0 then
call tsw("Double free: object of type UnitIndex","when calling error in ")
else
set Zn[Un]=kBu
set Un=Un+1
set Pn[kBu]=0
endif
set Ad=Ad-1
endfunction
function P_u takes integer U_u,string I_u returns nothing
set Dd[Ad]=I_u
set Ad=Ad+1
call K_u(U_u)
call xBu(U_u,"when calling UnitIndex in UnitIndexer, line 172")
set Ad=Ad-1
endfunction
function GBu takes integer TBu,string YBu returns nothing
set Dd[Ad]=YBu
set Ad=Ad+1
if Pn[TBu]==0 then
if TBu==0 then
call tsw("Nullpointer exception when calling UnitIndex.destroyUnitIndex","when calling error in ")
else
call tsw("Called UnitIndex.destroyUnitIndex on invalid object.","when calling error in ")
endif
endif
call P_u(TBu,"when calling destroyUnitIndex in UnitIndexer, line 157")
set Ad=Ad-1
endfunction
function FBu takes string gBu returns integer
local integer hBu
set Dd[Ad]=gBu
set Ad=Ad+1
if Un==0 then
if In<32768 then
set In=In+1
set hBu=In
set Pn[hBu]=896
else
call tsw("Out of memory: Could not create UnitIndex.","when calling error in ")
set hBu=0
endif
else
set Un=Un-1
set hBu=Zn[Un]
set Pn[hBu]=896
endif
set Ad=Ad-1
return hBu
endfunction
function H_u takes integer A_u,unit D_u returns nothing
set tp[A_u]=D_u
call dSu(tp[A_u],A_u)
set rp=tp[A_u]
call b8w(wp)
endfunction
function Z_u takes unit Q_u,string W_u returns integer
local integer E_u
set Dd[Ad]=W_u
set Ad=Ad+1
set E_u=FBu("when calling UnitIndex in UnitIndexer, line 166")
call H_u(E_u,Q_u)
set Ad=Ad-1
return E_u
endfunction
function d_u takes unit q_u,string a_u returns integer
local integer n_u
set Dd[Ad]=a_u
set Ad=Ad+1
set n_u=Ytu(q_u)
if n_u==0 then
set n_u=Z_u(q_u,"when calling new_UnitIndex in UnitIndexer, line 125")
endif
set Ad=Ad-1
return n_u
endfunction
function k_u takes unit h_u,string F_u returns boolean
set Dd[Ad]=F_u
set Ad=Ad+1
if Ytu(h_u)==0 then
set Ad=Ad-1
return false
else
call GBu(d_u(h_u,"when calling toUnitIndex in UnitIndexer, line 154"),"when calling UnitIndex in UnitIndexer, line 154")
set Ad=Ad-1
return true
endif
endfunction
function qxw takes nothing returns unit
return Ho[Jo-1]
endfunction
function y_u takes unit b_u returns boolean
return true
endfunction
function m_u takes string v_u returns nothing
set Dd[Ad]=v_u
set Ad=Ad+1
if y_u(qxw()) then
call k_u(qxw(),"when calling deindex in UnitIndexer, line 180")
endif
set Ad=Ad-1
endfunction
function j4u takes nothing returns nothing
set Ad=0
call m_u("UnitIndexer, line 180")
endfunction
function jU takes nothing returns boolean
set Lw=0.024/0.0023
set Xw=.03
set Cw=3.
return true
endfunction
function X_u takes string L_u returns boolean
set Dd[Ad]=L_u
set Ad=Ad+1
set ip=20.0
set Sp=Ngw("when calling new_LinkedList in UnitSpawnSystem, line 17")
set cp=Ngw("when calling new_LinkedList in UnitSpawnSystem, line 18")
set op=Ngw("when calling new_LinkedList in UnitSpawnSystem, line 19")
set Op=b2w("when calling getTimer in UnitSpawnSystem, line 21")
set lp=false
set bp=1
set Ad=Ad-1
return true
endfunction
function k1u takes nothing returns boolean
set Ad=0
return X_u("UnitSpawnSystem, line 1")
endfunction
function x_u takes string j_u returns nothing
set Dd[Ad]=j_u
set Ad=Ad+1
if y_u(qxw()) then
call d_u(qxw(),"when calling toUnitIndex in UnitIndexer, line 179")
endif
set Ad=Ad-1
endfunction
function k4u takes nothing returns nothing
set Ad=0
call x_u("UnitIndexer, line 179")
endfunction
function U0u takes real Z0u returns integer
return bUw(Z0u*Ny)
endfunction
function dUu takes string aUu returns integer
local integer nUu
set Dd[Ad]=aUu
set Ad=Ad+1
if Ha==0 then
if Ja<32768 then
set Ja=Ja+1
set nUu=Ja
set Ka[nUu]=698
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set nUu=0
endif
else
set Ha=Ha-1
set nUu=Da[Ha]
set Ka[nUu]=698
endif
set Ad=Ad-1
return nUu
endfunction
function qUu takes string pUu returns integer
local integer eUu
set Dd[Ad]=pUu
set Ad=Ad+1
if Ha==0 then
if Ja<32768 then
set Ja=Ja+1
set eUu=Ja
set Ka[eUu]=697
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set eUu=0
endif
else
set Ha=Ha-1
set eUu=Da[Ha]
set Ka[eUu]=697
endif
set Ad=Ad-1
return eUu
endfunction
function mYw takes string vYw returns boolean
set Dd[Ad]=vYw
set Ad=Ad+1
call qUu("when calling alloc_Closure in LinkedList, line 479")
call dUu("when calling alloc_Closure in LinkedList, line 483")
call U0u(0.)
set Ad=Ad-1
return true
endfunction
function l1u takes nothing returns boolean
set Ad=0
return mYw("LinkedList, line 1")
endfunction
function g0w takes string a0w returns nothing
local integer n0w
local integer d0w
local integer f0w
local integer R0w
local integer T0w
local integer Y0w
local integer G0w
set Dd[Ad]=a0w
set Ad=Ad+1
call gEw("|cff666666Game over")
set n0w=Ht
loop
exitwhen not(n0w!=0)
set Y0w=Oe[n0w]
if Y0w>=839 and Y0w<=871 then
set d0w=n0w
call ySu(Nt[d0w],0.)
call Siu(Nt[d0w])
endif
set n0w=Ct[n0w]
endloop
set f0w=Uuw("when calling iterator in EndGame, line 15")
loop
exitwhen not Luw(f0w)
set R0w=Vuw(f0w)
set G0w=Oe[R0w]
if G0w>=839 and G0w<=871 then
set T0w=R0w
call ySu(Nt[T0w],0.)
call Siu(Nt[T0w])
endif
endloop
call Muw(f0w,"when calling close in EndGame, line 15")
set Tt=true
set Ad=Ad-1
endfunction
function l4u takes nothing returns nothing
set Ad=0
call g0w("GameConditions, line 15")
endfunction
function lFw takes nothing returns boolean
set bo=1
set yo=1227894854
set po=1227894856
set eo=0
set qo=18.
set ao=GetRandomInt(-2,3)
set no=16
set do=0
return true
endfunction
function fxw takes code dxw returns nothing
call r8w(Ao,dxw)
endfunction
function nxw takes code axw returns nothing
call i8w(Ao,Filter(axw))
endfunction
function l_u takes nothing returns boolean
set wp=CreateTrigger()
set up=CreateTrigger()
set rp=null
set sp=null
call nxw(Gg)
call fxw(gg)
return true
endfunction
function lh takes nothing returns nothing
call AddSpecialEffectLocBJ(GetRectCenter(GetPlayableMapRect()),"Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl")
call KillUnit(R)
call KillUnit(T)
endfunction
function initialize_2 takes string stackPos returns nothing
set Dd[Ad]=stackPos
set Ad=Ad+1
call tpw(uS,"when calling createGroups in GroupUtils, line 101")
set Ad=Ad-1
endfunction
function Xyw takes string Lyw returns boolean
set Dd[Ad]=Lyw
set Ad=Ad+1
set Mi=1024
set wS=64
set uS=64
set rS=wqw("when calling new_HashMap in GroupUtils, line 30")
set tS=0
set iS=0
set SS=false
call initialize_2("when calling initialize in GroupUtils, line 104")
set oS=false
set Ad=Ad-1
return true
endfunction
function m1u takes nothing returns boolean
set Ad=0
return Xyw("GroupUtils, line 1")
endfunction
function m4u takes nothing returns nothing
set Ad=0
call Feu("Wave, line 35")
endfunction
function Usu takes unit Esu,integer Zsu returns integer
return GetUnitAbilityLevel(Esu,Zsu)
endfunction
function p8w takes trigger y8w returns nothing
call TriggerExecute(y8w)
endfunction
function mxw takes nothing returns nothing
local unit vxw=GetTriggerUnit()
if Usu(vxw,Ko)==0 then
call pxw(vxw)
call p8w(Ao)
call exw()
endif
set vxw=null
endfunction
function Smu takes string tmu returns integer
local integer imu
set Dd[Ad]=tmu
set Ad=Ad+1
if na==0 then
if da<32768 then
set da=da+1
set imu=da
else
call tsw("Out of memory: Could not create BackIterator.","when calling error in ")
set imu=0
endif
else
set na=na-1
set imu=aa[na]
endif
set Ad=Ad-1
return imu
endfunction
function mSw takes integer xSw,boolean vSw returns nothing
endfunction
function jSw takes boolean hSw,string FSw returns integer
local integer kSw
set Dd[Ad]=FSw
set Ad=Ad+1
set kSw=Smu("when calling BackIterator in LinkedListModule, line 97")
call mSw(kSw,hSw)
set Ad=Ad-1
return kSw
endfunction
function Nsw takes string Bsw returns boolean
set Dd[Ad]=Bsw
set Ad=Ad+1
set bi=Ngw("when calling new_LinkedList in FText, line 33")
set ni=0
set di=0
set fi=0
call KSw(false,"when calling new_Iterator in LinkedListModule, line 55")
call jSw(false,"when calling new_BackIterator in LinkedListModule, line 65")
set Ad=Ad-1
return true
endfunction
function n1u takes nothing returns boolean
set Ad=0
return Nsw("FText, line 1")
endfunction
function Lqw takes hashtable Hqw,integer Jqw,integer Kqw returns trigger
return LoadTriggerHandle(Hqw,Jqw,Kqw)
endfunction
function G3w takes integer T3w,integer Y3w returns trigger
return Lqw(Bb,T3w,Y3w)
endfunction
function SCu takes integer rCu,integer sCu,string tCu returns trigger
local trigger iCu
set Dd[Ad]=tCu
set Ad=Ad+1
if Za[rCu]==0 then
if rCu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_loadTrigger","when calling error in ")
else
call tsw("Called Table.Table_Table_loadTrigger on invalid object.","when calling error in ")
endif
endif
set iCu=G3w(rCu,sCu)
set Ad=Ad-1
set Cg=iCu
set iCu=null
return Cg
endfunction
function saw takes hashtable Mqw,integer waw,integer uaw,fogstate raw returns nothing
call SaveFogStateHandle(Mqw,waw,uaw,raw)
endfunction
function k3w takes integer g3w,integer h3w,fogstate F3w returns nothing
call saw(Bb,g3w,h3w,F3w)
endfunction
function bCu takes integer cCu,integer oCu,fogstate OCu,string lCu returns nothing
set Dd[Ad]=lCu
set Ad=Ad+1
if Za[cCu]==0 then
if cCu==0 then
call tsw("Nullpointer exception when calling Table.Table_Table_saveFogState","when calling error in ")
else
call tsw("Called Table.Table_Table_saveFogState on invalid object.","when calling error in ")
endif
endif
call k3w(cCu,oCu,OCu)
set Ad=Ad-1
endfunction
function s_u takes integer w_u,string u_u returns trigger
local trigger r_u
set Dd[Ad]=u_u
set Ad=Ad+1
call bCu(By,0,ConvertFogState(w_u),"when calling saveFogState in TypeCasting, line 88")
set r_u=SCu(By,0,"when calling loadTrigger in TypeCasting, line 89")
set Ad=Ad-1
set Dg=r_u
set r_u=null
return Dg
endfunction
function rIw takes string wIw returns boolean
local boolean uIw
set Dd[Ad]=wIw
set Ad=Ad+1
set uIw=b8w(s_u(kEu(ZO,GetSpellAbilityId(),"when calling get in RegisterEvents, line 58"),"when calling triggerFromIndex in RegisterEvents, line 58"))
set Ad=Ad-1
return uIw
endfunction
function n4u takes nothing returns boolean
set Ad=0
return rIw("RegisterEvents, line 58")
endfunction
function nJw takes nothing returns boolean
set Yl=10
set Gl=10
set gl="CombatSoundsEAX"
set hl=127
set Fl=1.
set kl=10000
set jl=5
set xl=600.
set vl=8000.
set ml=1500.
set Pl=0
set Al=null
call Condition(qg)
return true
endfunction
function ncw takes nothing returns boolean
set gi="Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile.mdl"
set hi=48.
set Fi=1747988803
return true
endfunction
function UUw takes string ZUw returns boolean
set Dd[Ad]=ZUw
set Ad=Ad+1
set ZO=wqw("when calling new_HashMap in RegisterEvents, line 55")
call AUw(EVENT_PLAYER_UNIT_SPELL_EFFECT,yg)
set Ad=Ad-1
return true
endfunction
function o1u takes nothing returns boolean
set Ad=0
return UUw("RegisterEvents, line 1")
endfunction
function uww_2 takes string M0w returns nothing
local integer www
set Dd[Ad]=M0w
set Ad=Ad+1
set www=sww(R_u())
if www!=0 then
call J2u(0,0,0,0,0,0,www,"when calling terminate in EntityManagement, line 33",0.,0.,0.,0,0,0.,0.,0.,null,null,0.,0.,0.,0.,null,null,null)
endif
set Ad=Ad-1
endfunction
function o4u takes nothing returns nothing
set Ad=0
call uww_2("EntityManagement, line 30")
endfunction
function Vjw takes integer Xjw,integer Cjw returns nothing
endfunction
function kAu takes string hAu returns integer
local integer FAu
set Dd[Ad]=hAu
set Ad=Ad+1
if en==0 then
if qn<32768 then
set qn=qn+1
set FAu=qn
else
call tsw("Out of memory: Could not create IdGenerator.","when calling error in ")
set FAu=0
endif
else
set en=en-1
set FAu=pn[en]
endif
set Ad=Ad-1
return FAu
endfunction
function Ljw takes integer Hjw,string Jjw returns integer
local integer Kjw
set Dd[Ad]=Jjw
set Ad=Ad+1
set Kjw=kAu("when calling IdGenerator in ObjectIdGenerator, line 20")
call Vjw(Kjw,Hjw)
set Ad=Ad-1
return Kjw
endfunction
function Djw takes string Ajw returns boolean
set Dd[Ad]=Ajw
set Ad=Ad+1
call Ljw(2016423984,"when calling new_IdGenerator in ObjectIdGenerator, line 7")
call Ljw(1213018160,"when calling new_IdGenerator in ObjectIdGenerator, line 8")
call Ljw(1095577648,"when calling new_IdGenerator in ObjectIdGenerator, line 9")
call Ljw(1112354864,"when calling new_IdGenerator in ObjectIdGenerator, line 10")
call Ljw(1229795376,"when calling new_IdGenerator in ObjectIdGenerator, line 11")
call Ljw(1380790320,"when calling new_IdGenerator in ObjectIdGenerator, line 12")
set Ad=Ad-1
return true
endfunction
function p1u takes nothing returns boolean
set Ad=0
return Djw("ObjectIdGenerator, line 1")
endfunction
function Ak takes nothing returns nothing
endfunction
function FGu takes string gGu returns integer
local integer hGu
set Dd[Ad]=gGu
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set hGu=ye
set pe[hGu]=793
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set hGu=0
endif
else
set be=be-1
set hGu=le[be]
set pe[hGu]=793
endif
set Ad=Ad-1
return hGu
endfunction
function xK takes integer hK,integer FK,string kK returns integer
local integer jK
set Dd[Ad]=kK
set Ad=Ad+1
set jK=gK(null,hK,FK,"when calling addSpellInternal in ClosureEvents, line 139")
set Ad=Ad-1
return jK
endfunction
function BM takes string CM returns nothing
local integer VM
set Dd[Ad]=CM
set Ad=Ad+1
set VM=FGu("when calling alloc_Closure in Destroy, line 6")
call qL(VM)
call xK(1093677125,VM,"when calling onCast in Destroy, line 6")
set Ad=Ad-1
endfunction
function H8w takes nothing returns nothing
local trigger A8w=CreateTrigger()
local trigger D8w
call r8w(A8w,Tg)
set Ky=A8w
set D8w=CreateTrigger()
call r8w(D8w,Yg)
set Ly=D8w
set A8w=null
set D8w=null
endfunction
function N0w takes string B0w returns boolean
set Dd[Ad]=B0w
set Ad=Ad+1
call Q2w(b2w("when calling getTimer in EntityManagement, line 26"),sw,XG)
call Q2w(b2w("when calling getTimer in EntityManagement, line 27"),Vw,CG)
call Q2w(b2w("when calling getTimer in EntityManagement, line 28"),1.0,VG)
call Y_u(BG)
set Ad=Ad-1
return true
endfunction
function TAu takes string fAu returns integer
local integer RAu
set Dd[Ad]=fAu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set RAu=Le
set Xe[RAu]=726
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set RAu=0
endif
else
set Ke=Ke-1
set RAu=Je[Ke]
set Xe[RAu]=726
endif
set Ad=Ad-1
return RAu
endfunction
function dAu takes string aAu returns integer
local integer nAu
set Dd[Ad]=aAu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set nAu=Le
set Xe[nAu]=725
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set nAu=0
endif
else
set Ke=Ke-1
set nAu=Je[Ke]
set Xe[nAu]=725
endif
set Ad=Ad-1
return nAu
endfunction
function NFw takes string LFw returns nothing
local integer XFw
local integer CFw
local playerunitevent VFw
local playerunitevent BFw
set Dd[Ad]=LFw
set Ad=Ad+1
if sPu(Mo,"when calling size in LumberAndCoinSystem, line 90")<=2 then
set bo=2
endif
if uO then
set qo=32.
set no=54+GetRandomInt(-6,6)
endif
set VFw=EVENT_PLAYER_UNIT_DEATH
set XFw=dAu("when calling alloc_Closure in LumberAndCoinSystem, line 95")
call cL(XFw)
call pK(VFw,XFw,"when calling add in LumberAndCoinSystem, line 95")
set BFw=EVENT_PLAYER_UNIT_PICKUP_ITEM
set CFw=TAu("when calling alloc_Closure in LumberAndCoinSystem, line 96")
call cL(CFw)
call pK(BFw,CFw,"when calling add in LumberAndCoinSystem, line 96")
set Ad=Ad-1
set VFw=null
set BFw=null
endfunction
function VVu takes string XVu returns integer
local integer CVu
set Dd[Ad]=XVu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set CVu=Le
set Xe[CVu]=734
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set CVu=0
endif
else
set Ke=Ke-1
set CVu=Je[Ke]
set Xe[CVu]=734
endif
set Ad=Ad-1
return CVu
endfunction
function V7w takes string L7w returns nothing
local integer X7w
local playerunitevent C7w
set Dd[Ad]=L7w
set Ad=Ad+1
set C7w=EVENT_PLAYER_UNIT_PICKUP_ITEM
set X7w=VVu("when calling alloc_Closure in TownBell, line 41")
call cL(X7w)
call pK(C7w,X7w,"when calling add in TownBell, line 41")
set Ad=Ad-1
set C7w=null
endfunction
function mHu takes string xHu returns integer
local integer vHu
set Dd[Ad]=xHu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set vHu=Le
set Xe[vHu]=729
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set vHu=0
endif
else
set Ke=Ke-1
set vHu=Je[Ke]
set Xe[vHu]=729
endif
set Ad=Ad-1
return vHu
endfunction
function VIw takes string LIw returns nothing
local integer XIw
local playerunitevent CIw
set Dd[Ad]=LIw
set Ad=Ad+1
set CIw=EVENT_PLAYER_UNIT_USE_ITEM
set XIw=mHu("when calling alloc_Closure in RevivalSystem, line 7")
call cL(XIw)
call pK(CIw,XIw,"when calling add in RevivalSystem, line 7")
set Ad=Ad-1
set CIw=null
endfunction
function Nbw takes integer Cbw,unit Vbw,string Bbw returns nothing
set Dd[Ad]=Bbw
set Ad=Ad+1
call J2u(0,0,3,Cbw,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Vbw,0.,0.,0.,0.,"when calling construct_UnitEntity in GameConditions, line 20",null,null)
set Ad=Ad-1
endfunction
function pWu takes string bWu returns integer
local integer yWu
set Dd[Ad]=bWu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set yWu=oe
set Oe[yWu]=868
else
call tsw("Out of memory: Could not create Treasure.","when calling error in ")
set yWu=0
endif
else
set ce=ce-1
set yWu=Se[ce]
set Oe[yWu]=868
endif
set Ad=Ad-1
return yWu
endfunction
function Xbw takes unit Jbw,string Kbw returns integer
local integer Lbw
set Dd[Ad]=Kbw
set Ad=Ad+1
set Lbw=pWu("when calling Treasure in GameConditions, line 20")
call Nbw(Lbw,Jbw,"when calling construct_Treasure in GameConditions, line 20")
set Ad=Ad-1
return Lbw
endfunction
function lWu takes string oWu returns integer
local integer OWu
set Dd[Ad]=oWu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set OWu=ae
set ne[OWu]=674
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set OWu=0
endif
else
set qe=qe-1
set OWu=ee[qe]
set ne[OWu]=674
endif
set Ad=Ad-1
return OWu
endfunction
function Zbw takes string Qbw returns nothing
local integer Wbw
local trigger Ebw
set Dd[Ad]=Qbw
set Ad=Ad+1
set Hi=b2w("when calling getTimer in GameConditions, line 24")
call j2w(Hi,16.*60.+20.,wg)
set Wbw=lWu("when calling alloc_Closure in GameConditions, line 26")
call VC(Wbw)
call gX(0.5,Wbw,"when calling doAfter in GameConditions, line 26")
call gEw("|cffFFCC00>> Visit our discord server: discord.gg/yr3ZyYQ")
call gEw("|cffFFCC00>> You have one minute to build up defenses..")
set Ebw=CreateTrigger()
if uO then
call TriggerRegisterUnitEvent(Ebw,T,EVENT_UNIT_DEATH)
call Xbw(T,"when calling new_Treasure in GameConditions, line 35")
call biu(R)
else
call TriggerRegisterUnitEvent(Ebw,R,EVENT_UNIT_DEATH)
call Xbw(R,"when calling new_Treasure in GameConditions, line 39")
call biu(T)
endif
call TriggerAddAction(Ebw,ug)
set Ad=Ad-1
set Ebw=null
endfunction
function IHu takes string ZHu returns integer
local integer UHu
set Dd[Ad]=ZHu
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set UHu=ye
set pe[UHu]=798
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set UHu=0
endif
else
set be=be-1
set UHu=le[be]
set pe[UHu]=798
endif
set Ad=Ad-1
return UHu
endfunction
function LK takes integer DK,integer HK,string JK returns integer
local integer KK
set Dd[Ad]=JK
set Ad=Ad+1
set KK=gK(null,DK,HK,"when calling addSpellInternal in ClosureEvents, line 148")
set Ad=Ad-1
return KK
endfunction
function ZL takes integer EL returns nothing
call qL(EL)
endfunction
function fPw takes string aPw returns nothing
local integer nPw
local integer dPw
set Dd[Ad]=aPw
set Ad=Ad+1
set dPw=DO
set nPw=IHu("when calling alloc_Closure in Rocket, line 54")
call ZL(nPw)
call LK(dPw,nPw,"when calling onPointCast in Rocket, line 54")
set Ad=Ad-1
endfunction
function fWu takes string nWu returns integer
local integer dWu
set Dd[Ad]=nWu
set Ad=Ad+1
if ja==0 then
if xa<32768 then
set xa=xa+1
set dWu=xa
set va[dWu]=777
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set dWu=0
endif
else
set ja=ja-1
set dWu=ka[ja]
set va[dWu]=777
endif
set Ad=Ad-1
return dWu
endfunction
function BH takes camerasetup XH,boolean CH,real VH returns nothing
call CameraSetupApplyForceDuration(XH,CH,VH)
endfunction
function Fpu takes boolean Tpu returns nothing
local real Ypu
local real Gpu
local real gpu
local real hpu
if Tpu then
set Zp=7
set Ep[0]=i
set Ep[1]=S
set Ep[2]=c
set Ep[3]=o
set Ep[4]=O
set Ep[5]=l
set Ep[6]=b
set Ep[7]=t
set Ypu=itu(T)
set Gpu=ctu(T)
set Up=Ypu
set Ip=Gpu
else
set Zp=3
set Ep[0]=w
set Ep[1]=r
set Ep[2]=u
set Ep[3]=s
set gpu=itu(R)
set hpu=ctu(R)
set Up=gpu
set Ip=hpu
endif
endfunction
function GQw takes player YQw returns mapcontrol
return GetPlayerController(YQw)
endfunction
function WQw takes player QQw returns playerslotstate
return GetPlayerSlotState(QQw)
endfunction
function CQw takes player LQw,unit XQw returns nothing
if lO==LQw then
call SelectUnit(XQw,true)
endif
endfunction
function lB takes integer SB,integer cB,integer oB,integer OB returns integer
set jR=SB
set xR=cB
set vR=oB
set mR=OB
return jR
endfunction
function lJu takes string oJu returns integer
local integer OJu
set Dd[Ad]=oJu
set Ad=Ad+1
if be==0 then
if ye<32768 then
set ye=ye+1
set OJu=ye
set pe[OJu]=796
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set OJu=0
endif
else
set be=be-1
set OJu=le[be]
set pe[OJu]=796
endif
set Ad=Ad-1
return OJu
endfunction
function rJ takes player NH,real MH,real wJ,real uJ returns nothing
call PanCameraToTimedForPlayer(NH,MH,wJ,uJ)
endfunction
function mDw takes integer bDw,real yDw,real pDw,real eDw,player qDw,string aDw returns nothing
local unit nDw
local unit dDw
local player fDw
local player RDw
local integer TDw
local unit YDw
local integer GDw
local integer gDw
local integer hDw
local real FDw
local real kDw
local real jDw
local real xDw
local integer vDw
set Dd[Ad]=aDw
set Ad=Ad+1
call J2u(0,0,3,bDw,0,0,0,null,0.,0.,0.,0,0,0.,0.,0.,null,Xru(qDw,1747989043,Ycu(Up,Ip),jf,xf,0.),0.,0.,0.,0.,"when calling construct_UnitEntity in Selector, line 32",null,null)
set ll[bDw]=0.
set sl[bDw]=Ptw(Qou(yDw,pDw,eDw,20.,25.,0.),UR,IR,ZV(qDw),12.5,"when calling createFText in Selector, line 34")
set nDw=Nt[bDw]
call gB(nDw,lB(VV(iWw(qDw)),uR,rR,255),xR,vR,mR)
set dDw=nDw
call SSu(dDw,0.)
set GDw=bDw
set tl[GDw]=yDw
set il[GDw]=pDw
set Sl[GDw]=eDw
set gDw=bDw
set vDw=gDw
set jDw=Up
set xDw=Ip
set FDw=Up
set kDw=Ip
set hDw=bDw
set cl[vDw]=Ycu(wou(jDw,xDw,Kh(Ccu(FDw,kDw,EOu(tl[hDw],il[hDw],Sl[hDw]),Ef),Qh(48)),168.),Cd)
set ol[gDw]=jf
set Ol[gDw]=xf
set fDw=qDw
call CQw(fDw,Nt[bDw])
set RDw=fDw
call rJ(RDw,stu(Nt[bDw]),cf,0.)
set YDw=Nt[bDw]
set TDw=lJu("when calling alloc_Closure in Selector, line 43")
call xL(TDw)
set yl[TDw]=qDw
set pl[TDw]=bDw
call EK(YDw,TDw,"when calling onCast in Selector, line 43")
set Ad=Ad-1
set nDw=null
set dDw=null
set fDw=null
set RDw=null
set YDw=null
endfunction
function tJu takes string rJu returns integer
local integer sJu
set Dd[Ad]=rJu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set sJu=oe
set Oe[sJu]=860
else
call tsw("Out of memory: Could not create Selector.","when calling error in ")
set sJu=0
endif
else
set ce=ce-1
set sJu=Se[ce]
set Oe[sJu]=860
endif
set Ad=Ad-1
return sJu
endfunction
function lDw takes real tDw,real iDw,real SDw,player cDw,string oDw returns integer
local integer ODw
set Dd[Ad]=oDw
set Ad=Ad+1
set ODw=tJu("when calling Selector in Selector, line 32")
call mDw(ODw,tDw,iDw,SDw,cDw,"when calling construct_Selector in Selector, line 32")
set Ad=Ad-1
return ODw
endfunction
function Zmw takes integer Qmw,player Wmw,string Emw returns nothing
set Dd[Ad]=Emw
set Ad=Ad+1
set sO[Qmw]=0
set tO[Qmw]=true
set iO[Qmw]=0
set SO[Qmw]=0
set cO[Qmw]=0
set rO[Qmw]=Wmw
set wO[kQw(Wmw)]=Qmw
call j3u(Mo,Qmw,"when calling add in PlayerData, line 29")
call SetPlayerTechMaxAllowed(Wmw,1747989048,0)
set Ad=Ad-1
endfunction
function dDu takes string aDu returns integer
local integer nDu
set Dd[Ad]=aDu
set Ad=Ad+1
if nn==0 then
if dn<32768 then
set dn=dn+1
set nDu=dn
set fn[nDu]=810
else
call tsw("Out of memory: Could not create PlayerData.","when calling error in ")
set nDu=0
endif
else
set nn=nn-1
set nDu=an[nn]
set fn[nDu]=810
endif
set Ad=Ad-1
return nDu
endfunction
function mmw takes player jmw,string xmw returns integer
local integer vmw
set Dd[Ad]=xmw
set Ad=Ad+1
set vmw=dDu("when calling PlayerData in PlayerData, line 26")
call Zmw(vmw,jmw,"when calling construct_PlayerData in PlayerData, line 26")
set Ad=Ad-1
return vmw
endfunction
function yDu takes string lDu returns integer
local integer bDu
set Dd[Ad]=lDu
set Ad=Ad+1
if Ke==0 then
if Le<32768 then
set Le=Le+1
set bDu=Le
set Xe[bDu]=727
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set bDu=0
endif
else
set Ke=Ke-1
set bDu=Je[Ke]
set Xe[bDu]=727
endif
set Ad=Ad-1
return bDu
endfunction
function gmw takes string qmw returns nothing
local integer amw
local integer nmw
local real dmw
local real fmw
local real Rmw
local integer Tmw
local integer Ymw
local playerevent Gmw
set Dd[Ad]=qmw
set Ad=Ad+1
set Gmw=EVENT_PLAYER_LEAVE
set amw=yDu("when calling alloc_Closure in PlayerData, line 53")
call cL(amw)
call pK(Gmw,amw,"when calling add in PlayerData, line 53")
set nmw=0
loop
exitwhen nmw>7
if WQw(OO[nmw])==PLAYER_SLOT_STATE_PLAYING and GQw(OO[nmw])==MAP_CONTROL_USER then
call mmw(OO[nmw],"when calling new_PlayerData in PlayerData, line 57")
endif
set nmw=nmw+1
endloop
if sPu(Mo,"when calling size in PlayerData, line 59")>4 then
set uO=true
call Fpu(true)
set dmw=1245.
call BH(e,true,0.)
call BH(q,true,1.5)
else
set uO=false
call Fpu(false)
set dmw=490.
call BH(y,true,0.)
call BH(p,true,1.5)
endif
set fmw=360*1./sPu(Mo,"when calling size in PlayerData, line 72")
set Rmw=GetRandomInt(0,sPu(Mo,"when calling size in PlayerData, line 73"))*fmw+GetRandomInt(0,4)*90
set Tmw=lgw(Mo,"when calling iterator in PlayerData, line 74")
loop
exitwhen not nGw(Tmw)
set Ymw=qGw(Tmw)
set cO[Ymw]=lDw(Ycu(wou(Up,Ip,vh(Rmw),285.),Cd),jf,xf,rO[Ymw],"when calling new_Selector in PlayerData, line 75")
set Rmw=Rmw+fmw
call oQw(rO[Ymw],bUw(dmw/sPu(Mo,"when calling size in PlayerData, line 77")))
endloop
call RGw(Tmw,"when calling close in PlayerData, line 74")
call Ptw(Qou(Ycu(Up,Ip),jf,xf,80.,0.,0.),UR,IR,"Item Shop",17.5,"when calling createFText in PlayerData, line 79")
set Ad=Ad-1
set Gmw=null
endfunction
function QMu takes string vMu returns integer
local integer mMu
set Dd[Ad]=vMu
set Ad=Ad+1
if ud==0 then
if rd<32768 then
set rd=rd+1
set mMu=rd
set sd[mMu]=790
else
call tsw("Out of memory: Could not create NormalWave.","when calling error in ")
set mMu=0
endif
else
set ud=ud-1
set mMu=wd[ud]
set sd[mMu]=790
endif
set Ad=Ad-1
return mMu
endfunction
function tqu takes integer Neu,integer Meu,integer wqu,integer uqu,integer rqu,integer squ returns nothing
set Mp[Neu]=0
set Xp[Neu]=Meu
set Cp[Neu]=wqu
set Vp[Neu]=uqu
set Bp[Neu]=rqu
set Np[Neu]=squ
endfunction
function Beu takes integer Heu,integer Jeu,integer Keu,integer Leu,integer Xeu,string Ceu returns integer
local integer Veu
set Dd[Ad]=Ceu
set Ad=Ad+1
set Veu=QMu("when calling NormalWave in Wave, line 25")
call tqu(Veu,Heu,Jeu,Keu,Leu,Xeu)
set Ad=Ad-1
return Veu
endfunction
function HBu takes string ABu returns integer
local integer DBu
set Dd[Ad]=ABu
set Ad=Ad+1
if Dn==0 then
if Hn<32768 then
set Hn=Hn+1
set DBu=Hn
set Jn[DBu]=703
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set DBu=0
endif
else
set Dn=Dn-1
set DBu=An[Dn]
set Jn[DBu]=703
endif
set Ad=Ad-1
return DBu
endfunction
function JNu takes string DNu returns integer
local integer HNu
set Dd[Ad]=DNu
set Ad=Ad+1
if Bn==0 then
if Nn<32768 then
set Nn=Nn+1
set HNu=Nn
set Mn[HNu]=637
else
call tsw("Out of memory: Could not create BossWave.","when calling error in ")
set HNu=0
endif
else
set Bn=Bn-1
set HNu=Vn[Bn]
set Mn[HNu]=637
endif
set Ad=Ad-1
return HNu
endfunction
function Npu takes integer Jpu,integer Kpu,integer Lpu,integer Xpu,string Cpu,integer Vpu,string Bpu returns nothing
set Dd[Ad]=Bpu
set Ad=Ad+1
set Pp[Jpu]=Kpu
set Ap[Jpu]=Lpu
set Dp[Jpu]=Xpu
set Hp[Jpu]=VJw(Cpu,false,"when calling new_SoundDefinition in Wave, line 77")
set Jp[Jpu]=Vpu
set Ad=Ad-1
endfunction
function Hpu takes integer Epu,integer Zpu,integer Upu,string Ipu,integer Ppu,string Apu returns integer
local integer Dpu
set Dd[Ad]=Apu
set Ad=Ad+1
set Dpu=JNu("when calling BossWave in Wave, line 73")
call Npu(Dpu,Epu,Zpu,Upu,Ipu,Ppu,"when calling construct_BossWave in Wave, line 73")
set Ad=Ad-1
return Dpu
endfunction
function LBu takes string JBu returns integer
local integer KBu
set Dd[Ad]=JBu
set Ad=Ad+1
if Dn==0 then
if Hn<32768 then
set Hn=Hn+1
set KBu=Hn
set Jn[KBu]=704
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set KBu=0
endif
else
set Dn=Dn-1
set KBu=An[Dn]
set Jn[KBu]=704
endif
set Ad=Ad-1
return KBu
endfunction
function MBu takes string BBu returns integer
local integer NBu
set Dd[Ad]=BBu
set Ad=Ad+1
if Ln==0 then
if Xn<32768 then
set Xn=Xn+1
set NBu=Xn
set Cn[NBu]=707
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set NBu=0
endif
else
set Ln=Ln-1
set NBu=Kn[Ln]
set Cn[NBu]=707
endif
set Ad=Ad-1
return NBu
endfunction
function PBu takes string UBu returns integer
local integer IBu
set Dd[Ad]=UBu
set Ad=Ad+1
if Dn==0 then
if Hn<32768 then
set Hn=Hn+1
set IBu=Hn
set Jn[IBu]=702
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set IBu=0
endif
else
set Dn=Dn-1
set IBu=An[Dn]
set Jn[IBu]=702
endif
set Ad=Ad-1
return IBu
endfunction
function QBu takes string vBu returns integer
local integer mBu
set Dd[Ad]=vBu
set Ad=Ad+1
if Dn==0 then
if Hn<32768 then
set Hn=Hn+1
set mBu=Hn
set Jn[mBu]=700
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set mBu=0
endif
else
set Dn=Dn-1
set mBu=An[Dn]
set Jn[mBu]=700
endif
set Ad=Ad-1
return mBu
endfunction
function VBu takes string XBu returns integer
local integer CBu
set Dd[Ad]=XBu
set Ad=Ad+1
if Ln==0 then
if Xn<32768 then
set Xn=Xn+1
set CBu=Xn
set Cn[CBu]=706
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set CBu=0
endif
else
set Ln=Ln-1
set CBu=Kn[Ln]
set Cn[CBu]=706
endif
set Ad=Ad-1
return CBu
endfunction
function ZBu takes string WBu returns integer
local integer EBu
set Dd[Ad]=WBu
set Ad=Ad+1
if Dn==0 then
if Hn<32768 then
set Hn=Hn+1
set EBu=Hn
set Jn[EBu]=701
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set EBu=0
endif
else
set Dn=Dn-1
set EBu=An[Dn]
set Jn[EBu]=701
endif
set Ad=Ad-1
return EBu
endfunction
function ceu takes integer Seu returns nothing
endfunction
function iNu takes string sNu returns integer
local integer tNu
set Dd[Ad]=sNu
set Ad=Ad+1
if Ln==0 then
if Xn<32768 then
set Xn=Xn+1
set tNu=Xn
set Cn[tNu]=709
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set tNu=0
endif
else
set Ln=Ln-1
set tNu=Kn[Ln]
set Cn[tNu]=709
endif
set Ad=Ad-1
return tNu
endfunction
function oNu takes string SNu returns integer
local integer cNu
set Dd[Ad]=SNu
set Ad=Ad+1
if Ln==0 then
if Xn<32768 then
set Xn=Xn+1
set cNu=Xn
set Cn[cNu]=710
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set cNu=0
endif
else
set Ln=Ln-1
set cNu=Kn[Ln]
set Cn[cNu]=710
endif
set Ad=Ad-1
return cNu
endfunction
function rNu takes string wNu returns integer
local integer uNu
set Dd[Ad]=wNu
set Ad=Ad+1
if Ln==0 then
if Xn<32768 then
set Xn=Xn+1
set uNu=Xn
set Cn[uNu]=708
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set uNu=0
endif
else
set Ln=Ln-1
set uNu=Kn[Ln]
set Cn[uNu]=708
endif
set Ad=Ad-1
return uNu
endfunction
function LMu takes string JMu returns integer
local integer KMu
set Dd[Ad]=JMu
set Ad=Ad+1
if id==0 then
if Sd<32768 then
set Sd=Sd+1
set KMu=Sd
set cd[KMu]=879
else
call tsw("Out of memory: Could not create SpecialWave.","when calling error in ")
set KMu=0
endif
else
set id=id-1
set KMu=td[id]
set cd[KMu]=879
endif
set Ad=Ad-1
return KMu
endfunction
function Uqu takes integer mqu,integer Qqu,integer Wqu,integer Equ,integer Zqu returns nothing
set re[mqu]=Qqu
set se[mqu]=Wqu
set te[mqu]=Equ
set ie[mqu]=Zqu
endfunction
function vqu takes integer gqu,integer hqu,integer Fqu,integer kqu,string jqu returns integer
local integer xqu
set Dd[Ad]=jqu
set Ad=Ad+1
set xqu=LMu("when calling SpecialWave in Wave, line 98")
call Uqu(xqu,gqu,hqu,Fqu,kqu)
set Ad=Ad-1
return xqu
endfunction
function weu takes integer Mpu returns nothing
endfunction
function gwu takes string B_u returns nothing
local integer N_u
local integer M_u
local integer wwu
local integer uwu
local integer rwu
local integer swu
local integer twu
local integer iwu
local integer Swu
local integer cwu
local string owu
local integer Owu
local string lwu
local integer bwu
local string ywu
local integer pwu
local string ewu
local integer qwu
local string awu
local integer nwu
local integer dwu
local integer fwu
local integer Rwu
local integer Twu
local integer Ywu
local integer Gwu
set Dd[Ad]=B_u
set Ad=Ad+1
call j3u(Sp,Beu(1966092336,1966092339,1848651824,1,6,"when calling new_NormalWave in UnitSpawnSystem, line 45"),"when calling add in UnitSpawnSystem, line 45")
call j3u(Sp,Beu(1966092336,1966092339,1848651824,2,6,"when calling new_NormalWave in UnitSpawnSystem, line 46"),"when calling add in UnitSpawnSystem, line 46")
call j3u(Sp,Beu(1966092336,1966092339,1848651824,3,6,"when calling new_NormalWave in UnitSpawnSystem, line 47"),"when calling add in UnitSpawnSystem, line 47")
call j3u(Sp,Beu(1966092337,1966092340,1848651825,1,10,"when calling new_NormalWave in UnitSpawnSystem, line 49"),"when calling add in UnitSpawnSystem, line 49")
call j3u(Sp,Beu(1966092337,1966092340,1848651825,2,10,"when calling new_NormalWave in UnitSpawnSystem, line 50"),"when calling add in UnitSpawnSystem, line 50")
call j3u(Sp,Beu(1966092337,1966092340,1848651825,3,10,"when calling new_NormalWave in UnitSpawnSystem, line 51"),"when calling add in UnitSpawnSystem, line 51")
call j3u(Sp,Beu(1966092338,1966092341,1848651826,1,11,"when calling new_NormalWave in UnitSpawnSystem, line 53"),"when calling add in UnitSpawnSystem, line 53")
call j3u(Sp,Beu(1966092338,1966092341,1848651826,2,11,"when calling new_NormalWave in UnitSpawnSystem, line 54"),"when calling add in UnitSpawnSystem, line 54")
call j3u(Sp,Beu(1966092338,1966092341,1848651826,3,11,"when calling new_NormalWave in UnitSpawnSystem, line 55"),"when calling add in UnitSpawnSystem, line 55")
call j3u(Sp,Beu(1966092342,1966092343,1848651829,1,12,"when calling new_NormalWave in UnitSpawnSystem, line 57"),"when calling add in UnitSpawnSystem, line 57")
call j3u(Sp,Beu(1966092342,1966092343,1848651829,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 58"),"when calling add in UnitSpawnSystem, line 58")
call j3u(Sp,Beu(1966092342,1966092343,1848651829,3,12,"when calling new_NormalWave in UnitSpawnSystem, line 59"),"when calling add in UnitSpawnSystem, line 59")
call j3u(Sp,Beu(1966092344,1966092345,1848651830,1,13,"when calling new_NormalWave in UnitSpawnSystem, line 61"),"when calling add in UnitSpawnSystem, line 61")
call j3u(Sp,Beu(1966092344,1966092345,1848651830,2,13,"when calling new_NormalWave in UnitSpawnSystem, line 62"),"when calling add in UnitSpawnSystem, line 62")
call j3u(Sp,Beu(1966092344,1966092345,1848651830,3,13,"when calling new_NormalWave in UnitSpawnSystem, line 63"),"when calling add in UnitSpawnSystem, line 63")
call j3u(Sp,Beu(1966092359,1966092360,1848651832,1,14,"when calling new_NormalWave in UnitSpawnSystem, line 65"),"when calling add in UnitSpawnSystem, line 65")
call j3u(Sp,Beu(1966092359,1966092360,1848651832,2,14,"when calling new_NormalWave in UnitSpawnSystem, line 66"),"when calling add in UnitSpawnSystem, line 66")
call j3u(Sp,Beu(1966092359,1966092360,1848651832,3,14,"when calling new_NormalWave in UnitSpawnSystem, line 67"),"when calling add in UnitSpawnSystem, line 67")
call j3u(Sp,Beu(1966092361,1966092363,1848651833,1,15,"when calling new_NormalWave in UnitSpawnSystem, line 69"),"when calling add in UnitSpawnSystem, line 69")
call j3u(Sp,Beu(1966092361,1966092363,1848651833,2,15,"when calling new_NormalWave in UnitSpawnSystem, line 70"),"when calling add in UnitSpawnSystem, line 70")
call j3u(Sp,Beu(1966092361,1966092363,1848651833,3,15,"when calling new_NormalWave in UnitSpawnSystem, line 71"),"when calling add in UnitSpawnSystem, line 71")
call j3u(Sp,Beu(1966092362,1966092364,1848651841,1,16,"when calling new_NormalWave in UnitSpawnSystem, line 73"),"when calling add in UnitSpawnSystem, line 73")
call j3u(Sp,Beu(1966092362,1966092364,1848651841,2,16,"when calling new_NormalWave in UnitSpawnSystem, line 74"),"when calling add in UnitSpawnSystem, line 74")
call j3u(Sp,Beu(1966092362,1966092364,1848651841,3,16,"when calling new_NormalWave in UnitSpawnSystem, line 75"),"when calling add in UnitSpawnSystem, line 75")
call j3u(Sp,Beu(1966092366,1966092365,1848651844,1,16,"when calling new_NormalWave in UnitSpawnSystem, line 77"),"when calling add in UnitSpawnSystem, line 77")
call j3u(Sp,Beu(1966092366,1966092365,1848651844,2,16,"when calling new_NormalWave in UnitSpawnSystem, line 78"),"when calling add in UnitSpawnSystem, line 78")
call j3u(Sp,Beu(1966092366,1966092365,1848651844,3,16,"when calling new_NormalWave in UnitSpawnSystem, line 79"),"when calling add in UnitSpawnSystem, line 79")
call j3u(Sp,Beu(1966092371,1966092368,1848651846,1,14,"when calling new_NormalWave in UnitSpawnSystem, line 81"),"when calling add in UnitSpawnSystem, line 81")
call j3u(Sp,Beu(1966092371,1966092368,1848651846,2,14,"when calling new_NormalWave in UnitSpawnSystem, line 82"),"when calling add in UnitSpawnSystem, line 82")
call j3u(Sp,Beu(1966092371,1966092368,1848651846,2,14,"when calling new_NormalWave in UnitSpawnSystem, line 83"),"when calling add in UnitSpawnSystem, line 83")
call j3u(Sp,Beu(1966092372,1966092369,1848651847,1,14,"when calling new_NormalWave in UnitSpawnSystem, line 85"),"when calling add in UnitSpawnSystem, line 85")
call j3u(Sp,Beu(1966092372,1966092369,1848651847,2,14,"when calling new_NormalWave in UnitSpawnSystem, line 86"),"when calling add in UnitSpawnSystem, line 86")
call j3u(Sp,Beu(1966092372,1966092369,1848651847,2,14,"when calling new_NormalWave in UnitSpawnSystem, line 87"),"when calling add in UnitSpawnSystem, line 87")
call j3u(Sp,Beu(1966092373,1966092370,1848651848,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 89"),"when calling add in UnitSpawnSystem, line 89")
call j3u(Sp,Beu(1966092373,1966092370,1848651848,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 90"),"when calling add in UnitSpawnSystem, line 90")
call j3u(Sp,Beu(1966092373,1966092370,1848651848,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 91"),"when calling add in UnitSpawnSystem, line 91")
call j3u(Sp,Beu(1966092376,1966092592,1848651849,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 93"),"when calling add in UnitSpawnSystem, line 93")
call j3u(Sp,Beu(1966092376,1966092592,1848651849,3,12,"when calling new_NormalWave in UnitSpawnSystem, line 94"),"when calling add in UnitSpawnSystem, line 94")
call j3u(Sp,Beu(1966092376,1966092592,1848651849,3,12,"when calling new_NormalWave in UnitSpawnSystem, line 95"),"when calling add in UnitSpawnSystem, line 95")
call j3u(Sp,Beu(1966092377,1966092593,1848651850,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 97"),"when calling add in UnitSpawnSystem, line 97")
call j3u(Sp,Beu(1966092377,1966092593,1848651850,2,12,"when calling new_NormalWave in UnitSpawnSystem, line 98"),"when calling add in UnitSpawnSystem, line 98")
call j3u(Sp,Beu(1966092378,1966092594,1848651851,1,12,"when calling new_NormalWave in UnitSpawnSystem, line 100"),"when calling add in UnitSpawnSystem, line 100")
call j3u(Sp,Beu(1966092378,1966092594,1848651851,1,12,"when calling new_NormalWave in UnitSpawnSystem, line 101"),"when calling add in UnitSpawnSystem, line 101")
call j3u(Sp,Beu(1966092378,1966092594,1848651851,1,10,"when calling new_NormalWave in UnitSpawnSystem, line 103"),"when calling add in UnitSpawnSystem, line 103")
call j3u(Sp,Beu(1966092378,1966092594,1848651851,1,10,"when calling new_NormalWave in UnitSpawnSystem, line 104"),"when calling add in UnitSpawnSystem, line 104")
set Owu=cp
set owu=qb
set N_u=QBu("when calling alloc_Closure in UnitSpawnSystem, line 106")
call weu(N_u)
call j3u(Owu,Hpu(1848651827,1,85,owu,N_u,"when calling new_BossWave in UnitSpawnSystem, line 106"),"when calling add in UnitSpawnSystem, line 106")
set bwu=cp
set lwu=lb
set M_u=ZBu("when calling alloc_Closure in UnitSpawnSystem, line 109")
call weu(M_u)
call j3u(bwu,Hpu(1848651828,1,100,lwu,M_u,"when calling new_BossWave in UnitSpawnSystem, line 109"),"when calling add in UnitSpawnSystem, line 109")
set pwu=cp
set ywu=ob
set wwu=PBu("when calling alloc_Closure in UnitSpawnSystem, line 112")
call weu(wwu)
call j3u(pwu,Hpu(1848651831,1,125,ywu,wwu,"when calling new_BossWave in UnitSpawnSystem, line 112"),"when calling add in UnitSpawnSystem, line 112")
set qwu=cp
set ewu=eb
set uwu=HBu("when calling alloc_Closure in UnitSpawnSystem, line 115")
call weu(uwu)
call j3u(qwu,Hpu(1848651842,1,150,ewu,uwu,"when calling new_BossWave in UnitSpawnSystem, line 115"),"when calling add in UnitSpawnSystem, line 115")
set nwu=cp
set awu=Ob
set rwu=LBu("when calling alloc_Closure in UnitSpawnSystem, line 118")
call weu(rwu)
call j3u(nwu,Hpu(1848651845,1,175,awu,rwu,"when calling new_BossWave in UnitSpawnSystem, line 118"),"when calling add in UnitSpawnSystem, line 118")
set dwu=op
set swu=VBu("when calling alloc_Closure in UnitSpawnSystem, line 122")
call ceu(swu)
call j3u(dwu,vqu(1966092353,3,15,swu,"when calling new_SpecialWave in UnitSpawnSystem, line 122"),"when calling add in UnitSpawnSystem, line 122")
set fwu=op
set twu=MBu("when calling alloc_Closure in UnitSpawnSystem, line 125")
call ceu(twu)
call j3u(fwu,vqu(1966092354,1,25,twu,"when calling new_SpecialWave in UnitSpawnSystem, line 125"),"when calling add in UnitSpawnSystem, line 125")
set Rwu=op
set iwu=rNu("when calling alloc_Closure in UnitSpawnSystem, line 128")
call ceu(iwu)
call j3u(Rwu,vqu(1966092358,4,10,iwu,"when calling new_SpecialWave in UnitSpawnSystem, line 128"),"when calling add in UnitSpawnSystem, line 128")
set Twu=op
set Swu=iNu("when calling alloc_Closure in UnitSpawnSystem, line 131")
call ceu(Swu)
call j3u(Twu,vqu(1966092367,25,4,Swu,"when calling new_SpecialWave in UnitSpawnSystem, line 131"),"when calling add in UnitSpawnSystem, line 131")
set Gwu=op
set Ywu=Ub
set cwu=oNu("when calling alloc_Closure in UnitSpawnSystem, line 134")
call ceu(cwu)
call j3u(Gwu,vqu(Ywu,4,65,cwu,"when calling new_SpecialWave in UnitSpawnSystem, line 134"),"when calling add in UnitSpawnSystem, line 134")
set Ad=Ad-1
endfunction
function kru takes string Fru returns nothing
set Dd[Ad]=Fru
set Ad=Ad+1
call gwu("when calling initWaves in UnitSpawnSystem, line 169")
set Ad=Ad-1
endfunction
function cyw takes string tyw returns nothing
local integer iyw
local integer Syw
set Dd[Ad]=tyw
set Ad=Ad+1
call gmw("when calling initPlayers in GameInit, line 17")
call NFw("when calling initLumberSystem in GameInit, line 18")
call BM("when calling initDestroy in GameInit, line 19")
call VIw("when calling initRevivalSystem in GameInit, line 20")
call Ak()
call H8w()
call Zbw("when calling initConds in GameInit, line 23")
call kru("when calling initSpawn in GameInit, line 24")
call fPw("when calling initRocket in GameInit, line 25")
call V7w("when calling initTownBell in GameInit, line 26")
call e2w(GetExpiredTimer(),"when calling release in GameInit, line 27")
call xKu(VJw(yb,false,"when calling new_SoundDefinition in GameInit, line 28"),"when calling play in GameInit, line 28")
call gEw("|cffffcc00Leave space between walls and towers in order to repair damaged walls!")
call N0w("when calling startEntityLoop in GameInit, line 30")
if sPu(Mo,"when calling size in GameInit, line 31")<=2 and mQw(rO[EIu(Mo,0,"when calling get in GameInit, line 31")])=="WorldEdit" or mQw(rO[EIu(Mo,0,"when calling get in GameInit, line 31")])=="Frotty" then
set Syw=Mo
set iyw=fWu("when calling alloc_Closure in GameInit, line 32")
call aPu(Syw,iyw,"when calling forEach in GameInit, line 32")
call j2w(b2w("when calling getTimer in GameInit, line 33"),15.,sg)
call Cheat("warpten")
call Cheat("iseedeadpeople")
call gEw("|cffFFCC00>>|r Editor Test Mode activated")
else
call j2w(b2w("when calling getTimer in GameInit, line 38"),50.,tg)
endif
set Ad=Ad-1
endfunction
function p4u takes nothing returns nothing
set Ad=0
call cyw("GameInit, line 63")
endfunction
function q0w takes nothing returns boolean
set Tt=false
return true
endfunction
function qTu takes string pTu returns integer
local integer eTu
set Dd[Ad]=pTu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set eTu=ae
set ne[eTu]=663
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set eTu=0
endif
else
set qe=qe-1
set eTu=ee[qe]
set ne[eTu]=663
endif
set Ad=Ad-1
return eTu
endfunction
function bJ takes string OJ returns boolean
local integer lJ
set Dd[Ad]=OJ
set Ad=Ad+1
set pu=ConvertPlayerEvent(96)
set fu=wqw("when calling new_HashMap in ClosureEvents, line 98")
set Ru=wqw("when calling new_HashMap in ClosureEvents, line 99")
set eu=CreateTrigger()
set qu=CreateTrigger()
set au=CreateTrigger()
set du=0
set lJ=qTu("when calling alloc_Closure in ClosureEvents, line 278")
call VC(lJ)
call kX(lJ,"when calling nullTimer in ClosureEvents, line 278")
set Ad=Ad-1
return true
endfunction
function q1u takes nothing returns boolean
set Ad=0
return bJ("ClosureEvents, line 1")
endfunction
function q4u takes nothing returns nothing
set Ad=0
call nyw("GameInit, line 38")
endfunction
function I2 takes integer U2 returns nothing
endfunction
function ihu takes integer shu,string thu returns nothing
set Dd[Ad]=thu
set Ad=Ad+1
if Zq[shu]==0 then
call tsw("Double free: object of type DelayNode","when calling error in ")
else
set Qq[Wq]=shu
set Wq=Wq+1
set Zq[shu]=0
endif
set Ad=Ad-1
endfunction
function v2 takes integer j2,string x2 returns nothing
set Dd[Ad]=x2
set Ad=Ad+1
call I2(j2)
call ihu(j2,"when calling DelayNode in DummyRecycler, line 71")
set Ad=Ad-1
endfunction
function Mgu takes integer Bgu,string Ngu returns nothing
set Dd[Ad]=Ngu
set Ad=Ad+1
if Zq[Bgu]==0 then
if Bgu==0 then
call tsw("Nullpointer exception when calling DelayNode.destroyDelayNode","when calling error in ")
else
call tsw("Called DelayNode.destroyDelayNode on invalid object.","when calling error in ")
endif
endif
call v2(Bgu,"when calling destroyDelayNode in DummyRecycler, line 71")
set Ad=Ad-1
endfunction
function c5 takes unit B2,string N2 returns nothing
local integer M2
local integer w5
local integer u5
local unit r5
local unit s5
local unit t5
local unit i5
local unit S5
set Dd[Ad]=N2
set Ad=Ad+1
set M2=0
set w5=1
set u5=os-1
loop
exitwhen w5>u5
if ps[Rs[M2]]>ps[Rs[w5]]then
set M2=w5
endif
set w5=w5+1
endloop
if ps[Rs[M2]]>=ls then
call biu(B2)
else
call Dgu(Rs[M2],B2,"when calling enqueue in DummyRecycler, line 38")
set r5=B2
call kSu(r5,vo,mo)
set s5=r5
call Siu(s5)
set t5=s5
call viu(t5,vh(M2*Os))
set i5=t5
call OSu(i5,1.)
set S5=i5
call gB(S5,Au,Du,Hu,Ju)
endif
set Ad=Ad-1
set r5=null
set s5=null
set t5=null
set i5=null
set S5=null
endfunction
function k2 takes string h2 returns nothing
local integer F2
set Dd[Ad]=h2
set Ad=Ad+1
call c5(qs[ds],"when calling recycle in DummyRecycler, line 120")
set F2=ds
if ns[ds]==0 then
set ds=0
else
set ds=ns[ds]
call j2w(es,as[ds]-Hyw(),DG)
endif
call Mgu(F2,"when calling DelayNode in DummyRecycler, line 129")
set Ad=Ad-1
endfunction
function r4u takes nothing returns nothing
set Ad=0
call k2("DummyRecycler, line 115")
endfunction
function s4u takes nothing returns nothing
set Ad=0
call k2("DummyRecycler, line 117")
endfunction
function sWw takes nothing returns boolean
set bO=ConvertPlayerColor(24)
set yO=ConvertPlayerColor(25)
set pO=ConvertPlayerColor(26)
set eO=ConvertPlayerColor(27)
set qO[0]=PLAYER_COLOR_RED
set qO[1]=PLAYER_COLOR_BLUE
set qO[2]=PLAYER_COLOR_CYAN
set qO[3]=PLAYER_COLOR_PURPLE
set qO[4]=PLAYER_COLOR_YELLOW
set qO[5]=PLAYER_COLOR_ORANGE
set qO[6]=PLAYER_COLOR_GREEN
set qO[7]=PLAYER_COLOR_PINK
set qO[8]=PLAYER_COLOR_LIGHT_GRAY
set qO[9]=PLAYER_COLOR_LIGHT_BLUE
set qO[10]=PLAYER_COLOR_AQUA
set qO[11]=PLAYER_COLOR_BROWN
set qO[12]=PLAYER_COLOR_MAROON
set qO[13]=PLAYER_COLOR_NAVY
set qO[14]=PLAYER_COLOR_TURQUOISE
set qO[15]=PLAYER_COLOR_VIOLET
set qO[16]=PLAYER_COLOR_WHEAT
set qO[17]=PLAYER_COLOR_PEACH
set qO[18]=PLAYER_COLOR_MINT
set qO[19]=PLAYER_COLOR_LAVENDER
set qO[20]=PLAYER_COLOR_COAL
set qO[21]=PLAYER_COLOR_SNOW
set qO[22]=PLAYER_COLOR_EMERALD
set qO[23]=PLAYER_COLOR_PEANUT
set qO[24]=bO
set qO[25]=yO
set qO[26]=pO
set qO[27]=eO
return true
endfunction
function initializeTable takes string stackPos returns nothing
local integer i_2
set Dd[Ad]=stackPos
set Ad=Ad+1
set i_2=0
loop
exitwhen i_2>15
call JXu(ur,ZMw(wr[i_2]),i_2,"when calling saveInt in Colors, line 205")
set i_2=i_2+1
endloop
set Ad=Ad-1
endfunction
function WV takes string wV returns boolean
local integer uV
local integer rV
local integer sV
local integer tV
local integer iV
local integer SV
local integer cV
local integer oV
local integer OV
local integer lV
local integer bV
local integer yV
local integer pV
local integer eV
local integer qV
local integer aV
local integer nV
local integer dV
local integer fV
local integer RV
local integer TV
local integer YV
local integer GV
local integer gV
local integer hV
local integer FV
local integer kV
local integer jV
local integer xV
local integer vV
local integer mV
local integer QV
set Dd[Ad]=wV
set Ad=Ad+1
set uV=255
set rV=255
set sV=255
set tV=255
set Au=uV
set Du=rV
set Hu=sV
set Ju=tV
set iV=0
set SV=0
set cV=0
set oV=0
set Ku=iV
set Lu=SV
set Xu=cV
set Cu=oV
set Vu=23
set OV=0
set Bu[OV]=255
set Nu[OV]=2
set Mu[OV]=2
set lV=1
set Bu[lV]=0
set Nu[lV]=65
set Mu[lV]=255
set bV=2
set Bu[bV]=27
set Nu[bV]=229
set Mu[bV]=184
set yV=3
set Bu[yV]=83
set Nu[yV]=0
set Mu[yV]=128
set pV=4
set Bu[pV]=255
set Nu[pV]=252
set Mu[pV]=0
set eV=5
set Bu[eV]=254
set Nu[eV]=137
set Mu[eV]=13
set qV=6
set Bu[qV]=31
set Nu[qV]=191
set Mu[qV]=0
set aV=7
set Bu[aV]=228
set Nu[aV]=90
set Mu[aV]=175
set nV=8
set Bu[nV]=148
set Nu[nV]=149
set Mu[nV]=150
set dV=9
set Bu[dV]=125
set Nu[dV]=190
set Mu[dV]=241
set fV=10
set Bu[fV]=15
set Nu[fV]=97
set Mu[fV]=69
set RV=11
set Bu[RV]=77
set Nu[RV]=41
set Mu[RV]=3
set TV=12
set Bu[TV]=155
set Nu[TV]=0
set Mu[TV]=0
set YV=13
set Bu[YV]=0
set Nu[YV]=0
set Mu[YV]=195
set GV=14
set Bu[GV]=0
set Nu[GV]=234
set Mu[GV]=255
set gV=15
set Bu[gV]=190
set Nu[gV]=0
set Mu[gV]=254
set hV=16
set Bu[hV]=235
set Nu[hV]=205
set Mu[hV]=135
set FV=17
set Bu[FV]=248
set Nu[FV]=164
set Mu[FV]=139
set kV=18
set Bu[kV]=191
set Nu[kV]=255
set Mu[kV]=128
set jV=19
set Bu[jV]=220
set Nu[jV]=185
set Mu[jV]=235
set xV=20
set Bu[xV]=40
set Nu[xV]=40
set Mu[xV]=40
set vV=21
set Bu[vV]=235
set Nu[vV]=240
set Mu[vV]=255
set mV=22
set Bu[mV]=0
set Nu[mV]=120
set Mu[mV]=30
set QV=23
set Bu[QV]=164
set Nu[QV]=11
set Mu[QV]=51
set wr[0]="0"
set wr[1]="1"
set wr[2]="2"
set wr[3]="3"
set wr[4]="4"
set wr[5]="5"
set wr[6]="6"
set wr[7]="7"
set wr[8]="8"
set wr[9]="9"
set wr[10]="A"
set wr[11]="B"
set wr[12]="C"
set wr[13]="D"
set wr[14]="E"
set wr[15]="F"
set ur=v3w("when calling new_Table in Colors, line 153")
call initializeTable("when calling initializeTable in Colors, line 208")
set Ad=Ad-1
return true
endfunction
function t1u takes nothing returns boolean
set Ad=0
return WV("Colors, line 1")
endfunction
function C0u takes integer K0u,string L0u returns string
local string X0u
set Dd[Ad]=L0u
set Ad=Ad+1
set X0u=VXu(By,K0u,"when calling loadString in TypeCasting, line 29")
set Ad=Ad-1
return X0u
endfunction
function Eku takes string Qku returns integer
local integer Wku
set Dd[Ad]=Qku
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set Wku=ae
set ne[Wku]=672
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set Wku=0
endif
else
set qe=qe-1
set Wku=ee[qe]
set ne[Wku]=672
endif
set Ad=Ad-1
return Wku
endfunction
function j9 takes integer G9,integer g9,string h9 returns nothing
local integer F9
local real k9
set Dd[Ad]=h9
set Ad=Ad+1
call Tiu(Nt[G9],"spell")
set k9=Gy
set F9=Eku("when calling alloc_Closure in EndBoss, line 90")
call VC(F9)
set et[F9]=g9
call gX(k9,F9,"when calling doAfter in EndBoss, line 90")
set Ad=Ad-1
endfunction
function rku takes integer MFu,integer wku,string uku returns nothing
set Dd[Ad]=uku
set Ad=Ad+1
if Oe[MFu]==0 then
if MFu==0 then
call tsw("Nullpointer exception when calling EndBoss.EndBoss_EndBoss_castTowerBlockade","when calling error in ")
else
call tsw("Called EndBoss.EndBoss_EndBoss_castTowerBlockade on invalid object.","when calling error in ")
endif
endif
call j9(MFu,wku,"when calling castTowerBlockade in EndBoss, line 87")
set Ad=Ad-1
endfunction
function e9 takes integer N8,string M8 returns nothing
local group w9
local unit u9
local integer r9
local boolean s9
local integer t9
local integer i9
local integer S9
local real c9
local real o9
local integer O9
local real l9
local real b9
local group y9
local real p9
set Dd[Ad]=M8
set Ad=Ad+1
set y9=OS
set S9=N8
set o9=ht[S9]
set c9=o9
set p9=c9
set O9=N8
set b9=Ft[O9]
set l9=b9
call GroupEnumUnitsInRange(y9,p9,l9,3072.,Filter(KG))
set w9=Lpw(OS)
loop
exitwhen not Jpw(w9)
set u9=Bpw(w9)
set r9=sww(u9)
set s9=false
if KU(r9) then
set t9=lgw(iI(r9),"when calling iterator in EndBoss, line 80")
loop
exitwhen not nGw(t9)
set i9=qGw(t9)
if Ie[i9]==648 then
set s9=true
endif
endloop
call RGw(t9,"when calling close in EndBoss, line 80")
endif
if not s9 then
call rku(N8,r9,"when calling castTowerBlockade in EndBoss, line 84")
call Mpw(w9)
set Ad=Ad-1
set w9=null
set u9=null
set y9=null
return
endif
endloop
call Mpw(w9)
set Ad=Ad-1
set w9=null
set u9=null
set y9=null
endfunction
function NFu takes integer VFu,string BFu returns nothing
set Dd[Ad]=BFu
set Ad=Ad+1
if Oe[VFu]==0 then
if VFu==0 then
call tsw("Nullpointer exception when calling EndBoss.EndBoss_EndBoss_tryCastTowerBlockade","when calling error in ")
else
call tsw("Called EndBoss.EndBoss_EndBoss_tryCastTowerBlockade on invalid object.","when calling error in ")
endif
endif
call e9(VFu,"when calling tryCastTowerBlockade in EndBoss, line 71")
set Ad=Ad-1
endfunction
function T3 takes integer e3,real q3,real a3,real n3,string d3 returns nothing
local integer f3
local integer R3
set Dd[Ad]=d3
set Ad=Ad+1
call J2u(0,0,0,0,7,e3,0,null,q3,a3,n3,Tr,gr,Up,Ip,qlu(q3,a3,n3,Up,Ip),"when calling construct_Creep in DestroyerSummoner, line 112",null,0.,0.,0.,0.,null,null,null)
set xr[e3]=false
set f3=Nlw(q3,a3,n3,0.,x,"when calling new_Fx in DestroyerSummoner, line 114")
call XQu(f3,180.,"when calling setZ in DestroyerSummoner, line 114")
set R3=f3
call iQu(R3,1.5,"when calling setScale in DestroyerSummoner, line 114")
call Bmu(R3,"when calling Fx in DestroyerSummoner, line 114")
set Ad=Ad-1
endfunction
function xGu takes string kGu returns integer
local integer jGu
set Dd[Ad]=kGu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set jGu=oe
set Oe[jGu]=850
else
call tsw("Out of memory: Could not create DestroyerSummoner.","when calling error in ")
set jGu=0
endif
else
set ce=ce-1
set jGu=Se[ce]
set Oe[jGu]=850
endif
set Ad=Ad-1
return jGu
endfunction
function p3 takes real o3,real O3,real l3,string b3 returns integer
local integer y3
set Dd[Ad]=b3
set Ad=Ad+1
set y3=xGu("when calling DestroyerSummoner in DestroyerSummoner, line 112")
call T3(y3,o3,O3,l3,"when calling construct_DestroyerSummoner in DestroyerSummoner, line 112")
set Ad=Ad-1
return y3
endfunction
function j3 takes integer h3,integer F3,string k3 returns nothing
set Dd[Ad]=k3
set Ad=Ad+1
call j3u(Zr[h3],F3,"when calling add in DestroyerSummoner, line 87")
set Ad=Ad-1
endfunction
function sgu takes integer wgu,integer ugu,string rgu returns nothing
set Dd[Ad]=rgu
set Ad=Ad+1
if nq[wgu]==0 then
if wgu==0 then
call tsw("Nullpointer exception when calling FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_addSummoner","when calling error in ")
else
call tsw("Called FinalBossSummoning.DestroyerSummoner_FinalBossSummoning_addSummoner on invalid object.","when calling error in ")
endif
endif
call j3(wgu,ugu,"when calling addSummoner in DestroyerSummoner, line 86")
set Ad=Ad-1
endfunction
function S8 takes integer r8,integer s8,string t8 returns nothing
local integer i8
set Dd[Ad]=t8
set Ad=Ad+1
if not pt[r8]then
set i8=p3(wvu(s8,"when calling getPos in EndBoss, line 124"),sf,tf,"when calling new_DestroyerSummoner in EndBoss, line 124")
call sgu(yt[r8],i8,"when calling addSummoner in EndBoss, line 125")
endif
set Ad=Ad-1
endfunction
function dku takes integer qku,integer aku,string nku returns nothing
set Dd[Ad]=nku
set Ad=Ad+1
if ta[qku]==0 then
if qku==0 then
call tsw("Nullpointer exception when calling EndBossFight.EndBoss_EndBossFight_createDestroyerSummoner","when calling error in ")
else
call tsw("Called EndBossFight.EndBoss_EndBossFight_createDestroyerSummoner on invalid object.","when calling error in ")
endif
endif
call S8(qku,aku,"when calling createDestroyerSummoner in EndBoss, line 122")
set Ad=Ad-1
endfunction
function n9 takes integer q9,string a9 returns nothing
set Dd[Ad]=a9
set Ad=Ad+1
call dku(lt,q9,"when calling createDestroyerSummoner in EndBoss, line 94")
set Ad=Ad-1
endfunction
function iku takes integer sku,string tku returns nothing
set Dd[Ad]=tku
set Ad=Ad+1
if Oe[sku]==0 then
if sku==0 then
call tsw("Nullpointer exception when calling EndBoss.EndBoss_EndBoss_castDestroyerSummoner","when calling error in ")
else
call tsw("Called EndBoss.EndBoss_EndBoss_castDestroyerSummoner on invalid object.","when calling error in ")
endif
endif
call n9(sku,"when calling castDestroyerSummoner in EndBoss, line 93")
set Ad=Ad-1
endfunction
function B8 takes integer L8,string X8 returns nothing
local string C8
local string V8
set Dd[Ad]=X8
set Ad=Ad+1
set C8=C0u(EIu(dt[L8],GetRandomInt(0,sPu(dt[L8],"when calling size in EndBoss, line 61")-1),"when calling get in EndBoss, line 61"),"when calling stringFromIndex in EndBoss, line 61")
set V8=C8
if V8=="blockade" then
call NFu(L8,"when calling tryCastTowerBlockade in EndBoss, line 65")
elseif V8=="destroyerSummoner" then
call iku(L8,"when calling castDestroyerSummoner in EndBoss, line 67")
else
call gEw("Ability not implemented :)))")
endif
set Ad=Ad-1
endfunction
function CFu takes integer LFu,string XFu returns nothing
set Dd[Ad]=XFu
set Ad=Ad+1
if Oe[LFu]==0 then
if LFu==0 then
call tsw("Nullpointer exception when calling EndBoss.EndBoss_EndBoss_castAbility","when calling error in ")
else
call tsw("Called EndBoss.EndBoss_EndBoss_castAbility on invalid object.","when calling error in ")
endif
endif
call B8(LFu,"when calling castAbility in EndBoss, line 60")
set Ad=Ad-1
endfunction
function K8 takes string D8 returns nothing
local integer H8
local integer J8
set Dd[Ad]=D8
set Ad=Ad+1
set H8=c2w(GetExpiredTimer(),"when calling getData in EndBoss, line 48")
set at[H8]=at[H8]+1
set J8=qt[H8]
if J8==1 then
if ModuloInteger(at[H8],1*Zp)==0 then
call CFu(H8,"when calling castAbility in EndBoss, line 53")
endif
elseif J8==2 then
if ModuloInteger(at[H8],2*Zp)==0 then
call CFu(H8,"when calling castAbility in EndBoss, line 56")
endif
elseif J8==3 then
call CFu(H8,"when calling castAbility in EndBoss, line 58")
endif
set Ad=Ad-1
endfunction
function t4u takes nothing returns nothing
set Ad=0
call K8("EndBoss, line 31")
endfunction
function tUw takes nothing returns boolean
set WO=340282366920938000000000000000000000000.
return true
endfunction
function u3 takes nothing returns boolean
set Tr=1966092598
set Yr=1848651857
set Gr=1093677642
set gr=99
set hr=666
set Fr=30.
set kr=.05
set jr=45.
return true
endfunction
function u4u takes nothing returns nothing
set Ad=0
call k2("DummyRecycler, line 127")
endfunction
function syw takes string ryw returns boolean
set Dd[Ad]=ryw
set Ad=Ad+1
set Ji=1.01
set Ki=VJw("Sound\\Dialogue\\OrcCampaign\\Orc04Interlude\\O04Mannoroth38.mp3",false,"when calling new_SoundDefinition in GameInit, line 41")
call CameraSetupApplyForceDuration(e,true,0.)
call j2w(b2w("when calling getTimer in GameInit, line 63"),0.025,rg)
set Ad=Ad-1
return true
endfunction
function v1u takes nothing returns boolean
set Ad=0
return syw("GameInit, line 1")
endfunction
function cMu takes integer iMu,string SMu returns nothing
set Dd[Ad]=SMu
set Ad=Ad+1
if Jn[iMu]==0 then
call tsw("Double free: object of type CreateBoss","when calling error in ")
else
set An[Dn]=iMu
set Dn=Dn+1
set Jn[iMu]=0
endif
set Ad=Ad-1
endfunction
function reu takes integer ueu returns nothing
endfunction
function ieu takes integer seu,string teu returns nothing
set Dd[Ad]=teu
set Ad=Ad+1
call reu(seu)
call cMu(seu,"when calling CreateBoss in Wave, line 62")
set Ad=Ad-1
endfunction
function XNu takes integer KNu,string LNu returns nothing
set Dd[Ad]=LNu
set Ad=Ad+1
if Jn[KNu]==0 then
if KNu==0 then
call tsw("Nullpointer exception when calling CreateBoss.destroyCreateBoss","when calling error in ")
else
call tsw("Called CreateBoss.destroyCreateBoss on invalid object.","when calling error in ")
endif
endif
call ieu(KNu,"when calling destroyCreateBoss in Wave, line 62")
set Ad=Ad-1
endfunction
function WW takes integer gW,real hW,real FW,real kW,integer jW,integer xW,real vW,real mW,string QW returns nothing
set Dd[Ad]=QW
set Ad=Ad+1
call gU(gW,hW,FW,kW,jW,xW,vW,mW,"when calling construct_Boss in BossOne, line 7")
set Ad=Ad-1
endfunction
function lfu takes string ofu returns integer
local integer Ofu
set Dd[Ad]=ofu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set Ofu=oe
set Oe[Ofu]=846
else
call tsw("Out of memory: Could not create BossOne.","when calling error in ")
set Ofu=0
endif
else
set ce=ce-1
set Ofu=Se[ce]
set Oe[Ofu]=846
endif
set Ad=Ad-1
return Ofu
endfunction
function GW takes real eW,real qW,real aW,integer nW,integer dW,real fW,real RW,string TW returns integer
local integer YW
set Dd[Ad]=TW
set Ad=Ad+1
set YW=lfu("when calling BossOne in BossOne, line 7")
call WW(YW,eW,qW,aW,nW,dW,fW,RW,"when calling construct_BossOne in BossOne, line 7")
set Ad=Ad-1
return YW
endfunction
function Ewu takes integer hwu,real Fwu,real kwu,real jwu,integer xwu,integer vwu,real mwu,real Qwu,string Wwu returns nothing
set Dd[Ad]=Wwu
set Ad=Ad+1
call GW(Fwu,kwu,jwu,xwu,vwu,mwu,Qwu,"when calling new_BossOne in UnitSpawnSystem, line 107")
set Ad=Ad-1
endfunction
function Ddu takes string Pdu returns integer
local integer Adu
set Dd[Ad]=Pdu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set Adu=oe
set Oe[Adu]=844
else
call tsw("Out of memory: Could not create BossFive.","when calling error in ")
set Adu=0
endif
else
set ce=ce-1
set Adu=Se[ce]
set Oe[Adu]=844
endif
set Ad=Ad-1
return Adu
endfunction
function Cdu takes string Ldu returns integer
local integer Xdu
set Dd[Ad]=Ldu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set Xdu=ae
set ne[Xdu]=658
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set Xdu=0
endif
else
set qe=qe-1
set Xdu=ee[qe]
set ne[Xdu]=658
endif
set Ad=Ad-1
return Xdu
endfunction
function Ndu takes string Vdu returns integer
local integer Bdu
set Dd[Ad]=Vdu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set Bdu=ae
set ne[Bdu]=659
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set Bdu=0
endif
else
set qe=qe-1
set Bdu=ee[qe]
set ne[Bdu]=659
endif
set Ad=Ad-1
return Bdu
endfunction
function Em takes integer Ym,real Gm,real gm,real hm,integer Fm,integer km,real jm,real xm,string vm returns nothing
local integer mm
local integer Qm
local integer Wm
set Dd[Ad]=vm
set Ad=Ad+1
call gU(Ym,Gm,gm,hm,Fm,km,jm,xm,"when calling construct_Boss in BossFive, line 7")
set mm=Cdu("when calling alloc_Closure in BossFive, line 9")
call VC(mm)
set Yw[mm]=Ym
call gX(10.,mm,"when calling doAfter in BossFive, line 9")
set Qm=Ndu("when calling alloc_Closure in BossFive, line 10")
call VC(Qm)
set Gw[Qm]=Ym
set Wm=Qm
set gw[Wm]=jm
set hw[Wm]=xm
call gX(11.,Qm,"when calling doAfter in BossFive, line 10")
set Ad=Ad-1
endfunction
function Tm takes real ym,real pm,real em,integer qm,integer am,real nm,real dm,string fm returns integer
local integer Rm
set Dd[Ad]=fm
set Ad=Ad+1
set Rm=Ddu("when calling BossFive in BossFive, line 7")
call Em(Rm,ym,pm,em,qm,am,nm,dm,"when calling construct_BossFive in BossFive, line 7")
set Ad=Ad-1
return Rm
endfunction
function Guu takes integer euu,real quu,real auu,real nuu,integer duu,integer fuu,real Ruu,real Tuu,string Yuu returns nothing
set Dd[Ad]=Yuu
set Ad=Ad+1
call Tm(quu,auu,nuu,duu,fuu,Ruu,Tuu,"when calling new_BossFive in UnitSpawnSystem, line 119")
set Ad=Ad-1
endfunction
function jfu takes string Ffu returns integer
local integer kfu
set Dd[Ad]=Ffu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set kfu=oe
set Oe[kfu]=848
else
call tsw("Out of memory: Could not create BossTwo.","when calling error in ")
set kfu=0
endif
else
set ce=ce-1
set kfu=Se[ce]
set Oe[kfu]=848
endif
set Ad=Ad-1
return kfu
endfunction
function AZ takes integer EZ,real ZZ returns nothing
local integer UZ
local integer IZ
local integer PZ
call OEw(EZ,ZZ,Qw,Ww,6500.)
set UZ=EZ
set Zw[UZ]=155
set Uw[UZ]=255
set Iw[UZ]=155
set IZ=EZ
set Pw[IZ]=155
set Aw[IZ]=255
set Dw[IZ]=155
set Hw[EZ]=0.
set PZ=EZ
set Zw[PZ]=155
set Uw[PZ]=255
set Iw[PZ]=155
endfunction
function Efu takes string Qfu returns integer
local integer Wfu
set Dd[Ad]=Qfu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set Wfu=Ue
set Ie[Wfu]=645
else
call tsw("Out of memory: Could not create SludgeBuff.","when calling error in ")
set Wfu=0
endif
else
set Ze=Ze-1
set Wfu=Ee[Ze]
set Ie[Wfu]=645
endif
set Ad=Ad-1
return Wfu
endfunction
function WZ takes real vZ,string mZ returns integer
local integer QZ
set Dd[Ad]=mZ
set Ad=Ad+1
set QZ=Efu("when calling SludgeBuff in BossTwo, line 13")
call AZ(QZ,vZ)
set Ad=Ad-1
return QZ
endfunction
function ZDu takes integer QDu,integer WDu,string EDu returns nothing
set Dd[Ad]=EDu
set Ad=Ad+1
if Ie[QDu]==0 then
if QDu==0 then
call tsw("Nullpointer exception when calling ShieldBuff.PresetBuffs_ShieldBuff_apply","when calling error in ")
else
call tsw("Called ShieldBuff.PresetBuffs_ShieldBuff_apply on invalid object.","when calling error in ")
endif
endif
if Ie[QDu]<=644 then
if Ie[QDu]<=643 then
call VWw(QDu,WDu,"when calling apply in PresetBuffs, line 72")
else
call XHw(QDu,WDu,"when calling apply in PresetBuffs, line 72")
endif
else
call VWw(QDu,WDu,"when calling apply in PresetBuffs, line 72")
endif
set Ad=Ad-1
endfunction
function oZ takes integer ME,real wZ,real uZ,real rZ,integer sZ,integer tZ,real iZ,real SZ,string cZ returns nothing
set Dd[Ad]=cZ
set Ad=Ad+1
call gU(ME,wZ,uZ,rZ,sZ,tZ,iZ,SZ,"when calling construct_Boss in BossTwo, line 39")
call ZDu(WZ(99999.,"when calling new_SludgeBuff in BossTwo, line 41"),ME,"when calling apply in BossTwo, line 41")
set Ad=Ad-1
endfunction
function NE takes real DE,real HE,real JE,integer KE,integer LE,real XE,real CE,string VE returns integer
local integer BE
set Dd[Ad]=VE
set Ad=Ad+1
set BE=jfu("when calling BossTwo in BossTwo, line 39")
call oZ(BE,DE,HE,JE,KE,LE,XE,CE,"when calling construct_BossTwo in BossTwo, line 39")
set Ad=Ad-1
return BE
endfunction
function Lwu takes integer Zwu,real Uwu,real Iwu,real Pwu,integer Awu,integer Dwu,real Hwu,real Jwu,string Kwu returns nothing
set Dd[Ad]=Kwu
set Ad=Ad+1
call NE(Uwu,Iwu,Pwu,Awu,Dwu,Hwu,Jwu,"when calling new_BossTwo in UnitSpawnSystem, line 110")
set Ad=Ad-1
endfunction
function LQ takes integer JQ,real KQ returns nothing
call OEw(JQ,KQ,Fw,kw,6500.)
set xw[JQ]=0.
endfunction
function cfu takes string ifu returns integer
local integer Sfu
set Dd[Ad]=ifu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set Sfu=Ue
set Ie[Sfu]=643
else
call tsw("Out of memory: Could not create JumpyBuff.","when calling error in ")
set Sfu=0
endif
else
set Ze=Ze-1
set Sfu=Ee[Ze]
set Ie[Sfu]=643
endif
set Ad=Ad-1
return Sfu
endfunction
function HQ takes real PQ,string AQ returns integer
local integer DQ
set Dd[Ad]=AQ
set Ad=Ad+1
set DQ=cfu("when calling JumpyBuff in BossFour, line 14")
call LQ(DQ,PQ)
set Ad=Ad-1
return DQ
endfunction
function hQ takes integer aQ,real nQ,real dQ,real fQ,integer RQ,integer TQ,real YQ,real GQ,string gQ returns nothing
set Dd[Ad]=gQ
set Ad=Ad+1
call gU(aQ,nQ,dQ,fQ,RQ,TQ,YQ,GQ,"when calling construct_Boss in BossFour, line 33")
call ZDu(HQ(55555.,"when calling new_JumpyBuff in BossFour, line 35"),aQ,"when calling apply in BossFour, line 35")
set Ad=Ad-1
endfunction
function ufu takes string Mdu returns integer
local integer wfu
set Dd[Ad]=Mdu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set wfu=oe
set Oe[wfu]=845
else
call tsw("Out of memory: Could not create BossFour.","when calling error in ")
set wfu=0
endif
else
set ce=ce-1
set wfu=Se[ce]
set Oe[wfu]=845
endif
set Ad=Ad-1
return wfu
endfunction
function qQ takes real SQ,real cQ,real oQ,integer OQ,integer lQ,real bQ,real yQ,string pQ returns integer
local integer eQ
set Dd[Ad]=pQ
set Ad=Ad+1
set eQ=ufu("when calling BossFour in BossFour, line 33")
call hQ(eQ,SQ,cQ,oQ,OQ,lQ,bQ,yQ,"when calling construct_BossFour in BossFour, line 33")
set Ad=Ad-1
return eQ
endfunction
function puu takes integer tuu,real iuu,real Suu,real cuu,integer ouu,integer Ouu,real luu,real buu,string yuu returns nothing
set Dd[Ad]=yuu
set Ad=Ad+1
call qQ(iuu,Suu,cuu,ouu,Ouu,luu,buu,"when calling new_BossFour in UnitSpawnSystem, line 116")
set Ad=Ad-1
endfunction
function mDu takes integer jDu,integer xDu,string vDu returns nothing
set Dd[Ad]=vDu
set Ad=Ad+1
if Ie[jDu]==0 then
if jDu==0 then
call tsw("Nullpointer exception when calling NormalBuff.PresetBuffs_NormalBuff_apply","when calling error in ")
else
call tsw("Called NormalBuff.PresetBuffs_NormalBuff_apply on invalid object.","when calling error in ")
endif
endif
if Ie[jDu]<=644 then
if Ie[jDu]<=643 then
if Ie[jDu]<=641 then
call ZWw(jDu,xDu,"when calling apply in PresetBuffs, line 11")
else
call VWw(jDu,xDu,"when calling apply in PresetBuffs, line 11")
endif
else
call XHw(jDu,xDu,"when calling apply in PresetBuffs, line 11")
endif
elseif Ie[jDu]<=645 then
call VWw(jDu,xDu,"when calling apply in PresetBuffs, line 11")
else
call Wlu(jDu,xDu,"when calling apply in PresetBuffs, line 11")
endif
set Ad=Ad-1
endfunction
function WE takes integer mE,real QE returns nothing
call DWw(mE,QE,vw,mw)
endfunction
function hfu takes string Gfu returns integer
local integer gfu
set Dd[Ad]=Gfu
set Ad=Ad+1
if Ze==0 then
if Ue<32768 then
set Ue=Ue+1
set gfu=Ue
set Ie[gfu]=641
else
call tsw("Out of memory: Could not create PudgePowerBuff.","when calling error in ")
set gfu=0
endif
else
set Ze=Ze-1
set gfu=Ee[Ze]
set Ie[gfu]=641
endif
set Ad=Ad-1
return gfu
endfunction
function vE takes real kE,string jE returns integer
local integer xE
set Dd[Ad]=jE
set Ad=Ad+1
set xE=hfu("when calling PudgePowerBuff in BossThree, line 13")
call WE(xE,kE)
set Ad=Ad-1
return xE
endfunction
function eE takes integer iE,real SE,real cE,real oE,integer OE,integer lE,real bE,real yE,string pE returns nothing
set Dd[Ad]=pE
set Ad=Ad+1
call gU(iE,SE,cE,oE,OE,lE,bE,yE,"when calling construct_Boss in BossThree, line 32")
call mDu(vE(9999.,"when calling new_PudgePowerBuff in BossThree, line 34"),iE,"when calling apply in BossThree, line 34")
set Ad=Ad-1
endfunction
function ffu takes string nfu returns integer
local integer dfu
set Dd[Ad]=nfu
set Ad=Ad+1
if ce==0 then
if oe<32768 then
set oe=oe+1
set dfu=oe
set Oe[dfu]=847
else
call tsw("Out of memory: Could not create BossThree.","when calling error in ")
set dfu=0
endif
else
set ce=ce-1
set dfu=Se[ce]
set Oe[dfu]=847
endif
set Ad=Ad-1
return dfu
endfunction
function tE takes real CW,real VW,real BW,integer NW,integer MW,real wE,real uE,string rE returns integer
local integer sE
set Dd[Ad]=rE
set Ad=Ad+1
set sE=ffu("when calling BossThree in BossThree, line 32")
call eE(sE,CW,VW,BW,NW,MW,wE,uE,"when calling construct_BossThree in BossThree, line 32")
set Ad=Ad-1
return sE
endfunction
function suu takes integer Xwu,real Cwu,real Vwu,real Bwu,integer Nwu,integer Mwu,real wuu,real uuu,string ruu returns nothing
set Dd[Ad]=ruu
set Ad=Ad+1
call tE(Cwu,Vwu,Bwu,Nwu,Mwu,wuu,uuu,"when calling new_BossThree in UnitSpawnSystem, line 113")
set Ad=Ad-1
endfunction
function tMu takes integer CNu,real VNu,real BNu,real NNu,integer MNu,integer wMu,real uMu,real rMu,string sMu returns nothing
set Dd[Ad]=sMu
set Ad=Ad+1
if Jn[CNu]==0 then
if CNu==0 then
call tsw("Nullpointer exception when calling CreateBoss.Wave_CreateBoss_create","when calling error in ")
else
call tsw("Called CreateBoss.Wave_CreateBoss_create on invalid object.","when calling error in ")
endif
endif
if Jn[CNu]<=702 then
if Jn[CNu]<=701 then
if Jn[CNu]<=700 then
call Ewu(CNu,VNu,BNu,NNu,MNu,wMu,uMu,rMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 63")
else
call Lwu(CNu,VNu,BNu,NNu,MNu,wMu,uMu,rMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 63")
endif
else
call suu(CNu,VNu,BNu,NNu,MNu,wMu,uMu,rMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 63")
endif
elseif Jn[CNu]<=703 then
call puu(CNu,VNu,BNu,NNu,MNu,wMu,uMu,rMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 63")
else
call Guu(CNu,VNu,BNu,NNu,MNu,wMu,uMu,rMu,"when calling UnitSpawnSystem_closure_impl in Wave, line 63")
endif
set Ad=Ad-1
endfunction
function Wpu takes integer kpu,string jpu returns nothing
local integer xpu
local integer vpu
local integer mpu
local integer Qpu
set Dd[Ad]=jpu
set Ad=Ad+1
call xKu(Hp[kpu],"when calling play in Wave, line 81")
call gEw("|cffE62121## Attention:|r Boss incoming!")
set xpu=0
set vpu=Ap[kpu]-1
loop
exitwhen xpu>vpu
set mpu=0
set Qpu=Zp
loop
exitwhen mpu>Qpu
call tMu(Jp[kpu],Ycu(fUw(Ep[mpu]),qR),jf,xf,Pp[kpu],Dp[kpu],Up,Ip,"when calling create in Wave, line 85")
set mpu=mpu+1
endloop
set xpu=xpu+1
endloop
call XNu(Jp[kpu],"when calling CreateBoss in Wave, line 86")
set Ad=Ad-1
endfunction
function ANu takes integer INu,string PNu returns nothing
set Dd[Ad]=PNu
set Ad=Ad+1
if Mn[INu]==0 then
if INu==0 then
call tsw("Nullpointer exception when calling BossWave.Wave_BossWave_spawn","when calling error in ")
else
call tsw("Called BossWave.Wave_BossWave_spawn on invalid object.","when calling error in ")
endif
endif
call Wpu(INu,"when calling spawn in Wave, line 80")
set Ad=Ad-1
endfunction
function MMu takes string BMu returns integer
local integer NMu
set Dd[Ad]=BMu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set NMu=ae
set ne[NMu]=694
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set NMu=0
endif
else
set qe=qe-1
set NMu=ee[qe]
set ne[NMu]=694
endif
set Ad=Ad-1
return NMu
endfunction
function VMu takes string XMu returns integer
local integer CMu
set Dd[Ad]=XMu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set CMu=ae
set ne[CMu]=693
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set CMu=0
endif
else
set qe=qe-1
set CMu=ee[qe]
set ne[CMu]=693
endif
set Ad=Ad-1
return CMu
endfunction
function qqu takes integer cqu,string oqu returns nothing
local integer Oqu
local integer lqu
local integer bqu
local integer yqu
local real pqu
local real equ
set Dd[Ad]=oqu
set Ad=Ad+1
call gEw("|cffE62121##|r |cff087BB5B|r|cff0C79B1r|r|cff1077ADa|r|cff1475A9c|r|cff1873A5e|r |cff206F9Dy|r|cff246D99o|r|cff286B95u|r|cff2C6991r|r|cff30678Ds|r|cff346589e|r|cff386385l|r|cff3C6181v|r|cff405F7De|r|cff445D79s|r|cff485B75:|r |cff50576DS|r|cff545569p|r|cff585365e|r|cff5C5161c|r|cff604F5Di|r|cff644D59a|r|cff684B55l|r|cff6C4951s|r |cff744549a|r|cff784345r|r|cff7C4141e|r |cff843D39c|r|cff883B35o|r|cff8C3931m|r|cff90372Di|r|cff943529n|r|cff983325g|r|cff9C3121!|r")
set Oqu=0
set lqu=se[cqu]-1
loop
exitwhen Oqu>lqu
set pqu=Ofw(Oqu)
set bqu=VMu("when calling alloc_Closure in Wave, line 107")
call VC(bqu)
set we[bqu]=cqu
call gX(pqu,bqu,"when calling doAfter in Wave, line 107")
set Oqu=Oqu+1
endloop
set equ=Ofw(se[cqu])
set yqu=MMu("when calling alloc_Closure in Wave, line 110")
call VC(yqu)
set ue[yqu]=cqu
call gX(equ,yqu,"when calling doAfter in Wave, line 110")
set Ad=Ad-1
endfunction
function HMu takes integer AMu,string DMu returns nothing
set Dd[Ad]=DMu
set Ad=Ad+1
if cd[AMu]==0 then
if AMu==0 then
call tsw("Nullpointer exception when calling SpecialWave.Wave_SpecialWave_spawn","when calling error in ")
else
call tsw("Called SpecialWave.Wave_SpecialWave_spawn on invalid object.","when calling error in ")
endif
endif
call qqu(AMu,"when calling spawn in Wave, line 104")
set Ad=Ad-1
endfunction
function aeu takes integer peu,string eeu returns nothing
local timer qeu
set Dd[Ad]=eeu
set Ad=Ad+1
set qeu=b2w("when calling getTimer in Wave, line 33")
call s2w(qeu,peu,"when calling setData in Wave, line 34")
call j2w(qeu,0.1,kg)
set Ad=Ad-1
set qeu=null
endfunction
function xMu takes integer kMu,string jMu returns nothing
set Dd[Ad]=jMu
set Ad=Ad+1
if sd[kMu]==0 then
if kMu==0 then
call tsw("Nullpointer exception when calling NormalWave.Wave_NormalWave_spawn","when calling error in ")
else
call tsw("Called NormalWave.Wave_NormalWave_spawn on invalid object.","when calling error in ")
endif
endif
call aeu(kMu,"when calling spawn in Wave, line 32")
set Ad=Ad-1
endfunction
function V_u takes string C_u returns nothing
set Dd[Ad]=C_u
set Ad=Ad+1
if lp then
set Ad=Ad-1
return
endif
if ModuloInteger(bp,7)==0 and sPu(op,"when calling size in UnitSpawnSystem, line 28")>0 then
call HMu(JIu(op,"when calling dequeue in UnitSpawnSystem, line 29"),"when calling spawn in UnitSpawnSystem, line 29")
else
if sPu(Sp,"when calling size in UnitSpawnSystem, line 31")>0 then
call xMu(JIu(Sp,"when calling dequeue in UnitSpawnSystem, line 32"),"when calling spawn in UnitSpawnSystem, line 32")
endif
if ModuloInteger(bp,4)==0 and sPu(cp,"when calling size in UnitSpawnSystem, line 33")>0 then
call ANu(JIu(cp,"when calling dequeue in UnitSpawnSystem, line 34"),"when calling spawn in UnitSpawnSystem, line 34")
endif
endif
set bp=bp+1
if bp>7 then
set bp=1
endif
if sPu(op,"when calling size in UnitSpawnSystem, line 40")<=0 and sPu(cp,"when calling size in UnitSpawnSystem, line 40")<=0 and sPu(Sp,"when calling size in UnitSpawnSystem, line 40")<=0 then
call a2w(GetExpiredTimer())
endif
set Ad=Ad-1
endfunction
function v4u takes nothing returns nothing
set Ad=0
call V_u("UnitSpawnSystem, line 165")
endfunction
function v4w takes nothing returns boolean
set ly=1114010223
set by=1093677395
return true
endfunction
function O8w takes trigger o8w returns nothing
call EnableTrigger(o8w)
endfunction
function g4 takes integer G4 returns nothing
set ts=ts-1
if G4!=rs then
set Ss[is[G4]]=Ss[G4]
else
set rs=Ss[G4]
endif
if G4!=ss then
set is[Ss[G4]]=is[G4]
else
set ss=is[G4]
endif
endfunction
function ggu takes integer Ygu,string Ggu returns nothing
set Dd[Ad]=Ggu
set Ad=Ad+1
if Tq[Ygu]==0 then
if Ygu==0 then
call tsw("Nullpointer exception when calling Active.DmgMod_Active_LinkedListModule_remove","when calling error in ")
else
call tsw("Called Active.DmgMod_Active_LinkedListModule_remove on invalid object.","when calling error in ")
endif
endif
call g4(Ygu)
set Ad=Ad-1
endfunction
function Y4 takes integer R4,string T4 returns nothing
set Dd[Ad]=T4
set Ad=Ad+1
call ggu(R4,"when calling remove in LinkedListModule, line 49")
set Ad=Ad-1
endfunction
function vgu takes integer jgu,string xgu returns nothing
set Dd[Ad]=xgu
set Ad=Ad+1
if Tq[jgu]==0 then
call tsw("Double free: object of type Active","when calling error in ")
else
set dq[fq]=jgu
set fq=fq+1
set Tq[jgu]=0
endif
set Ad=Ad-1
endfunction
function f4 takes integer n4,string d4 returns nothing
set Dd[Ad]=d4
set Ad=Ad+1
call Y4(n4,"when calling Active_onDestroy in DmgMod, line 58")
call vgu(n4,"when calling Active in DmgMod, line 58")
set Ad=Ad-1
endfunction
function Tgu takes integer fgu,string Rgu returns nothing
set Dd[Ad]=Rgu
set Ad=Ad+1
if Tq[fgu]==0 then
if fgu==0 then
call tsw("Nullpointer exception when calling Active.destroyActive","when calling error in ")
else
call tsw("Called Active.destroyActive on invalid object.","when calling error in ")
endif
endif
call f4(fgu,"when calling destroyActive in DmgMod, line 58")
set Ad=Ad-1
endfunction
function c8w takes trigger S8w returns nothing
call DisableTrigger(S8w)
endfunction
function q8w takes trigger e8w returns boolean
return IsTriggerEnabled(e8w)
endfunction
function a4 takes string b4 returns nothing
local integer y4
local real p4
local real e4
local boolean q4
set Dd[Ad]=b4
set Ad=Ad+1
loop
exitwhen not(rs!=0)
set y4=rs
set p4=GetWidgetLife(Xr[y4])
if ws[y4] and(not us[y4]) then
set e4=p4
else
set e4=Vr[y4]+p4-Br[y4]+Nr[y4]
endif
if us[y4]then
call eiu(Xr[y4],Hr)
endif
if e4-Mr[y4]>0.405 then
call Wiu(Xr[y4],e4-Mr[y4])
else
set q4=q8w(Lr[y4])
call c8w(Lr[y4])
call Fsu(Cr[y4],Xr[y4],Jr+0.)
if q4 then
call O8w(Lr[y4])
endif
endif
call Tgu(y4,"when calling Active in DmgMod, line 96")
endloop
set Ad=Ad-1
endfunction
function w4u takes nothing returns nothing
set Ad=0
call a4("DmgMod, line 74")
endfunction
function wew takes nothing returns boolean
set bS=InitHashtable()
set yS=InitHashtable()
return true
endfunction
function a7w takes string q7w returns boolean
set Dd[Ad]=q7w
set Ad=Ad+1
set Qy=1227894853
set Wy=1747989045
set Ey=1747988548
set Zy=30.0
set Uy=VJw(pb,false,"when calling new_SoundDefinition in TownBell, line 13")
set Py=0
set Ad=Ad-1
return true
endfunction
function x1u takes nothing returns boolean
set Ad=0
return a7w("TownBell, line 1")
endfunction
function x4u takes nothing returns nothing
set Ad=0
call V_u("UnitSpawnSystem, line 163")
endfunction
function x4w takes nothing returns boolean
return true
endfunction
function xYw takes nothing returns boolean
return true
endfunction
function xxw takes nothing returns nothing
call Gxw(GetFilterUnit())
endfunction
function sxw takes integer Njw returns string
local string Mjw=""
local integer wxw=Njw
local integer uxw=0
local integer rxw
loop
exitwhen uxw>3
set rxw=ModuloInteger(wxw,256)
set wxw=wxw/256
set Mjw=pMw(Eo,rxw)+Mjw
set uxw=uxw+1
endloop
return Mjw
endfunction
function ixw takes integer txw returns string
return sxw(txw)
endfunction
function kDu takes string hDu returns integer
local integer FDu
set Dd[Ad]=hDu
set Ad=Ad+1
if qe==0 then
if ae<32768 then
set ae=ae+1
set FDu=ae
set ne[FDu]=682
else
call tsw("Out of memory: Could not create Closure.","when calling error in ")
set FDu=0
endif
else
set qe=qe-1
set FDu=ee[qe]
set ne[FDu]=682
endif
set Ad=Ad-1
return FDu
endfunction
function pWw takes string bWw returns boolean
local integer yWw
set Dd[Ad]=bWw
set Ad=Ad+1
set aO=true
set nO=CreateGroup()
set dO=Iru(cw,cs,0.,0.,0.)
if dO==null then
call tsw("DUMMY_UNITID ("+ixw(cs)+") not added correctly to the map.","when calling error in Preloader, line 48")
endif
if aO then
set yWw=kDu("when calling alloc_Closure in Preloader, line 50")
call VC(yWw)
call kX(yWw,"when calling nullTimer in Preloader, line 50")
endif
set Ad=Ad-1
return true
endfunction
function y1u takes nothing returns boolean
set Ad=0
return pWw("Preloader, line 1")
endfunction
function jru takes nothing returns nothing
set lp=true
call Y2w(Op)
endfunction
function mbw takes string vbw returns nothing
set Dd[Ad]=vbw
set Ad=Ad+1
call gEw("|cffFFCC00>> The Magic Treasure has been destroyed.|r\nYou failed!")
call Y2w(Hi)
call j2w(b2w("when calling getTimer in GameConditions, line 15"),1.,MG)
call jru()
set Ad=Ad-1
endfunction
function y4u takes nothing returns nothing
set Ad=0
call mbw("GameConditions, line 41")
endfunction
function yh takes nothing returns nothing
call CameraSetupApplyForPlayer(true,y,Player(0),0.)
call CameraSetupApplyForPlayer(true,p,Player(0),1.50)
call CameraSetupApplyForPlayer(true,e,Player(0),1.50)
call CameraSetupApplyForPlayer(true,q,Player(0),1.50)
endfunction
function initPlayerArray2 takes nothing returns nothing
local integer i_2=0
local integer temp=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen i_2>temp
set OO[i_2]=Player(i_2)
set i_2=i_2+1
endloop
endfunction
function ymw takes nothing returns boolean
set lO=GetLocalPlayer()
call initPlayerArray2()
return true
endfunction
function Bg takes nothing returns nothing
set w=null
set u=null
set r=null
set s=null
set t=null
set i=null
set S=null
set c=null
set o=null
set O=null
set l=null
set b=null
set y=null
set p=null
set e=null
set q=null
set a=null
set n=null
set d=null
set f=null
set R=null
set T=null
set ce=0
set oe=0
set be=0
set ye=0
set qe=0
set ae=0
set fe=0
set Re=0
set Ge=0
set ge=0
set ke=0
set je=0
set me=0
set Qe=0
set Ze=0
set Ue=0
set Ae=0
set De=0
set Ke=0
set Le=0
set Ve=0
set Be=0
set Me=0
set wq=0
set sq=0
set tq=0
set cq=0
set oq=0
set bq=0
set yq=0
set qq=0
set aq=0
set fq=0
set Rq=0
set Gq=0
set gq=0
set Fq=0
set kq=0
set xq=0
set vq=0
set Wq=0
set Eq=0
set Iq=0
set Pq=0
set Hq=0
set Jq=0
set Xq=0
set Cq=0
set Nq=0
set Mq=0
set ra=0
set sa=0
set Sa=0
set ca=0
set Oa=0
set la=0
set pa=0
set ea=0
set na=0
set da=0
set Ra=0
set Ta=0
set ga=0
set ha=0
set ja=0
set xa=0
set Wa=0
set Ea=0
set Ia=0
set Pa=0
set Ha=0
set Ja=0
set Va=0
set Ba=0
set Na=0
set un=0
set rn=0
set Sn=0
set cn=0
set ln=0
set bn=0
set en=0
set qn=0
set nn=0
set dn=0
set Tn=0
set Yn=0
set Gn=0
set hn=0
set jn=0
set xn=0
set Qn=0
set Wn=0
set Un=0
set In=0
set Dn=0
set Hn=0
set Ln=0
set Xn=0
set Bn=0
set Nn=0
set ud=0
set rd=0
set id=0
set Sd=0
set qT=function lh
set aT=function yh
set nT=function eh
set dT=function Yh
set fT=function Gh
set RT=function tUw
set TT=function cfw
set YT=function gh
set GT=function BMw
set gT=function icu
set hT=function ymw
set FT=function KNw
set kT=function sWw
set jT=function t1u
set xT=function Kyw
set vT=function Dk
set mT=function Dyw
set QT=function ikw
set WT=function xYw
set ET=function Tkw
set ZT=function i1u
set UT=function VEw
set IT=function eEw
set PT=function Krw
set AT=function S1u
set DT=function wew
set HT=function c1u
set JT=function o1u
set KT=function RX
set LT=function W3w
set XT=function AH
set CT=function H4
set VT=function Mdw
set BT=function Sxw
set NT=function HLw
set MT=function JLw
set wY=function x4w
set uY=function O_u
set rY=function MSu
set sY=function Iqu
set tY=function Skw
set iY=function O1u
set SY=function l1u
set cY=function b1u
set oY=function Bjw
set OY=function LL
set lY=function y1u
set bY=function p1u
set yY=function e1u
set pY=function l_u
set eY=function q1u
set qY=function Z3w
set aY=function Exw
set nY=function a1u
set dY=function n1u
set fY=function Kow
set RY=function Jow
set TY=function E0w
set YY=function DNw
set GY=function d1u
set gY=function f1u
set hY=function Low
set FY=function Lh
set kY=function Pk
set jY=function Hk
set xY=function Ox
set vY=function jU
set mY=function ZB
set QY=function bJw
set WY=function nJw
set EY=function Zxw
set ZY=function R1u
set UY=function Bm
set IY=function T1u
set PY=function fA
set AY=function AW
set DY=function UE
set HY=function Y1u
set JY=function u3
set KY=function asw
set LY=function Q5
set XY=function K2w
set CY=function q0w
set VY=function G1u
set BY=function g1u
set NY=function h1u
set MY=function ncw
set wG=function F1u
set uG=function Wxw
set rG=function KLw
set sG=function XVw
set tG=function LLw
set iG=function k1u
set SG=function j1u
set cG=function lFw
set oG=function P8w
set OG=function x1u
set lG=function v1u
set bG=function m1u
set yG=function Q1u
set pG=function W1u
set eG=function E1u
set qG=function Z1u
set aG=function aRw
set nG=function U1u
set dG=function I1u
set fG=function P1u
set RG=function A1u
set TG=function dNw
set YG=function JNw
set GG=function D1u
set gG=function v4w
set hG=function Ebu
set FG=function H1u
set kG=function MJ
set jG=function J1u
set xG=function K1u
set vG=function L1u
set mG=function X1u
set QG=function C1u
set WG=function V1u
set EG=function B1u
set ZG=function N1u
set UG=function M1u
set IG=function PM
set PG=function XM
set AG=function w4u
set DG=function u4u
set HG=function r4u
set JG=function s4u
set KG=function Y9
set LG=function t4u
set XG=function i4u
set CG=function S4u
set VG=function c4u
set BG=function o4u
set NG=function O4u
set MG=function l4u
set wg=function b4u
set ug=function y4u
set rg=function p4u
set sg=function e4u
set tg=function q4u
set ig=function Jyw
set Sg=function Xpw
set cg=function Sfw
set og=function a4u
set Og=function xxw
set lg=function mxw
set bg=function Qxw
set yg=function n4u
set pg=function d4u
set eg=function f4u
set qg=function R4u
set ag=function T4u
set ng=function Y4u
set dg=function G4u
set fg=function V3w
set Rg=function g4u
set Tg=function h4u
set Yg=function F4u
set Gg=function k4u
set gg=function j4u
set hg=function x4u
set Fg=function v4u
set kg=function m4u
set jg=function Q4u
set xg=function W4u
endfunction
function Ng takes nothing returns nothing
call CreateGroup()
call CreateGroup()
call CreateForce()
endfunction
function Oh takes nothing returns nothing
set y=CreateCameraSetup()
call CameraSetupSetField(y,CAMERA_FIELD_ZOFFSET,0.0,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_ROTATION,88.1,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_ANGLE_OF_ATTACK,269.5,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_TARGET_DISTANCE,5178.4,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_ROLL,0.0,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_FIELD_OF_VIEW,70.0,0.0)
call CameraSetupSetField(y,CAMERA_FIELD_FARZ,8857.8,0.0)
call CameraSetupSetDestPosition(y,2153.5,1430.1,0.0)
set p=CreateCameraSetup()
call CameraSetupSetField(p,CAMERA_FIELD_ZOFFSET,0.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_ROTATION,90.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_ANGLE_OF_ATTACK,304.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_TARGET_DISTANCE,1650.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_ROLL,0.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_FIELD_OF_VIEW,70.0,0.0)
call CameraSetupSetField(p,CAMERA_FIELD_FARZ,5000.0,0.0)
call CameraSetupSetDestPosition(p,2171.5,1599.6,0.0)
set e=CreateCameraSetup()
call CameraSetupSetField(e,CAMERA_FIELD_ZOFFSET,0.0,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_ROTATION,90.8,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_ANGLE_OF_ATTACK,321.9,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_TARGET_DISTANCE,5696.2,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_ROLL,0.0,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_FIELD_OF_VIEW,70.0,0.0)
call CameraSetupSetField(e,CAMERA_FIELD_FARZ,10000.0,0.0)
call CameraSetupSetDestPosition(e,11894.7,-928.8,0.0)
set q=CreateCameraSetup()
call CameraSetupSetField(q,CAMERA_FIELD_ZOFFSET,0.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_ROTATION,90.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_ANGLE_OF_ATTACK,304.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_TARGET_DISTANCE,1650.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_ROLL,0.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_FIELD_OF_VIEW,70.0,0.0)
call CameraSetupSetField(q,CAMERA_FIELD_FARZ,5000.0,0.0)
call CameraSetupSetDestPosition(q,11739.7,-476.3,0.0)
set a=CreateCameraSetup()
call CameraSetupSetField(a,CAMERA_FIELD_ZOFFSET,0.0,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_ROTATION,90.0,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_ANGLE_OF_ATTACK,304.0,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_TARGET_DISTANCE,13431.5,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_ROLL,0.0,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_FIELD_OF_VIEW,70.0,0.0)
call CameraSetupSetField(a,CAMERA_FIELD_FARZ,7320.5,0.0)
call CameraSetupSetDestPosition(a,2424.6,1759.9,0.0)
endfunction
function bh takes nothing returns nothing
set n=CreateTrigger()
call TriggerAddAction(n,qT)
endfunction
function ph takes nothing returns nothing
set d=CreateTrigger()
call TriggerAddAction(d,aT)
endfunction
function qh takes nothing returns nothing
set f=CreateTrigger()
call TriggerAddAction(f,nT)
endfunction
function ah takes nothing returns nothing
call bh()
call ph()
call qh()
endfunction
function rh takes nothing returns nothing
local player uh=Player(8)
call CreateUnit(uh,1747988548,1572.2,1225.6,75.625)
call CreateUnit(uh,1747988548,2692.4,1074.6,167.672)
call CreateUnit(uh,1747988548,2791.5,2055.3,245.154)
call CreateUnit(uh,1747988548,1944.9,2346.8,317.448)
call CreateUnit(uh,1747988548,11015.8,344.7,338.577)
call CreateUnit(uh,1747988548,10816.3,-1406.8,292.862)
call CreateUnit(uh,1747988548,12896.9,-1328.8,262.199)
call CreateUnit(uh,1747988548,12725.4,417.5,140.251)
call CreateUnit(uh,1747988548,12771.2,-1218.1,85.048)
call CreateUnit(uh,1747988548,10913.2,-1260.8,12.948)
call CreateUnit(uh,1747988548,12665.1,285.3,259.360)
call CreateUnit(uh,1747988548,10982.0,536.8,144.404)
set uh=null
endfunction
function Sh takes nothing returns nothing
call rh()
endfunction
function wh takes nothing returns nothing
local player Mg=Player(8)
set T=CreateUnit(Mg,1747988549,11776.0,-512.0,270.000)
set R=CreateUnit(Mg,1747988549,2176.0,1664.0,270.000)
set Mg=null
endfunction
function ih takes nothing returns nothing
call wh()
endfunction
function th takes nothing returns nothing
local player sh=Player(PLAYER_NEUTRAL_PASSIVE)
call CreateUnit(sh,1966092595,-260.6,-191.0,273.410)
set sh=null
endfunction
function ch takes nothing returns nothing
call ih()
call th()
call Sh()
endfunction
function oh takes nothing returns nothing
set w=Rect(1120.0,-864.0,3264.0,-768.0)
set u=Rect(1344.0,4032.0,3488.0,4128.0)
set r=Rect(-384.0,1088.0,-288.0,2848.0)
set s=Rect(4576.0,800.0,4672.0,2560.0)
set t=Rect(6848.0,-3040.0,6976.0,-1568.0)
set i=Rect(6848.0,1280.0,6976.0,3008.0)
set S=Rect(9088.0,4288.0,10976.0,4416.0)
set c=Rect(13344.0,4192.0,14816.0,4320.0)
set o=Rect(16608.0,512.0,16736.0,1984.0)
set O=Rect(16672.0,-3072.0,16800.0,-1568.0)
set l=Rect(13408.0,-5280.0,14752.0,-5152.0)
set b=Rect(8736.0,-5280.0,10144.0,-5152.0)
endfunction
function main takes nothing returns nothing
local weathereffect Rh
local trigger Th
call Bg()
call SetCameraBounds((-1280.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),(-5632.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM),17664.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),5120.0-GetCameraMargin(CAMERA_MARGIN_TOP),(-1280.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),5120.0-GetCameraMargin(CAMERA_MARGIN_TOP),17664.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),(-5632.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl","Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
call SetTerrainFogEx(0,600.0,5000.0,0.500,0.078,0.078,0.196)
call SetWaterBaseColor(100,100,150,255)
set Rh=AddWeatherEffect(Rect(-2048.0,-6144.0,18432.0,6144.0),1380019314)
call EnableWeatherEffect(Rh,true)
call NewSoundEnvironment("Default")
call SetAmbientDaySound("VillageDay")
call SetAmbientNightSound("VillageNight")
call SetMapMusic("Music",true,0)
call oh()
call Oh()
call ch()
call InitBlizzard()
call Ng()
call ah()
set Th=CreateTrigger()
call TriggerAddCondition(Th,Condition(dT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Abilities.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(fT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package AbilityIds.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(RT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Real.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(TT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Integer.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(YT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Angle.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(GT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Table.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(gT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Vectors.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(hT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Player.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(FT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package String.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(kT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Playercolor.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(jT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Colors.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(xT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Group.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(vT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Basics.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(mT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GameTimer.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(QT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MagicFunctions.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(WT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Lightning.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(ET))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Maths.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(ZT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TypeCasting.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(UT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Printing_config.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(IT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Printing.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(PT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ErrorHandling.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(AT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TimerUtils.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(DT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashList.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(HT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EventHelper.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(JT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RegisterEvents.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(KT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureTimers.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(LT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TargetsAllowed.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(XT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Buildings.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(CT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Doodads.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(VT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Icons.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(BT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Objects.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(NT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Sounds.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(MT))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Soundsets.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(wY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Textures.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(uY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UI.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(rY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Units.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(sY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WeatherEffects.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(tY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MapBounds.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(iY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DummyRecycler.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(SY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LinkedList.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(cY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package StringUtils.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(oY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIds.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(OY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureForGroups.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(lY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Preloader.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(bY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIdGenerator.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(yY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnUnitEnterLeave.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(pY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIndexer.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(eY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureEvents.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(qY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TerrainUtils.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(aY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PhysicsConstants.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(nY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DmgMod.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(dY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package FText.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(fY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Frentity_config.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(RY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Frentity.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(TY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Entity.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(YY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Squares.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(GY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Buff.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(gY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Tower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(hY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package FxEntity.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(FY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ArtilleryTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(kY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package AssassinTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(jY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BigNum.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(xY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BigString.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(vY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Bounty.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(mY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Creep.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(QY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Simulate3dSound.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(WY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package SoundUtils.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(EY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PhysicsEntity.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(ZY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Boss.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(UY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BossFour.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(IY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WarningBuff.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(PY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Builder.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(AY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BossThree.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(DY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BossTwo.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(HY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DebugInfo.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(JY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DestroyerSummoner.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(KY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Execute.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(LY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Encoder.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(XY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TowerBlockade.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(CY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EndGame.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(VY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EndBoss.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(BY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EntityManagement.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(NY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package FieldGenerator.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(MY))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package FlamethrowerTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(wG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Rocket.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(uG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Orders.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(rG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Special.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(sG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package SpecialTwo.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(tG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package SpecialFive.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(iG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitSpawnSystem.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(SG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PlayerData.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(cG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LumberAndCoinSystem.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(oG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TrooperTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(OG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TownBell.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(lG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GameInit.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(bG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GroupUtils.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(yG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HealbackTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(pG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package InstanceBoard.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(eG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LZW.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(qG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Json.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(aG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package JsonParser.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(nG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MultiboardSystem.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(dG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Reinforcements.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(fG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Selector.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(RG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ShieldKit.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(TG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package SphereTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(YG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package StompingTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(GG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package SuperCharge.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(gG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ThermoTower.")
endif
call TriggerClearConditions(Th)
call TriggerAddCondition(Th,Condition(hG))
if not TriggerEvaluate(Th) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WaveTower.")
endif
call TriggerClearConditions(Th)
call DestroyTrigger(Th)
set Rh=null
set Th=null
endfunction
function dh takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerState(Player(0),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(1),0)
call SetPlayerState(Player(1),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(2),0)
call SetPlayerState(Player(2),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(3),0)
call SetPlayerState(Player(3),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(4),0)
call SetPlayerState(Player(4),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(5),0)
call SetPlayerState(Player(5),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(6),0)
call SetPlayerState(Player(6),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(7),0)
call SetPlayerState(Player(7),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerTeam(Player(8),0)
call SetPlayerState(Player(8),PLAYER_STATE_ALLIED_VICTORY,1)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(0),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(0),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(0),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(1),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(2),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(3),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(4),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(5),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(7),true)
call SetPlayerAllianceStateVisionBJ(Player(6),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(7),Player(8),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(0),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(1),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(2),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(3),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(4),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(5),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(6),true)
call SetPlayerAllianceStateVisionBJ(Player(8),Player(7),true)
call SetPlayerTeam(Player(9),1)
call SetPlayerState(Player(9),PLAYER_STATE_ALLIED_VICTORY,1)
endfunction
function fh takes nothing returns nothing
call SetStartLocPrioCount(0,7)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,7)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,7)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,7)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,7)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,7)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,7)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,7)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
endfunction
function nh takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(0),false)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(1),false)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(2),false)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(3),false)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(4),false)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(5),false)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call ForcePlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(6),false)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call ForcePlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(7),false)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call ForcePlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(8),false)
call SetPlayerController(Player(8),MAP_CONTROL_COMPUTER)
call SetPlayerStartLocation(Player(9),9)
call ForcePlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_UNDEAD)
call SetPlayerRaceSelectable(Player(9),false)
call SetPlayerController(Player(9),MAP_CONTROL_COMPUTER)
endfunction
function config takes nothing returns nothing
call SetMapName("TRIGSTR_1675")
call SetMapDescription("TRIGSTR_014")
call SetPlayers(10)
call SetTeams(10)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,2176.0,1664.0)
call DefineStartLocation(1,2176.0,1664.0)
call DefineStartLocation(2,2176.0,1664.0)
call DefineStartLocation(3,2176.0,1664.0)
call DefineStartLocation(4,2176.0,1664.0)
call DefineStartLocation(5,2176.0,1664.0)
call DefineStartLocation(6,2176.0,1664.0)
call DefineStartLocation(7,2176.0,1664.0)
call DefineStartLocation(8,2176.0,1664.0)
call DefineStartLocation(9,2176.0,1664.0)
call nh()
call dh()
call fh()
endfunction
